1
00:00:01,000 --> 00:00:02,000
我想打扣

2
00:00:02,000 --> 00:00:04,400
為什麼我們的教授都不讓我打扣

3
00:00:04,400 --> 00:00:06,400
都要叫我學 OS 要我背季節

4
00:00:06,400 --> 00:00:08,100
然後研究所還要考這個

5
00:00:08,100 --> 00:00:09,200
不能理解

6
00:00:09,200 --> 00:00:11,100
所以我今天要跟大家談談

7
00:00:11,100 --> 00:00:14,800
為什麼我們要學計算機結構和作業系統

8
00:00:14,800 --> 00:00:17,000
那會想講這個主題是因為

9
00:00:17,000 --> 00:00:18,800
縱觀大部分資訊工程學系

10
00:00:18,800 --> 00:00:20,800
我們會發現

11
00:00:20,800 --> 00:00:23,200
真正打到扣的課程

12
00:00:23,200 --> 00:00:24,500
只有大一的程式設計

13
00:00:24,500 --> 00:00:26,500
和後面一部分的小課程

14
00:00:26,500 --> 00:00:27,900
而其他非常非常多

15
00:00:27,900 --> 00:00:30,800
資工系本科學的這些知識

16
00:00:30,800 --> 00:00:34,500
更多的相關在計算機相關上的知識

17
00:00:34,500 --> 00:00:36,400
那並不是我們真的要去打扣

18
00:00:36,400 --> 00:00:37,700
要去寫演算法

19
00:00:37,700 --> 00:00:39,900
那這對於我們這些

20
00:00:39,900 --> 00:00:41,100
勵志念資工系

21
00:00:41,100 --> 00:00:42,400
可能是想要做網頁開發

22
00:00:42,400 --> 00:00:44,200
可能是想要做應用程式開發

23
00:00:44,200 --> 00:00:46,800
又或者是就是想設計一套演算法的學生來說

24
00:00:46,800 --> 00:00:48,500
會覺得有點迷惘

25
00:00:48,500 --> 00:00:49,400
就我進了這個系

26
00:00:49,400 --> 00:00:51,300
我以為我以後會成為 APP 大師

27
00:00:51,300 --> 00:00:53,100
結果不然

28
00:00:53,100 --> 00:00:54,800
所以對於一個

29
00:00:54,800 --> 00:00:56,800
憧憬想要寫厲害程式碼

30
00:00:56,800 --> 00:00:59,900
想要跟連續劇裡面的黑客一樣的學生來說

31
00:00:59,900 --> 00:01:02,200
為什麼我們要去學計算機結構

32
00:01:02,200 --> 00:01:04,800
為什麼要去學 OS 這兩門

33
00:01:04,800 --> 00:01:07,800
大家都有的備科呢

34
00:01:07,800 --> 00:01:09,500
大家都俗稱他是備科

35
00:01:09,500 --> 00:01:11,500
那這兩個真的只是備科嗎

36
00:01:11,500 --> 00:01:13,800
他真的只能用來刷 GPA 嗎

37
00:01:13,800 --> 00:01:15,300
這是我希望在這場議程

38
00:01:15,300 --> 00:01:16,300
接下來的時間

39
00:01:16,300 --> 00:01:18,900
跟大家討論的

40
00:01:18,900 --> 00:01:19,700
那首先

41
00:01:19,700 --> 00:01:20,900
我們這是一場嚴謹的議程

42
00:01:20,900 --> 00:01:23,200
所以我們先講一下我的實驗環境

43
00:01:23,200 --> 00:01:24,900
我是用 Ubuntu 20.04

44
00:01:24,900 --> 00:01:27,000
那為了因應我們的贊助商 AMD

45
00:01:27,000 --> 00:01:30,900
我今天使用了 APEX 7742 RYZEN 2 的 CPU

46
00:01:30,900 --> 00:01:32,000
非常的給面子

47
00:01:32,000 --> 00:01:33,500
這是他們伺服器等級

48
00:01:33,500 --> 00:01:36,800
現在前一代或最新的 CPU

49
00:01:36,800 --> 00:01:38,000
他含有的 Cache

50
00:01:38,000 --> 00:01:39,500
如果大家已經學過的話就知道

51
00:01:39,500 --> 00:01:41,100
他的 L1 Cache 有 2MB

52
00:01:41,100 --> 00:01:43,600
L2 Cache 有 32MB

53
00:01:43,600 --> 00:01:45,200
L3 Cache 有 256MB

54
00:01:45,200 --> 00:01:48,700
那支援除了 AVX-512 以外的平行指令集

55
00:01:48,700 --> 00:01:50,700
然後我使用的記憶體是 DDR4

56
00:01:50,700 --> 00:01:53,300
那他是 3200MHZ

57
00:01:53,400 --> 00:01:55,600
然後最後我使用的是 G++ 的 Compiler

58
00:01:55,600 --> 00:01:57,000
那 9.4.0

59
00:01:57,000 --> 00:01:58,400
好 那講到這邊

60
00:01:58,400 --> 00:02:01,000
這些參數看不懂的可以幫我舉一下手嗎

61
00:02:04,100 --> 00:02:05,000
喔 好

62
00:02:05,000 --> 00:02:05,900
那好像不是很多

63
00:02:05,900 --> 00:02:07,700
所以大家可能都修過季節了

64
00:02:07,700 --> 00:02:08,900
那在開始之前呢

65
00:02:08,900 --> 00:02:10,500
請大家幫我打開共筆

66
00:02:10,500 --> 00:02:13,300
那共筆在 C-COM 官網的

67
00:02:13,300 --> 00:02:15,200
我的議程點進去有一個共筆

68
00:02:15,200 --> 00:02:18,300
那裡面呢有這一場直播的 Live

69
00:02:18,300 --> 00:02:19,400
就是我一個 Keynote Live

70
00:02:19,400 --> 00:02:21,500
不管你是不是 Apple 使用者都可以打開

71
00:02:21,500 --> 00:02:22,900
那在你的電腦上看簡報

72
00:02:22,900 --> 00:02:24,800
更清晰更直觀比這個螢幕好一點

73
00:02:24,800 --> 00:02:27,000
好 那避免它黑掉

74
00:02:27,000 --> 00:02:29,000
好 那我們來講這個

75
00:02:29,000 --> 00:02:30,800
你的時間不是我的時間

76
00:02:30,800 --> 00:02:32,900
我們接下來的東西全部都跟時間有關的

77
00:02:32,900 --> 00:02:35,000
在 C-COM 裡面我們最在意的東西就兩個

78
00:02:35,000 --> 00:02:36,600
要嘛時間 要嘛空間

79
00:02:36,600 --> 00:02:38,600
好 那我們待會講到的時間呢

80
00:02:38,600 --> 00:02:39,600
會有四種時間

81
00:02:39,600 --> 00:02:41,300
一種是 Linux 的 time 指令

82
00:02:41,300 --> 00:02:42,400
大家可能都用過

83
00:02:42,400 --> 00:02:45,400
time 加上你的程式會隔出你這個程式的執行時間

84
00:02:45,400 --> 00:02:46,800
像上面那樣的結果

85
00:02:46,800 --> 00:02:48,100
它分為三種

86
00:02:48,100 --> 00:02:49,100
第一個是 real

87
00:02:49,200 --> 00:02:52,000
就是這個程式真實執行的時間

88
00:02:52,000 --> 00:02:52,900
什麼是真實

89
00:02:52,900 --> 00:02:54,500
你的感官就是真實

90
00:02:54,500 --> 00:02:55,900
所以我們人

91
00:02:55,900 --> 00:02:57,200
想像我們程式執行下去

92
00:02:57,200 --> 00:02:58,000
按下碼表

93
00:02:58,000 --> 00:02:59,800
到它結束又按一下碼表

94
00:02:59,800 --> 00:03:01,700
這個時間就是 real

95
00:03:01,700 --> 00:03:03,500
real 時間會包含兩部分

96
00:03:03,500 --> 00:03:05,900
第一部分就是系統佔用的時間

97
00:03:05,900 --> 00:03:08,700
第二部分是你程式真正執行的時間

98
00:03:08,700 --> 00:03:10,200
可能聽過 OS 的朋友知道

99
00:03:10,200 --> 00:03:12,600
我們的程式在我們的電腦裡面跑

100
00:03:12,600 --> 00:03:15,100
有一部分的時間是交給 OS 來決定

101
00:03:15,100 --> 00:03:16,900
所以 sys 代表的就是

102
00:03:16,900 --> 00:03:18,600
非你這支程式使用的時間

103
00:03:18,600 --> 00:03:20,300
就是被系統打走的時間

104
00:03:20,300 --> 00:03:23,700
那 user 就是使用者使用的時間

105
00:03:23,700 --> 00:03:26,100
那接著我們來看一下就是

106
00:03:26,100 --> 00:03:27,100
另外幾個指令

107
00:03:27,100 --> 00:03:29,100
就是 time

108
00:03:29,100 --> 00:03:30,800
time.h 裡面的 time

109
00:03:30,800 --> 00:03:33,700
那 time.h 裡面的 time 呢

110
00:03:33,700 --> 00:03:35,400
等我一下喔

111
00:03:35,400 --> 00:03:37,500
time.h 裡面的 time 只能記錄到秒

112
00:03:37,500 --> 00:03:40,200
所以有時候對 C++ 開發者來說不方便

113
00:03:40,200 --> 00:03:41,600
而後面的 clock 呢

114
00:03:41,600 --> 00:03:43,900
大家可能是最常看到的一個 function

115
00:03:43,900 --> 00:03:45,700
但它在 C++ 裡面呈現的

116
00:03:45,700 --> 00:03:47,700
這個結果就是在 Linux 裡面

117
00:03:47,700 --> 00:03:49,900
和 Windows 裡面會有不同的結果

118
00:03:49,900 --> 00:03:51,800
Linux 裡面計算的是 CPU 的時間

119
00:03:51,800 --> 00:03:53,200
也就是 user

120
00:03:53,200 --> 00:03:54,200
那在 Windows 裡面呢

121
00:03:54,200 --> 00:03:56,600
則計算的是 volt time 就是 real

122
00:03:56,600 --> 00:03:58,000
那最後最好的一個方式

123
00:03:58,000 --> 00:03:59,900
應該是用 high-resolution clock

124
00:03:59,900 --> 00:04:01,900
這個就會讓兩者都呈現相同的時間

125
00:04:01,900 --> 00:04:03,200
而且非常精準

126
00:04:03,200 --> 00:04:05,300
那接下來的程式碼中

127
00:04:05,300 --> 00:04:06,500
可能會包含這些東西

128
00:04:06,500 --> 00:04:07,800
請大家稍微注意一下

129
00:04:07,800 --> 00:04:08,800
分清楚誰是 volt time

130
00:04:08,800 --> 00:04:10,000
誰是 CPU 時間

131
00:04:10,000 --> 00:04:11,400
可以更有效幫助我們學習

132
00:04:11,400 --> 00:04:13,200
計算機結構和 OS

133
00:04:13,200 --> 00:04:14,900
好

134
00:04:14,900 --> 00:04:17,200
OK 那來問一下大家

135
00:04:17,300 --> 00:04:19,600
我猜剛剛有舉手的

136
00:04:19,600 --> 00:04:21,400
可能是還沒學過記捷和 OS

137
00:04:21,400 --> 00:04:22,800
所以沒舉手的朋友

138
00:04:22,800 --> 00:04:26,000
大家對於這個東西還記得什麼

139
00:04:26,000 --> 00:04:27,400
我們思考一下

140
00:04:27,400 --> 00:04:29,900
我記得老師說這個 CPU 非常複雜

141
00:04:29,900 --> 00:04:31,700
裡面有五個的 pipeline 非常複雜

142
00:04:31,700 --> 00:04:33,800
然後就忘光了 沒了 對不對

143
00:04:33,800 --> 00:04:35,000
我們就記得那一堆指令集

144
00:04:35,000 --> 00:04:36,300
我們也知道有的東西叫指令集

145
00:04:36,300 --> 00:04:37,500
但是指令集裡面有什麼

146
00:04:37,500 --> 00:04:38,800
load 跟 store 沒了

147
00:04:38,800 --> 00:04:40,600
就忘光了

148
00:04:40,600 --> 00:04:42,500
計算機結構的課非常精彩

149
00:04:42,500 --> 00:04:44,100
非常多內容 非常豐富

150
00:04:44,100 --> 00:04:45,300
但是在考完試之後

151
00:04:45,300 --> 00:04:46,700
卻被我們當作一個貝殼

152
00:04:46,700 --> 00:04:48,000
背完就忘

153
00:04:48,000 --> 00:04:49,800
之後看到還想不太起來

154
00:04:49,800 --> 00:04:51,700
我覺得這是一個非常令人難過的現象

155
00:04:51,700 --> 00:04:55,300
所以我們今天要反它一個公道

156
00:04:55,300 --> 00:04:56,500
那怎麼反它一個公道呢

157
00:04:56,500 --> 00:04:58,200
就是證明它有用

158
00:04:58,200 --> 00:05:00,000
我們知道演算法對於我們程式的加速

159
00:05:00,000 --> 00:05:00,700
非常有用

160
00:05:00,700 --> 00:05:03,500
一下就是幾個時間級數的跳躍

161
00:05:03,500 --> 00:05:05,400
那計算機結構和 OS 呢

162
00:05:05,400 --> 00:05:07,500
我們用三個例子來證明它

163
00:05:07,500 --> 00:05:08,700
好像有這麼點用

164
00:05:08,700 --> 00:05:11,600
學會它 把課程上的內容了解透

165
00:05:11,600 --> 00:05:12,600
了解明白

166
00:05:12,600 --> 00:05:14,300
也可能讓你的程式有加速

167
00:05:14,300 --> 00:05:17,000
或者是省空間的效果

168
00:05:17,000 --> 00:05:18,200
第一個 case 是

169
00:05:18,200 --> 00:05:20,100
浪費時間排序陣列

170
00:05:20,100 --> 00:05:22,600
程式執行卻變快了

171
00:05:22,600 --> 00:05:24,900
這句話大家仔細思考一下

172
00:05:24,900 --> 00:05:27,000
排序陣列的演算法複雜度

173
00:05:27,000 --> 00:05:28,900
ONlogN嘛 大家都學過

174
00:05:28,900 --> 00:05:32,400
那我們花了 ONlogN 的時間去排序陣列

175
00:05:32,400 --> 00:05:35,400
卻導致整支程式的執行時間變快了

176
00:05:35,400 --> 00:05:36,600
不科學

177
00:05:36,600 --> 00:05:38,200
那為什麼會這樣呢

178
00:05:38,200 --> 00:05:41,000
我們今天就是要來解答這個問題

179
00:05:41,000 --> 00:05:42,400
那這個問題的前言是

180
00:05:42,400 --> 00:05:44,300
我們都知道在寫程式前

181
00:05:44,300 --> 00:05:46,900
評估時間複雜度是一個很重要的步驟

182
00:05:46,900 --> 00:05:49,400
因為它可以確保你的程式運行得足夠快

183
00:05:49,400 --> 00:05:52,700
然後滿足你在生活或者是考試上的需求

184
00:05:52,700 --> 00:05:53,700
那舉例而言

185
00:05:53,700 --> 00:05:56,200
排序陣列我剛才說的是一個很耗時的動作

186
00:05:56,200 --> 00:05:59,100
大家都會說 ONlogN 能掃排就掃排

187
00:05:59,100 --> 00:06:00,800
能排完記者就記得

188
00:06:00,800 --> 00:06:03,300
那為什麼在接下來這個程式碼中

189
00:06:03,300 --> 00:06:05,400
排了卻變快了

190
00:06:05,400 --> 00:06:06,400
好 我們看一下這個程式碼

191
00:06:06,400 --> 00:06:07,200
如果看不到的話

192
00:06:07,200 --> 00:06:09,500
看一下你剛剛打開的 Keynote screen

193
00:06:09,500 --> 00:06:10,800
這程式碼有點重要

194
00:06:10,800 --> 00:06:13,400
所以我們在這一頁停留一些時間

195
00:06:13,400 --> 00:06:15,700
那這段程式碼主要分為三個部分

196
00:06:15,700 --> 00:06:17,800
第一個部分就是我們建立一個 Array

197
00:06:17,800 --> 00:06:20,400
然後在這個 Array 裡面填入亂數

198
00:06:20,400 --> 00:06:22,400
所以到 RAND%256 那一段

199
00:06:22,400 --> 00:06:27,800
是在一個 Array 中填入一堆 0-255 的亂數

200
00:06:27,800 --> 00:06:30,900
第二部分我們用 Sort 來排序這個陣列

201
00:06:30,900 --> 00:06:32,700
這行 Keyword

202
00:06:32,700 --> 00:06:34,400
好 大家把這行記起來

203
00:06:34,400 --> 00:06:36,600
待會有沒有這行會影響結果

204
00:06:36,600 --> 00:06:38,000
好 那最上面呢

205
00:06:38,200 --> 00:06:41,600
Clock T Start 是計時開始

206
00:06:41,600 --> 00:06:43,800
接著呢 我們為了凸顯這個結果

207
00:06:43,800 --> 00:06:46,400
做了一萬次 多做了一萬次

208
00:06:46,400 --> 00:06:47,900
還是十萬 好 十萬次

209
00:06:47,900 --> 00:06:50,200
那在組回圈裡面我們做的事情是什麼呢

210
00:06:50,200 --> 00:06:51,600
我們做的事情很簡單

211
00:06:51,600 --> 00:06:56,200
把這個陣列裡面所有大於 128 的數加總

212
00:06:56,200 --> 00:06:57,400
就會得到一個總和

213
00:06:57,400 --> 00:06:59,000
這就是程式做的事情

214
00:06:59,000 --> 00:07:02,200
有一個陣列 N 個數字

215
00:07:02,200 --> 00:07:03,500
裡面只有 0-255

216
00:07:03,500 --> 00:07:06,900
那我們把所有的大於 128 的數加起來

217
00:07:06,900 --> 00:07:09,700
好 這就是程式做的事情 非常簡單

218
00:07:09,700 --> 00:07:12,600
那我們來看一下 它發生什麼事了

219
00:07:12,600 --> 00:07:15,900
當我們今天在前面 STD Sort 的那一行

220
00:07:15,900 --> 00:07:18,200
先排序這個陣列

221
00:07:18,200 --> 00:07:21,400
結果 整支程式的時間居然變快了

222
00:07:21,400 --> 00:07:23,800
如果你沒加那一行 不排序 直接去加

223
00:07:23,800 --> 00:07:25,300
它花了 20 秒

224
00:07:25,300 --> 00:07:28,900
那你加了那一行 它居然只花了 8 秒

225
00:07:28,900 --> 00:07:32,100
為什麼差了這個 2.5 倍到 3 倍的時間呢

226
00:07:32,100 --> 00:07:33,100
令人深思

227
00:07:33,100 --> 00:07:34,300
這不符合我們演算法

228
00:07:34,400 --> 00:07:37,200
沒有人說加了一行 N log N 的東西還變快

229
00:07:37,200 --> 00:07:39,500
不科學

230
00:07:39,500 --> 00:07:41,400
那是什麼讓它快了 2.5 倍

231
00:07:41,400 --> 00:07:42,200
大家想一下

232
00:07:42,200 --> 00:07:44,100
如果已經學過季節的人 朋友想一下

233
00:07:44,100 --> 00:07:46,400
沒學過季節的人 通靈一下

234
00:07:46,400 --> 00:07:47,200
說不定就通出來了

235
00:07:47,200 --> 00:07:51,400
通出來就來找我覺得非常優秀之才

236
00:07:51,400 --> 00:07:52,600
我們來看一下

237
00:07:52,600 --> 00:07:55,600
這個的影響來自 Branch Prediction

238
00:07:55,600 --> 00:07:58,200
如果有人看到這個詞 就知道為什麼了

239
00:07:58,200 --> 00:08:01,300
那我覺得你應該往這方面努力前進一下

240
00:08:01,300 --> 00:08:03,800
那對於不知道 Branch Prediction 是什麼的朋友

241
00:08:03,800 --> 00:08:05,200
我們來說明一下

242
00:08:05,200 --> 00:08:06,600
想想今天有一個情況

243
00:08:06,600 --> 00:08:10,000
在通訊部發達的 1800 年代

244
00:08:10,000 --> 00:08:11,500
有一個東西長這樣

245
00:08:11,500 --> 00:08:13,900
這是一個火車軌道

246
00:08:13,900 --> 00:08:15,300
它會分成兩條

247
00:08:15,300 --> 00:08:16,300
那今天呢

248
00:08:16,300 --> 00:08:18,400
這個火車軌道旁邊都會有一個 trunk

249
00:08:18,400 --> 00:08:19,400
什麼是 trunk 呢

250
00:08:19,400 --> 00:08:21,300
就是你拉下去 火車往右走

251
00:08:21,300 --> 00:08:24,600
你推回來 火車往左走的這個裝置

252
00:08:24,600 --> 00:08:26,900
那今天一個火車的這個車長

253
00:08:26,900 --> 00:08:28,700
他如果開過來

254
00:08:28,700 --> 00:08:31,700
每次都要停下來去拉這個 trunk

255
00:08:31,700 --> 00:08:33,000
這個時候他是不是很花時間

256
00:08:33,100 --> 00:08:34,400
因為火車減速再加速

257
00:08:34,400 --> 00:08:36,300
大家知道是花時間的

258
00:08:36,300 --> 00:08:38,400
那這是一個非常沒有效率的做法

259
00:08:38,400 --> 00:08:40,800
那我們要怎麼樣加速這個做法呢

260
00:08:40,800 --> 00:08:42,500
顯而易見的就是

261
00:08:42,500 --> 00:08:45,800
我們來猜下一輛火車的目的地

262
00:08:45,800 --> 00:08:46,700
那你今天假設

263
00:08:46,700 --> 00:08:48,800
你都有把這個 trunk 往右拉

264
00:08:48,800 --> 00:08:51,100
假設下一輛火車就往右邊走了

265
00:08:51,100 --> 00:08:52,600
那這個火車長很開心

266
00:08:52,600 --> 00:08:54,800
都不用停下來跟你說了

267
00:08:54,800 --> 00:08:56,000
但如果你猜錯了

268
00:08:56,000 --> 00:08:57,600
火車長還是要停下來跟你說

269
00:08:57,600 --> 00:08:58,800
幫我們拉回來

270
00:08:58,800 --> 00:09:00,900
然後你就火車繼續走

271
00:09:00,900 --> 00:09:03,600
所以這個就是 brand tradition 的核心精神

272
00:09:03,600 --> 00:09:04,700
我們用猜的

273
00:09:04,700 --> 00:09:05,800
猜對了很好

274
00:09:05,800 --> 00:09:09,600
猜錯了大不了跟原本一樣慢

275
00:09:09,600 --> 00:09:11,100
所以如果你今天

276
00:09:11,100 --> 00:09:12,600
你是一個超級強的

277
00:09:12,600 --> 00:09:14,200
這個超重 trunk 的選手

278
00:09:14,200 --> 00:09:16,300
你可以每一次都猜對火車要往哪邊

279
00:09:16,300 --> 00:09:17,400
你通靈大師

280
00:09:17,400 --> 00:09:19,100
你就節省了非常多的時間

281
00:09:19,100 --> 00:09:22,200
讓這個火車停下來

282
00:09:22,200 --> 00:09:23,200
那這就是

283
00:09:23,200 --> 00:09:25,600
這邊是整個 brand tradition 的概念

284
00:09:25,600 --> 00:09:26,900
那我們現在來想想

285
00:09:26,900 --> 00:09:29,300
CPU 中有一樣的概念

286
00:09:29,300 --> 00:09:30,600
那 CPU 中為什麼會用到

287
00:09:30,600 --> 00:09:32,200
brand tradition 的概念呢

288
00:09:32,200 --> 00:09:34,700
我們來看看

289
00:09:34,700 --> 00:09:36,200
真實情況是這樣的

290
00:09:36,200 --> 00:09:39,000
今天有一個橫軸是 time

291
00:09:39,000 --> 00:09:40,900
縱軸是順序

292
00:09:40,900 --> 00:09:41,800
那我們來想一下

293
00:09:41,800 --> 00:09:43,700
如果大家今天有洗衣服

294
00:09:43,700 --> 00:09:44,900
高中生都洗過衣服吧

295
00:09:44,900 --> 00:09:47,300
就是對希望大家都洗過衣服

296
00:09:47,300 --> 00:09:48,800
洗衣服的流程大概就是

297
00:09:48,800 --> 00:09:51,000
洗衣然後晾衣或烘衣

298
00:09:51,000 --> 00:09:52,500
然後可能要燙一下

299
00:09:52,500 --> 00:09:54,400
那最後就把它丟回櫃子

300
00:09:54,400 --> 00:09:55,700
這是洗衣服的基本流程

301
00:09:55,700 --> 00:09:58,000
我們假設分為四個步驟

302
00:09:58,000 --> 00:09:59,900
那你今天是一個洗衣店老闆

303
00:09:59,900 --> 00:10:02,400
你今天有很多欄的衣服要洗

304
00:10:02,400 --> 00:10:03,800
那假設你有很多台

305
00:10:03,800 --> 00:10:05,800
假設你有很多台洗衣機的情況下

306
00:10:05,800 --> 00:10:08,500
我們能怎麼樣優化這個步驟呢

307
00:10:08,500 --> 00:10:10,200
其中一個做法就是

308
00:10:10,200 --> 00:10:13,600
我們今天在第二欄衣服

309
00:10:13,600 --> 00:10:16,700
第二欄衣服拿去晾乾的時候

310
00:10:16,700 --> 00:10:20,500
就把第一欄衣服塞進洗衣機裡面

311
00:10:20,500 --> 00:10:25,100
那當第一欄衣服去燙的時候

312
00:10:25,200 --> 00:10:28,300
就再把第三欄衣服丟進洗衣機裡面

313
00:10:28,300 --> 00:10:29,600
所以這可以保證什麼

314
00:10:29,600 --> 00:10:32,300
這可以保證我洗衣店的每個工作場域

315
00:10:32,300 --> 00:10:34,400
洗衣機 晾衣服的地方

316
00:10:34,400 --> 00:10:37,300
和燙衣服的地方

317
00:10:37,300 --> 00:10:39,400
都同時有人在工作

318
00:10:39,400 --> 00:10:41,800
那這就是一個Pipeline的基本概念

319
00:10:41,800 --> 00:10:43,600
我希望我所有可用的資源

320
00:10:43,600 --> 00:10:45,400
都有被用在上面

321
00:10:45,400 --> 00:10:47,000
都有被用

322
00:10:47,000 --> 00:10:48,700
所以我們把這個動畫播完

323
00:10:48,700 --> 00:10:50,700
那今天如果你採用了下面那種方法

324
00:10:50,700 --> 00:10:51,600
我們可以看到

325
00:10:51,600 --> 00:10:53,400
它幾乎比上面那種方法

326
00:10:53,400 --> 00:10:55,400
節省了一半的時間

327
00:10:55,400 --> 00:10:56,300
你只要花一半的時間

328
00:10:56,300 --> 00:10:58,300
就可以洗好三欄衣服

329
00:10:58,300 --> 00:11:01,400
相信大家都可以聽懂這個概念

330
00:11:01,400 --> 00:11:03,800
那在CPU

331
00:11:03,800 --> 00:11:05,900
但是我們今天會遇到一個問題

332
00:11:05,900 --> 00:11:08,400
就是如果我這個洗衣店老闆很機掰

333
00:11:08,400 --> 00:11:10,800
我今天一定要在衣服洗好時

334
00:11:10,800 --> 00:11:12,800
才能決定下一欄要洗誰的

335
00:11:12,800 --> 00:11:13,600
舉例來說

336
00:11:13,600 --> 00:11:15,000
我今天一定要A客戶洗完之後

337
00:11:15,000 --> 00:11:17,700
我才知道說接下來要洗C客戶的

338
00:11:17,700 --> 00:11:19,600
那我繼續採用剛剛這個模式

339
00:11:19,600 --> 00:11:21,100
會發生什麼問題呢

340
00:11:21,100 --> 00:11:23,900
那就是今天第一欄衣服洗衣機沒問題

341
00:11:23,900 --> 00:11:26,000
第二欄衣服到晾衣的環節

342
00:11:26,000 --> 00:11:27,900
然後第二欄進洗衣機也沒問題

343
00:11:27,900 --> 00:11:30,500
那第三步也沒問題

344
00:11:30,500 --> 00:11:32,100
但是我今天當老闆說

345
00:11:32,100 --> 00:11:33,600
我一定要到最後一步

346
00:11:33,600 --> 00:11:35,400
就是把第一欄衣服洗完之後

347
00:11:35,400 --> 00:11:37,500
我才能決定下一欄要洗什麼

348
00:11:37,500 --> 00:11:38,500
這個時候會導致什麼

349
00:11:38,500 --> 00:11:41,400
會導致你剛剛偷做的都沒有用了

350
00:11:41,400 --> 00:11:43,900
你就是沒辦法去偷做後面的事情

351
00:11:43,900 --> 00:11:45,900
你就回到了剛剛的樣子

352
00:11:45,900 --> 00:11:49,200
你一定要等到最後一步完成

353
00:11:49,200 --> 00:11:51,600
你才可以洗下一欄衣服

354
00:11:51,600 --> 00:11:53,300
那這是一個很尷尬的環境

355
00:11:53,300 --> 00:11:54,500
那我們可以看到

356
00:11:54,500 --> 00:11:56,400
當你出現這種情況的時候

357
00:11:56,400 --> 00:12:00,500
會導致你的這個洗衣環節明顯下降

358
00:12:00,500 --> 00:12:02,300
所以當它每次都出現的時候

359
00:12:02,300 --> 00:12:03,800
當你每次老闆都很雞掰的時候

360
00:12:03,800 --> 00:12:06,100
你就會發現我們要花

361
00:12:06,100 --> 00:12:09,800
我們要花一樣的時間去洗整個衣服

362
00:12:09,800 --> 00:12:17,300
等一下我動畫跳太多了

363
00:12:17,400 --> 00:12:19,600
那大家再稍微看一下這個圖

364
00:12:19,600 --> 00:12:21,100
它竟然在播了一遍

365
00:12:21,100 --> 00:12:30,500
那我們來複習一下這個流程

366
00:12:30,500 --> 00:12:31,500
所以我們可以看到

367
00:12:31,500 --> 00:12:34,700
當這個branch tradition work的情況下

368
00:12:34,700 --> 00:12:36,400
我們可以讓整個洗衣的流程

369
00:12:36,400 --> 00:12:38,300
縮短到二分之一、三分之一

370
00:12:38,300 --> 00:12:39,600
或者說N分之一

371
00:12:39,600 --> 00:12:42,000
你有幾欄它可以變多快

372
00:12:42,000 --> 00:12:45,300
那今天我們來看看這個CPU中

373
00:12:45,300 --> 00:12:46,500
也有一樣的情況

374
00:12:46,500 --> 00:12:50,800
我們把剛剛的洗衣、晾衣、運動

375
00:12:50,800 --> 00:12:52,900
還有最後收起來的步驟

376
00:12:52,900 --> 00:12:54,400
全部都換成代號

377
00:12:54,400 --> 00:12:56,000
我們換成五個代號

378
00:12:56,000 --> 00:12:57,900
FDXMW

379
00:12:57,900 --> 00:13:00,300
那這五個代號它象徵的是什麼

380
00:13:00,300 --> 00:13:03,100
它象徵的是CPU在執行一個指令時

381
00:13:03,100 --> 00:13:05,000
要做的五個環節

382
00:13:05,000 --> 00:13:06,200
所以就跟剛才洗衣服一樣

383
00:13:06,200 --> 00:13:08,000
CPU是一個老闆

384
00:13:08,000 --> 00:13:09,600
那他今天要做這五個環節

385
00:13:09,600 --> 00:13:12,000
才能把一條指令做完

386
00:13:12,000 --> 00:13:15,300
那大家可能看過CPU的指令集

387
00:13:15,400 --> 00:13:17,100
那像這邊就有出現說

388
00:13:17,100 --> 00:13:19,400
有幾個指令集

389
00:13:19,400 --> 00:13:20,500
那第一個呢

390
00:13:20,500 --> 00:13:21,200
是Move

391
00:13:21,200 --> 00:13:22,800
Move大家清晰明瞭

392
00:13:22,800 --> 00:13:25,100
就是我今天把一個變數

393
00:13:25,100 --> 00:13:26,100
放進一個地方

394
00:13:26,100 --> 00:13:27,400
移到另一個地方

395
00:13:27,400 --> 00:13:28,400
那CMP呢

396
00:13:28,400 --> 00:13:30,700
則是指我今天比較這兩個數

397
00:13:30,700 --> 00:13:33,100
EAX大家把它看成變數就可以了

398
00:13:33,100 --> 00:13:35,200
我比較EAX

399
00:13:35,200 --> 00:13:37,700
是否小於等於127

400
00:13:37,700 --> 00:13:38,700
那如果是的話呢

401
00:13:38,700 --> 00:13:40,000
它就會繼續執行

402
00:13:40,000 --> 00:13:40,900
下一行是什麼呢

403
00:13:40,900 --> 00:13:45,100
就是它就跳到復活圈的開始

404
00:13:45,200 --> 00:13:46,400
所以JLE4

405
00:13:46,400 --> 00:13:48,000
就是指我跳到回天的開始

406
00:13:48,000 --> 00:13:50,200
那這跟我們剛剛的程式邏輯是一樣的

407
00:13:50,200 --> 00:13:52,100
我今天先比較它有沒有小於等於127

408
00:13:52,100 --> 00:13:54,400
然後最後再跳回去

409
00:13:54,400 --> 00:13:54,800
好

410
00:13:54,800 --> 00:13:56,800
那最後下面的指令我們就不管它了

411
00:13:56,800 --> 00:13:58,200
因為下面的指令就是在做

412
00:13:58,200 --> 00:13:59,900
其他的加法的部分

413
00:13:59,900 --> 00:14:02,900
那我們來觀察這一段Code

414
00:14:02,900 --> 00:14:03,200
好

415
00:14:03,200 --> 00:14:04,200
那我們發現什麼事情

416
00:14:04,200 --> 00:14:04,700
欸

417
00:14:04,700 --> 00:14:07,400
今天如果所有東西都順順的被執行下來

418
00:14:07,400 --> 00:14:09,000
所有東西都跟我們一開始的那個

419
00:14:09,000 --> 00:14:10,400
洗衣的Pipeline一樣

420
00:14:10,400 --> 00:14:12,600
那它可以花減少大量的時間

421
00:14:12,600 --> 00:14:13,700
原本有五個Instruction

422
00:14:13,700 --> 00:14:14,500
乘以五個步驟

423
00:14:14,500 --> 00:14:17,100
應該要花25個時間slot才能做完的事情

424
00:14:17,100 --> 00:14:17,800
今天只花了

425
00:14:17,800 --> 00:14:19,600
1 2 3 4 5 6 7 8 9

426
00:14:19,600 --> 00:14:21,200
9個slot就做完了

427
00:14:21,200 --> 00:14:21,600
好

428
00:14:21,600 --> 00:14:24,400
所以我們的時間節省到了25分之9

429
00:14:24,400 --> 00:14:24,800
好

430
00:14:24,800 --> 00:14:25,400
但是呢

431
00:14:25,400 --> 00:14:25,800
有一個

432
00:14:25,800 --> 00:14:26,900
欸

433
00:14:26,900 --> 00:14:27,300
好

434
00:14:27,300 --> 00:14:28,900
但是有一個但書

435
00:14:28,900 --> 00:14:31,700
那就是呢

436
00:14:31,700 --> 00:14:32,200
跳好

437
00:14:32,200 --> 00:14:33,200
為什麼它一直跳過去

438
00:14:33,200 --> 00:14:33,700
好

439
00:14:33,700 --> 00:14:35,100
但是有個但書就是

440
00:14:35,100 --> 00:14:39,000
如果今天在CMP那一行發生了意外

441
00:14:39,000 --> 00:14:40,200
它並沒有真的

442
00:14:40,200 --> 00:14:42,000
在JLE那一行發生了意外

443
00:14:42,000 --> 00:14:44,200
它是直接跳回4回圈一開始

444
00:14:44,200 --> 00:14:45,300
那就代表什麼

445
00:14:45,300 --> 00:14:48,400
代表後面兩個被預先被猜測被執行的指令

446
00:14:48,400 --> 00:14:50,900
就是MOP不會被順利執行

447
00:14:50,900 --> 00:14:54,700
所以就導致我們CPU浪費了五分之二的時間

448
00:14:54,700 --> 00:14:56,100
它猜的卻沒做

449
00:14:56,100 --> 00:14:57,700
所以就浪費掉了

450
00:14:57,700 --> 00:15:00,600
那這個會跟我們的程式有什麼關係呢

451
00:15:00,600 --> 00:15:03,900
那就是如果今天CPU總是能猜對

452
00:15:03,900 --> 00:15:07,800
下一個if判斷的是小於127還是大於127

453
00:15:07,800 --> 00:15:10,500
那它就可以不間斷的執行程式

454
00:15:10,500 --> 00:15:12,100
那如果CPU猜錯了

455
00:15:12,100 --> 00:15:14,200
它就要花時間重頭回來

456
00:15:14,200 --> 00:15:18,300
rollback整個這三行的程式

457
00:15:18,300 --> 00:15:20,500
那才能做完剛剛所說的事情

458
00:15:20,500 --> 00:15:23,300
所以時間差距都出現了

459
00:15:23,300 --> 00:15:24,700
有沒有猜對

460
00:15:24,700 --> 00:15:26,700
就是JLE那邊有沒有跳回去

461
00:15:26,700 --> 00:15:30,200
決定了這個CPU執行的pipeline有多快

462
00:15:30,200 --> 00:15:31,900
那這個就是pipeline的概念

463
00:15:31,900 --> 00:15:33,800
我們繼續往下

464
00:15:33,800 --> 00:15:37,100
那如何在我們的這個程式中看到這個現象呢

465
00:15:37,100 --> 00:15:38,400
這自由現象

466
00:15:38,400 --> 00:15:40,700
那我們可以用一個工具叫做perf

467
00:15:40,700 --> 00:15:44,100
perf是Linux中一個常見的性能分析工具

468
00:15:44,100 --> 00:15:46,800
那我們用perf stat這個關鍵字呢

469
00:15:46,800 --> 00:15:49,000
就可以找到這一行

470
00:15:49,000 --> 00:15:51,900
我被紅線框起來這個叫做branch miss

471
00:15:51,900 --> 00:15:54,900
那大家比較上下兩個圖的branch miss數量

472
00:15:54,900 --> 00:15:58,500
你會發現一個是0.01%

473
00:15:58,500 --> 00:16:00,500
一個是16.42%

474
00:16:00,500 --> 00:16:01,500
這代表什麼

475
00:16:01,500 --> 00:16:04,500
這代表我們有加SOLID那一行的程式

476
00:16:04,500 --> 00:16:07,300
它的branch miss數很少

477
00:16:07,300 --> 00:16:09,700
那miss很少就代表它每次都猜對了

478
00:16:09,700 --> 00:16:11,500
它每次都猜對火車要往哪裡走

479
00:16:11,500 --> 00:16:13,100
它每次CPU每次都猜對

480
00:16:13,100 --> 00:16:15,700
下一個是大於127還是小於127

481
00:16:15,700 --> 00:16:18,500
那當你今天沒有先SOLID過的程式呢

482
00:16:18,500 --> 00:16:21,300
它就會發生它的branch miss數很大

483
00:16:21,300 --> 00:16:23,000
它完全不知道它很難猜對

484
00:16:23,000 --> 00:16:25,300
下一步要往哪裡走

485
00:16:25,300 --> 00:16:28,600
那這個就會關鍵的影響到兩支程式的效能

486
00:16:28,600 --> 00:16:29,500
因為它猜錯了

487
00:16:29,500 --> 00:16:36,000
那我們剛才說猜錯猜對影響的比例很大

488
00:16:36,000 --> 00:16:38,400
那我們來回顧整個問題

489
00:16:38,400 --> 00:16:39,600
一樣我們看這個

490
00:16:39,600 --> 00:16:41,500
先加陣列然後填入亂數

491
00:16:41,500 --> 00:16:43,100
然後用SOLID把它排序

492
00:16:43,100 --> 00:16:46,000
最後用if判斷是否符合條件然後加總

493
00:16:46,000 --> 00:16:48,500
我們看到那個if內行

494
00:16:48,500 --> 00:16:50,000
什麼情況下會猜對

495
00:16:50,000 --> 00:16:51,900
什麼情況下會猜錯

496
00:16:51,900 --> 00:16:52,400
很簡單

497
00:16:52,400 --> 00:16:54,200
當我們今天全都是亂數的時候

498
00:16:54,200 --> 00:16:55,600
它這樣走過去

499
00:16:55,600 --> 00:16:58,100
大概有二分之一的機率會猜錯

500
00:16:58,100 --> 00:17:00,000
那我們今天如果是排序好的

501
00:17:00,000 --> 00:17:01,100
結果就不一樣了

502
00:17:01,100 --> 00:17:02,400
排序好的代表什麼

503
00:17:02,400 --> 00:17:03,800
代表我今天一個數

504
00:17:03,800 --> 00:17:05,200
一個array排到中間

505
00:17:05,200 --> 00:17:06,600
差不多大於127以後

506
00:17:06,700 --> 00:17:09,200
只有大於127內一個數會猜錯

507
00:17:09,200 --> 00:17:11,100
其他都會猜對

508
00:17:11,100 --> 00:17:12,700
所以這個就可以讓我們

509
00:17:12,700 --> 00:17:15,400
避免分支預測帶來的額外開銷

510
00:17:15,400 --> 00:17:17,700
在Full回圈前面加入一場排序

511
00:17:17,700 --> 00:17:19,800
可以大幅提升這整個程式的性能

512
00:17:22,700 --> 00:17:23,000
OK

513
00:17:23,000 --> 00:17:24,500
那這個Case 1

514
00:17:24,500 --> 00:17:26,300
大家到這裡希望大家有明白

515
00:17:26,300 --> 00:17:29,000
它其中的概念一來自Branch Prediction

516
00:17:29,000 --> 00:17:31,000
就是分支預測的概念

517
00:17:31,000 --> 00:17:34,100
那這個概念能夠讓我們整個程式變快

518
00:17:34,100 --> 00:17:36,200
而不用去改變到這個程式的演算法

519
00:17:36,200 --> 00:17:38,800
僅僅是加一行排序

520
00:17:38,800 --> 00:17:41,000
那我們來看第二個Case

521
00:17:41,000 --> 00:17:42,500
Catch Locality

522
00:17:42,500 --> 00:17:45,400
那這個Case講的是回圈展開

523
00:17:45,400 --> 00:17:47,100
回圈展開指的是什麼意思呢

524
00:17:47,100 --> 00:17:48,600
我們今天我們寫回圈的時候

525
00:17:48,600 --> 00:17:50,600
常常會寫出雙重回圈

526
00:17:50,600 --> 00:17:52,700
那外面通常都是For i in range

527
00:17:52,700 --> 00:17:54,900
然後裡面通常是For j in range

528
00:17:54,900 --> 00:17:56,400
大家應該不陌生

529
00:17:56,400 --> 00:17:58,400
但是如果我今天把它反過來

530
00:17:58,400 --> 00:17:59,400
會發生什麼事

531
00:17:59,400 --> 00:18:01,900
就是這個Case想要講的事情

532
00:18:01,900 --> 00:18:02,900
那在開始講之前

533
00:18:02,900 --> 00:18:05,200
我們要先補充一點先備知識

534
00:18:05,200 --> 00:18:07,200
那根據Data Community的說法

535
00:18:07,200 --> 00:18:09,500
我們現在的處理器也就是CPU

536
00:18:09,500 --> 00:18:12,700
比我們的記憶體之間的性能差距非常的大

537
00:18:12,700 --> 00:18:14,900
那這對今天的計算機來說

538
00:18:14,900 --> 00:18:16,200
是一個很大的問題

539
00:18:16,200 --> 00:18:17,000
為什麼呢

540
00:18:17,000 --> 00:18:18,400
因為我們的CPU很快

541
00:18:18,400 --> 00:18:20,900
但是我們的記憶體卻沒有相對應的變快

542
00:18:20,900 --> 00:18:23,400
這導致我們如果繼續用傳統的方式

543
00:18:23,400 --> 00:18:24,900
去寫程式

544
00:18:24,900 --> 00:18:26,300
那會導致我們的記憶體

545
00:18:26,300 --> 00:18:28,000
永遠會成為我們的Bottleneck

546
00:18:28,000 --> 00:18:30,200
成為我們這次程式的性能瓶頸

547
00:18:30,200 --> 00:18:32,600
所以大家可以看它這邊右邊做出來的圖

548
00:18:32,600 --> 00:18:34,500
我們的CPU成長非常快

549
00:18:34,600 --> 00:18:37,100
在這幾十年間已經達到一千倍的成長

550
00:18:37,100 --> 00:18:38,800
但是我們的記憶體也就是低端成長

551
00:18:38,800 --> 00:18:40,000
甚至不到十倍

552
00:18:40,000 --> 00:18:41,400
就是速度上的成長

553
00:18:42,600 --> 00:18:44,200
那為了解決這個問題

554
00:18:44,200 --> 00:18:47,300
人們就發明出一個想法叫做Locality

555
00:18:47,300 --> 00:18:49,900
那Locality這個想法

556
00:18:49,900 --> 00:18:53,000
主要實踐在我們的記憶體的這個階層上

557
00:18:53,000 --> 00:18:54,400
大家可能都有組過電腦

558
00:18:54,400 --> 00:18:55,700
是在我們的電腦裡面

559
00:18:55,700 --> 00:18:57,200
從最慢的硬碟

560
00:18:57,200 --> 00:18:58,500
到蠻快的記憶體

561
00:18:58,500 --> 00:19:00,800
到更快的可能是CPU裡面的Cache

562
00:19:00,800 --> 00:19:02,400
到CPU裡面的Register

563
00:19:02,500 --> 00:19:07,100
這些東西是逐步的去建置整個我們的儲存體系

564
00:19:07,100 --> 00:19:10,300
那當我們今天把又快又貴的儲存方式

565
00:19:10,300 --> 00:19:11,900
放在最上面

566
00:19:11,900 --> 00:19:14,100
那把今天又慢又便宜的東西

567
00:19:14,100 --> 00:19:15,100
放在最下面

568
00:19:15,100 --> 00:19:17,900
就可以讓我們今天在大量使用資料的時候

569
00:19:17,900 --> 00:19:19,800
盡量使用上半部的資料

570
00:19:19,800 --> 00:19:21,800
那當我們今天這個資料不常被使用的時候

571
00:19:21,800 --> 00:19:24,300
我們就把它放到硬碟中

572
00:19:24,300 --> 00:19:26,300
那等到之後再去使用

573
00:19:26,300 --> 00:19:29,000
那這樣就可以在不太花錢的情況下

574
00:19:29,000 --> 00:19:31,100
大幅增加我們的程式性能

575
00:19:31,100 --> 00:19:33,100
那這其中包含兩個概念

576
00:19:33,100 --> 00:19:35,200
第一個叫做 temporal locality

577
00:19:35,200 --> 00:19:37,700
它指的是時間的局部性

578
00:19:37,700 --> 00:19:38,700
這指的是什麼呢

579
00:19:38,700 --> 00:19:41,300
指的是我們今天一個復活圈

580
00:19:41,300 --> 00:19:44,900
它常常會用到

581
00:19:44,900 --> 00:19:47,200
這指的是我們今天這個變數

582
00:19:47,200 --> 00:19:49,800
常常在CPU期間被多次的引用

583
00:19:49,800 --> 00:19:50,500
什麼意思呢

584
00:19:50,500 --> 00:19:52,300
就假設你今天有一個復活圈上面有個I

585
00:19:52,300 --> 00:19:54,000
那我們發現這復活圈每執行一次

586
00:19:54,000 --> 00:19:55,100
這個I都會被用到

587
00:19:55,100 --> 00:19:57,300
那就是很常一個變數剛被用完

588
00:19:57,300 --> 00:19:59,200
又立刻被用

589
00:19:59,600 --> 00:20:01,500
那第二個就是 special locality

590
00:20:01,500 --> 00:20:02,700
那它指的是什麼呢

591
00:20:02,700 --> 00:20:05,900
指的是我們今天臨近這個變數的東西

592
00:20:05,900 --> 00:20:09,000
臨近這個變數的數字也很常被使用

593
00:20:09,000 --> 00:20:09,700
什麼意思

594
00:20:09,700 --> 00:20:11,500
假設我們像剛才一樣寫了一個array

595
00:20:11,500 --> 00:20:13,500
這個array的0用完之後

596
00:20:13,500 --> 00:20:14,600
下一個通常會用1

597
00:20:14,600 --> 00:20:16,300
1用完之後通常會用2

598
00:20:16,300 --> 00:20:18,900
所以這兩個locality的概念

599
00:20:18,900 --> 00:20:21,500
出自於程式設計師的程式碼

600
00:20:21,500 --> 00:20:22,300
因為我們程式碼

601
00:20:22,300 --> 00:20:24,200
或者說我們現實生活中的問題

602
00:20:24,200 --> 00:20:25,600
總是有這樣的特性

603
00:20:25,600 --> 00:20:29,900
所以才能夠支撐我們去建立這個

604
00:20:29,900 --> 00:20:32,300
這個儲存的階層

605
00:20:32,300 --> 00:20:34,800
讓它可以加速我們整個計算機的

606
00:20:34,800 --> 00:20:36,700
記憶體體系

607
00:20:36,700 --> 00:20:38,800
那幫大家回憶過

608
00:20:38,800 --> 00:20:40,400
如果你學過計算機結構

609
00:20:40,400 --> 00:20:41,500
你就看過這張圖

610
00:20:41,500 --> 00:20:43,600
它指的是我們在CPU中的cache

611
00:20:43,600 --> 00:20:45,400
是怎麼被使用的

612
00:20:45,400 --> 00:20:47,000
那其中這個概念來說

613
00:20:47,000 --> 00:20:50,300
就是我們今天有n個set

614
00:20:50,300 --> 00:20:52,200
就是一行一行是一個set

615
00:20:52,200 --> 00:20:54,900
那每個set裡面有一個紫色的block

616
00:20:54,900 --> 00:20:56,200
深紫色的block

617
00:20:56,200 --> 00:20:57,500
那這個block裡面呢

618
00:20:57,500 --> 00:21:00,100
儲存了資料還有tag

619
00:21:00,100 --> 00:21:01,600
那這tag就像index一樣

620
00:21:01,600 --> 00:21:03,100
它會對應到一組value

621
00:21:03,100 --> 00:21:06,000
那我們的cache體系就是這樣被實現的

622
00:21:06,000 --> 00:21:08,200
透過指定set 指定tag

623
00:21:08,200 --> 00:21:09,600
和指定offset

624
00:21:09,600 --> 00:21:11,300
就是我們今天要找到第幾個資料

625
00:21:11,300 --> 00:21:15,900
然後來快速的找到資料

626
00:21:15,900 --> 00:21:17,200
那這個東西呢

627
00:21:17,200 --> 00:21:18,900
能夠讓我們做到什麼事情呢

628
00:21:18,900 --> 00:21:20,400
當我們今天有這個cache之後呢

629
00:21:20,400 --> 00:21:22,000
可以大幅降低我們在

630
00:21:22,000 --> 00:21:23,600
儲存情況下的latency

631
00:21:23,600 --> 00:21:24,800
就是延遲性

632
00:21:24,800 --> 00:21:26,600
舉例來說 當你加入這個

633
00:21:26,600 --> 00:21:28,000
在L1的cache的時候

634
00:21:28,000 --> 00:21:29,000
你就可以讓你的latency

635
00:21:29,000 --> 00:21:30,300
來到4個cycle

636
00:21:30,300 --> 00:21:31,400
4個cycle是什麼意思

637
00:21:31,400 --> 00:21:33,300
就是我們CPU執行4次

638
00:21:33,300 --> 00:21:35,200
CPU執行4次當然是非常非常快的

639
00:21:35,200 --> 00:21:37,600
那L2 cache會來到12個cycle

640
00:21:37,600 --> 00:21:39,900
那最慢的就是我們的rank latency

641
00:21:39,900 --> 00:21:41,000
就是記憶體的latency

642
00:21:41,000 --> 00:21:44,000
會來到38個cycle加上66奈秒

643
00:21:44,000 --> 00:21:45,200
不過總而言之就是

644
00:21:45,200 --> 00:21:47,800
透過這些由快到慢的cycle數

645
00:21:47,800 --> 00:21:50,900
那搭配我們剛剛提到的這個

646
00:21:50,900 --> 00:21:51,800
儲存架構

647
00:21:51,800 --> 00:21:54,500
那來加速我們的電腦

648
00:21:54,500 --> 00:21:56,600
然後來彌補我剛剛說的這個

649
00:21:56,600 --> 00:22:00,500
記憶體發展比CPU慢的問題

650
00:22:00,500 --> 00:22:02,000
那根據剛才的概念

651
00:22:02,000 --> 00:22:05,000
越近的還有越常用的記憶體必須快

652
00:22:05,000 --> 00:22:06,400
越近的和越常用的資料

653
00:22:06,400 --> 00:22:07,100
一定要很快

654
00:22:07,100 --> 00:22:08,600
這樣才可以加速

655
00:22:08,600 --> 00:22:11,500
所以我們來看一下

656
00:22:11,500 --> 00:22:13,500
這支程式非常簡單

657
00:22:13,500 --> 00:22:14,500
大家應該都看得懂

658
00:22:14,500 --> 00:22:16,300
int64 i j sum等於0

659
00:22:16,300 --> 00:22:17,500
那我們今天兩個雙重迴圈

660
00:22:17,500 --> 00:22:19,700
外面是for i 0到4 i++

661
00:22:19,700 --> 00:22:21,700
裡面是for j 0到4 j++

662
00:22:21,700 --> 00:22:22,500
那最後呢

663
00:22:22,500 --> 00:22:25,400
我用sum加等於這個陣列中的

664
00:22:25,400 --> 00:22:27,200
所有數字就是a i j

665
00:22:27,200 --> 00:22:28,400
所以我今天可以加總

666
00:22:28,400 --> 00:22:29,800
右上角那個4乘4的

667
00:22:29,800 --> 00:22:33,300
所有array裡面的資料

668
00:22:33,300 --> 00:22:34,200
那這個東西呢

669
00:22:34,200 --> 00:22:36,000
搭配我們剛剛的這個知識

670
00:22:36,000 --> 00:22:37,200
它告訴我們什麼

671
00:22:37,200 --> 00:22:38,300
它告訴我們說

672
00:22:38,300 --> 00:22:39,700
我們的資料呢

673
00:22:39,700 --> 00:22:41,700
都會被存在cache裡面

674
00:22:41,700 --> 00:22:44,600
讓它在之後可以被快速的使用

675
00:22:44,600 --> 00:22:46,600
這個就符合我們剛剛說的這個

676
00:22:46,600 --> 00:22:48,200
空間的locality

677
00:22:48,200 --> 00:22:49,400
那當今天呢

678
00:22:49,400 --> 00:22:50,600
第一個就是那個

679
00:22:50,600 --> 00:22:52,700
W0的資料被使用的時候呢

680
00:22:52,700 --> 00:22:54,800
我們的電腦就會自動的

681
00:22:54,800 --> 00:22:57,600
把後面到W3的這些資料

682
00:22:57,600 --> 00:22:59,100
都放進cache裡面

683
00:22:59,100 --> 00:23:01,500
所以當我們今天程式執行到

684
00:23:01,500 --> 00:23:03,100
裡面的那個氛圍圈的第二次

685
00:23:03,100 --> 00:23:05,000
也就是a01的時候呢

686
00:23:05,000 --> 00:23:06,100
它會發生什麼事

687
00:23:06,100 --> 00:23:08,000
它會發現它要的資料

688
00:23:08,000 --> 00:23:09,400
已經在cache裡面了

689
00:23:09,400 --> 00:23:10,500
所以它變快了

690
00:23:10,500 --> 00:23:11,600
它不用再去讀memory了

691
00:23:11,600 --> 00:23:13,100
它也不用再去讀硬碟了

692
00:23:13,100 --> 00:23:14,200
所以它變快了

693
00:23:14,200 --> 00:23:16,000
那就會大幅的降低

694
00:23:16,000 --> 00:23:17,900
我們今天這次程式的執行時間

695
00:23:17,900 --> 00:23:19,000
因為它要的早的資料

696
00:23:19,000 --> 00:23:20,800
已經被cache住了

697
00:23:20,800 --> 00:23:22,200
那我們看這次程式

698
00:23:22,200 --> 00:23:24,800
它在什麼情況下會miss

699
00:23:24,800 --> 00:23:25,800
那大家看喔

700
00:23:25,800 --> 00:23:27,000
通常都是在我們這個

701
00:23:27,000 --> 00:23:29,400
j等於0的情況下會miss

702
00:23:29,400 --> 00:23:30,900
j等於0的情況下都會miss

703
00:23:30,900 --> 00:23:32,400
那我們換一次程式看

704
00:23:32,400 --> 00:23:34,800
如果今天j在外面會發生什麼事

705
00:23:34,800 --> 00:23:37,200
j在外面就是我們先輪i再輪j

706
00:23:37,200 --> 00:23:39,400
所以剛剛是橫的一橫一橫一橫

707
00:23:39,400 --> 00:23:41,400
現在變成一直一直一直一直

708
00:23:41,400 --> 00:23:43,400
那我們來看一下這個狀況

709
00:23:43,400 --> 00:23:45,800
當今天我們今天把i0 j0

710
00:23:45,800 --> 00:23:47,800
放讀取進來的時候

711
00:23:47,800 --> 00:23:48,700
這時候cachemiss了

712
00:23:48,700 --> 00:23:49,900
因為它沒有放在cache裡面

713
00:23:49,900 --> 00:23:51,300
那後面呢

714
00:23:51,300 --> 00:23:52,300
後面發生什麼事

715
00:23:52,300 --> 00:23:53,100
電腦會覺得

716
00:23:53,100 --> 00:23:54,900
欸 鄰近的資料應該會先用

717
00:23:54,900 --> 00:23:57,700
所以它就把i0 j123的資料

718
00:23:57,700 --> 00:23:58,900
也放進cache裡面

719
00:23:58,900 --> 00:24:00,100
但這個時候呢

720
00:24:00,100 --> 00:24:01,500
你卻很違背電腦的意思

721
00:24:01,500 --> 00:24:02,100
你卻來說

722
00:24:02,100 --> 00:24:04,700
喔 我要先讀i1 j0

723
00:24:04,700 --> 00:24:05,500
電腦就說

724
00:24:05,500 --> 00:24:06,500
喔 我沒有cache到啊

725
00:24:06,500 --> 00:24:07,500
所以就miss了

726
00:24:07,500 --> 00:24:08,700
那往後的每一個

727
00:24:08,700 --> 00:24:10,100
都會發生一樣的問題

728
00:24:10,100 --> 00:24:11,100
全部都miss了

729
00:24:11,100 --> 00:24:12,900
所以你今天這一個程式

730
00:24:12,900 --> 00:24:14,700
你僅僅是把ij

731
00:24:14,700 --> 00:24:16,900
在迴圈上的位置替換

732
00:24:16,900 --> 00:24:18,500
卻導致它的miss rate

733
00:24:18,500 --> 00:24:19,900
從剛剛的四十六分之四

734
00:24:19,900 --> 00:24:22,300
新增到了十六分之十六

735
00:24:22,300 --> 00:24:23,100
十六分之六代表什麼

736
00:24:23,100 --> 00:24:24,300
剛才說l1比l2

737
00:24:24,300 --> 00:24:25,500
可能快個兩三倍

738
00:24:25,500 --> 00:24:27,700
然後l2又比rememory

739
00:24:27,700 --> 00:24:30,100
大概快了什麼兩三倍

740
00:24:30,100 --> 00:24:31,500
所以你只要這樣一miss rate

741
00:24:31,500 --> 00:24:32,900
整層都miss rate下去

742
00:24:32,900 --> 00:24:35,900
你的程式就差很多

743
00:24:35,900 --> 00:24:39,900
那 仔細的同學剛才可能有看到

744
00:24:39,900 --> 00:24:41,100
我們老師都說過啊

745
00:24:41,100 --> 00:24:42,700
陣列 雖然是二維陣列

746
00:24:42,700 --> 00:24:44,300
但它在記憶體中是一維的嘛

747
00:24:44,300 --> 00:24:46,100
有人注意到這個問題嗎

748
00:24:46,100 --> 00:24:47,700
如果我們今天在記憶體中的陣列

749
00:24:47,700 --> 00:24:48,500
是一維的

750
00:24:48,500 --> 00:24:50,100
那為什麼會出現今天換行的時候

751
00:24:50,100 --> 00:24:50,900
它卻沒有辦法

752
00:24:50,900 --> 00:24:52,500
漏進cache裡面的問題呢

753
00:24:52,500 --> 00:24:53,300
假設它是一維的

754
00:24:53,300 --> 00:24:55,100
那不是應該全部都被丟進去嗎

755
00:24:55,100 --> 00:24:55,700
對不對

756
00:24:55,700 --> 00:24:56,900
那我們來看看

757
00:24:56,900 --> 00:24:58,500
究竟發生了什麼事情

758
00:24:58,500 --> 00:25:00,300
其實這是我留下的一個小陷阱

759
00:25:00,300 --> 00:25:01,500
希望大家有注意到

760
00:25:01,500 --> 00:25:02,700
那問題就在於

761
00:25:02,700 --> 00:25:05,900
我剛剛的程式中

762
00:25:05,900 --> 00:25:08,300
我int64t

763
00:25:08,300 --> 00:25:09,500
代表的是今天

764
00:25:09,500 --> 00:25:10,700
每一個格子裡面

765
00:25:10,700 --> 00:25:11,700
它是一個int

766
00:25:11,700 --> 00:25:14,700
那這個int有64bit去儲存

767
00:25:14,700 --> 00:25:15,900
所以當我們今天

768
00:25:15,900 --> 00:25:17,500
要去漏cache的時候

769
00:25:17,500 --> 00:25:18,700
會漏多少cache

770
00:25:18,700 --> 00:25:21,700
會漏64乘上4格

771
00:25:21,700 --> 00:25:23,700
那為什麼是漏64乘上4格

772
00:25:23,700 --> 00:25:24,900
當作一次的cache呢

773
00:25:24,900 --> 00:25:25,700
原因是因為

774
00:25:25,700 --> 00:25:27,300
跟我最開始講到的

775
00:25:27,300 --> 00:25:28,700
我們今天的實驗架構有關

776
00:25:28,700 --> 00:25:30,700
因為我這一顆CPU

777
00:25:30,700 --> 00:25:35,300
它的LE的data cache size是2MB

778
00:25:35,300 --> 00:25:35,900
換句話說

779
00:25:35,900 --> 00:25:36,900
我今天有64核

780
00:25:36,900 --> 00:25:39,100
除外以後就是每個核心有32kb

781
00:25:39,100 --> 00:25:41,100
32kb就

782
00:25:41,100 --> 00:25:43,500
30kb就會等

783
00:25:43,500 --> 00:25:44,700
然後先用下面的換算

784
00:25:44,700 --> 00:25:45,500
大家可以看到

785
00:25:45,500 --> 00:25:46,500
就會變成說

786
00:25:46,500 --> 00:25:49,300
32kb剛好只能放4個數字

787
00:25:49,300 --> 00:25:50,500
所以會導致

788
00:25:50,500 --> 00:25:51,300
下一行的數字

789
00:25:51,300 --> 00:25:53,100
沒有辦法漏進cache裡面

790
00:25:53,100 --> 00:25:54,300
當然隨著你cache的增長

791
00:25:54,300 --> 00:25:55,700
這只是一個小例子

792
00:25:55,700 --> 00:25:56,500
隨著你的cache增長

793
00:25:56,500 --> 00:25:57,700
都會發生類似的事情

794
00:25:57,700 --> 00:25:59,300
因為沒辦法被漏進cache裡面

795
00:25:59,300 --> 00:26:02,100
導致你的程式變慢了

796
00:26:02,100 --> 00:26:03,300
那你說我沒那麼蠢啊

797
00:26:03,300 --> 00:26:04,500
我寫程式誰不會

798
00:26:04,500 --> 00:26:06,100
才不會直接放外面i放裡面

799
00:26:06,100 --> 00:26:07,100
沒有人會這麼蠢

800
00:26:07,100 --> 00:26:08,900
那你不會互換ij

801
00:26:08,900 --> 00:26:10,500
你會不會寫出這樣的程式

802
00:26:10,500 --> 00:26:13,700
你會不會寫出i加等於2

803
00:26:13,700 --> 00:26:14,500
當你今天寫出

804
00:26:14,500 --> 00:26:16,300
i加等於2的復活圈的時候

805
00:26:16,300 --> 00:26:17,700
你的讀取的資料

806
00:26:17,700 --> 00:26:19,100
是跳著跳著跳著的

807
00:26:19,100 --> 00:26:19,900
但是我們的cache

808
00:26:19,900 --> 00:26:21,100
每次都是漏4個啊

809
00:26:21,100 --> 00:26:22,500
每次都是漏4個啊

810
00:26:22,500 --> 00:26:23,700
那這樣會導致什麼

811
00:26:23,700 --> 00:26:25,300
導致你並沒有用好

812
00:26:25,300 --> 00:26:27,100
用滿cpu漏進來的cache

813
00:26:27,100 --> 00:26:28,100
好 那就會導致

814
00:26:28,100 --> 00:26:29,700
你的程式性能降低

815
00:26:29,700 --> 00:26:30,900
好 那更誇張的

816
00:26:30,900 --> 00:26:33,900
假設你寫了什麼ai等於bci

817
00:26:33,900 --> 00:26:35,100
那會發生什麼事

818
00:26:35,100 --> 00:26:36,500
發生你漏的cache

819
00:26:36,500 --> 00:26:37,500
完全用不到啊

820
00:26:37,500 --> 00:26:39,300
因為你今天讀的這個array

821
00:26:39,300 --> 00:26:40,900
都散落在不同地方

822
00:26:40,900 --> 00:26:42,500
好 所以這告訴我們什麼

823
00:26:42,500 --> 00:26:44,700
今天因為cache locality的問題

824
00:26:44,700 --> 00:26:46,100
我們今天在寫程式的時候

825
00:26:46,100 --> 00:26:48,300
盡量把cpu會認為

826
00:26:48,300 --> 00:26:50,500
先漏進來的資料

827
00:26:50,500 --> 00:26:52,300
先用好再去算其他的

828
00:26:52,300 --> 00:26:55,100
這樣可以加速我們的程式性能

829
00:26:55,100 --> 00:26:58,300
好 那這東西我們比較熟寫

830
00:26:58,300 --> 00:26:59,700
那我們接下來看第三個

831
00:26:59,700 --> 00:27:01,700
SIMD

832
00:27:01,700 --> 00:27:03,300
我們都知道我們演算法

833
00:27:03,300 --> 00:27:05,300
大家不斷地加強自己的演算法能力

834
00:27:05,300 --> 00:27:07,300
去打進程打APCS

835
00:27:07,300 --> 00:27:10,300
但是我們的計算機科學家

836
00:27:10,300 --> 00:27:12,100
也不斷地在加強我們電腦

837
00:27:12,100 --> 00:27:14,700
執行programmer寫程式的能力

838
00:27:14,700 --> 00:27:15,700
這是雙向的

839
00:27:15,700 --> 00:27:17,900
就是programmer都在加強自己的演算法

840
00:27:17,900 --> 00:27:21,100
但是科學家也在加強這個計算機

841
00:27:21,100 --> 00:27:23,700
處理這個programmer的程式能力

842
00:27:23,700 --> 00:27:25,900
其中一個好例子就是SIMD

843
00:27:25,900 --> 00:27:27,100
那SIMD是什麼

844
00:27:27,100 --> 00:27:28,900
它是factor processing

845
00:27:28,900 --> 00:27:30,700
那factor processing指的是什麼呢

846
00:27:30,700 --> 00:27:33,100
就是我們今天如果讓我們電腦

847
00:27:33,100 --> 00:27:35,500
能夠一次運算更多的數字

848
00:27:35,500 --> 00:27:37,100
例如我原本加數字

849
00:27:37,100 --> 00:27:38,700
要加四個到一個一個加

850
00:27:38,700 --> 00:27:40,300
那如果把四個數字併在一起

851
00:27:40,300 --> 00:27:41,100
一起加

852
00:27:41,100 --> 00:27:43,500
是不是就可以讓我的程式快四倍

853
00:27:43,500 --> 00:27:46,700
那這就是factor processing的其中一個意涵

854
00:27:46,700 --> 00:27:48,100
那我們來看一下這個程式

855
00:27:48,100 --> 00:27:50,500
這個程式裡面用到一些大家不常見的function

856
00:27:50,500 --> 00:27:52,500
所以我們看看概念就好

857
00:27:52,500 --> 00:27:55,500
一樣一開始我們在這個main function裡面

858
00:27:55,500 --> 00:27:57,700
新增一個array

859
00:27:57,700 --> 00:27:59,100
然後填入數字

860
00:27:59,100 --> 00:28:00,900
那接下來我們去call兩個function

861
00:28:00,900 --> 00:28:02,100
一個是normal function

862
00:28:02,100 --> 00:28:03,900
一個是SSE function

863
00:28:03,900 --> 00:28:06,100
normal function就是一般人會寫的方法

864
00:28:06,100 --> 00:28:07,700
如果我們今天想要把這個array中的

865
00:28:07,700 --> 00:28:09,500
所有數字都做SQRT

866
00:28:09,500 --> 00:28:11,500
那我們通常會像上面的寫法一樣

867
00:28:11,500 --> 00:28:13,900
for i等於0,i小於1,i加加i

868
00:28:13,900 --> 00:28:16,700
然後把全部東西都做SQRT存回去

869
00:28:16,700 --> 00:28:18,300
那這是一般人寫法

870
00:28:18,300 --> 00:28:20,700
那如果你因為學計算結構

871
00:28:20,700 --> 00:28:22,100
你因為知道這樣的知識

872
00:28:22,100 --> 00:28:23,700
你去用好它可以變成什麼呢

873
00:28:23,700 --> 00:28:25,900
你可以call SSE那個function

874
00:28:25,900 --> 00:28:27,500
那個function做到什麼事情

875
00:28:27,500 --> 00:28:29,300
它今天我們看它把

876
00:28:29,300 --> 00:28:33,500
mbitrs等於n除以4

877
00:28:33,500 --> 00:28:35,700
然後我們跳過指標那行不看

878
00:28:35,700 --> 00:28:37,700
我們直接看復活圈裡面那一行

879
00:28:37,700 --> 00:28:38,700
它做了什麼

880
00:28:39,300 --> 00:28:41,900
我們先看mnsqrtps

881
00:28:41,900 --> 00:28:44,500
這一個function它就是一次對

882
00:28:44,500 --> 00:28:47,100
tr這個point裡面的

883
00:28:47,100 --> 00:28:49,700
4個float做平方

884
00:28:49,700 --> 00:28:52,700
那再用mnsqrtps一次存進

885
00:28:52,700 --> 00:28:55,900
一次把4個float存回記憶體裡面

886
00:28:55,900 --> 00:28:58,300
那因為你call了這兩個簡單的function

887
00:28:58,300 --> 00:29:01,100
4個一起SQRT

888
00:29:01,100 --> 00:29:02,500
和4個一起存回去

889
00:29:02,500 --> 00:29:04,100
這可以直接導致你的程式

890
00:29:04,100 --> 00:29:06,900
的instruction數少了四分之一

891
00:29:07,100 --> 00:29:08,700
它用四分之一的數量

892
00:29:08,700 --> 00:29:12,100
就做完你原本要做的事情

893
00:29:12,100 --> 00:29:13,100
所以我們來看看

894
00:29:13,100 --> 00:29:14,300
這可以快多少倍

895
00:29:14,300 --> 00:29:16,100
這東西可以快四倍

896
00:29:16,100 --> 00:29:17,900
大家只是把上面那個normal

897
00:29:17,900 --> 00:29:19,300
改成下面的sse

898
00:29:19,300 --> 00:29:20,700
你call的function就是從sqrt

899
00:29:20,700 --> 00:29:22,500
改成mnsqrt

900
00:29:22,500 --> 00:29:23,900
小小的改一下你的電腦

901
00:29:23,900 --> 00:29:25,300
你的程式快了四倍

902
00:29:25,300 --> 00:29:26,700
是非常顯而易見的

903
00:29:26,700 --> 00:29:28,500
那這就是你理解計算機結構後

904
00:29:28,500 --> 00:29:30,300
可以做到一些優化

905
00:29:30,300 --> 00:29:34,500
那就是能夠符合計算機的設計方式

906
00:29:34,500 --> 00:29:35,500
那我們來看一下

907
00:29:35,500 --> 00:29:37,100
剛剛快四倍

908
00:29:37,100 --> 00:29:38,500
那有沒有更快的

909
00:29:38,500 --> 00:29:39,500
有

910
00:29:39,500 --> 00:29:40,700
就是我們在電腦裡面

911
00:29:40,700 --> 00:29:42,900
雖然我們說64位的CPU

912
00:29:42,900 --> 00:29:44,900
的register有64bit

913
00:29:44,900 --> 00:29:46,700
但其實在現代電腦中

914
00:29:46,700 --> 00:29:48,500
都有更長的register

915
00:29:48,500 --> 00:29:49,900
更長的儲存空間

916
00:29:49,900 --> 00:29:51,300
可以儲存更多的資料

917
00:29:51,300 --> 00:29:53,100
然後一次做更多的運算

918
00:29:53,100 --> 00:29:54,700
所以看左邊這張圖

919
00:29:54,700 --> 00:29:56,500
我們如果今天有一個register

920
00:29:56,500 --> 00:29:58,900
存0到127就是128bit

921
00:29:58,900 --> 00:30:01,300
我們會把它叫做一個XMM register

922
00:30:01,300 --> 00:30:02,500
那更新了電腦後

923
00:30:02,500 --> 00:30:05,100
還有YMM和ZMM兩種register

924
00:30:05,100 --> 00:30:06,500
所以最大的register

925
00:30:06,500 --> 00:30:08,900
一次可以儲存512bit的資料

926
00:30:08,900 --> 00:30:11,900
那如果你今天要算4bit

927
00:30:11,900 --> 00:30:13,500
就是4bit的int

928
00:30:13,500 --> 00:30:14,700
也就是32bit

929
00:30:14,700 --> 00:30:17,900
你就可以一次做512除以32的倍數

930
00:30:17,900 --> 00:30:19,900
的這個加速

931
00:30:19,900 --> 00:30:22,100
那如何查看你的電腦有哪些register呢

932
00:30:22,100 --> 00:30:23,500
如果你今天電腦剛好是Linux

933
00:30:23,500 --> 00:30:25,100
或你有著光GDB的話

934
00:30:25,100 --> 00:30:26,700
你就可以直接在GDB裡面

935
00:30:26,700 --> 00:30:28,700
下info or register

936
00:30:28,700 --> 00:30:31,700
你就可以去grip你的XMM YMM或ZMM

937
00:30:31,700 --> 00:30:34,300
看看你電腦支援到多大的register

938
00:30:34,300 --> 00:30:37,100
可以加速你的程式

939
00:30:37,100 --> 00:30:38,100
那我們來看一下剛剛

940
00:30:38,100 --> 00:30:40,500
一樣是破了不同一條指令

941
00:30:40,500 --> 00:30:41,500
它做了什麼

942
00:30:41,500 --> 00:30:43,500
我們看紅線框起來的地方

943
00:30:43,500 --> 00:30:45,900
這裡這個instruction數呢

944
00:30:45,900 --> 00:30:47,300
這邊instruction數

945
00:30:47,300 --> 00:30:49,500
我們看到上面那個instruction數

946
00:30:49,500 --> 00:30:51,500
是1.93instruction per cycle

947
00:30:51,500 --> 00:30:54,300
下面是1.79instruction per cycle

948
00:30:54,300 --> 00:30:55,100
它代表的是

949
00:30:55,100 --> 00:30:57,700
我今天一個CPU的cycle中

950
00:30:57,700 --> 00:30:59,500
執行的instruction數差不多

951
00:30:59,500 --> 00:31:00,900
但是因為這個instruction

952
00:31:00,900 --> 00:31:02,700
一次能處理4bit的資料

953
00:31:02,700 --> 00:31:04,700
所以導致我整個程式

954
00:31:04,700 --> 00:31:06,500
縮減了四分之一的時間

955
00:31:06,500 --> 00:31:07,900
應該蠻容易理解

956
00:31:07,900 --> 00:31:08,700
instruction數

957
00:31:08,700 --> 00:31:09,900
每秒能處理的instruction數

958
00:31:09,900 --> 00:31:10,900
並沒有變多

959
00:31:10,900 --> 00:31:11,900
但是因為每個instruction

960
00:31:11,900 --> 00:31:13,300
可以處理的資料變多

961
00:31:13,300 --> 00:31:16,900
所以導致我們的程式快了四倍

962
00:31:16,900 --> 00:31:19,700
那你說這個function其實有點難記

963
00:31:19,700 --> 00:31:21,700
我可以使用編譯器加速嗎

964
00:31:21,700 --> 00:31:22,500
這就問得好

965
00:31:22,500 --> 00:31:24,500
現在這個季節這些東西呢

966
00:31:24,500 --> 00:31:26,100
其實很多你都可以使用編譯器

967
00:31:26,100 --> 00:31:27,500
來幫助你加速

968
00:31:27,500 --> 00:31:28,900
舉例來說剛剛這個例子

969
00:31:28,900 --> 00:31:32,500
你就可以用G++-O3-NSE2

970
00:31:32,500 --> 00:31:35,500
然後去把你的這個SSE2-num.cpp

971
00:31:35,500 --> 00:31:37,700
就是沒有手動寫SSE2的那個

972
00:31:37,700 --> 00:31:39,300
程式碼版本去編譯

973
00:31:39,300 --> 00:31:40,700
那編譯完以後呢

974
00:31:40,700 --> 00:31:43,500
它就可以使用到一部分的XML register

975
00:31:43,500 --> 00:31:44,300
所以我們看

976
00:31:44,300 --> 00:31:46,500
今天你使用了這個

977
00:31:46,500 --> 00:31:47,900
編譯器參數去編譯完

978
00:31:47,900 --> 00:31:48,700
結果就是

979
00:31:48,700 --> 00:31:51,300
你的速度達到了0.1041秒

980
00:31:51,300 --> 00:31:54,500
那它比沒有使用SSE的0.193秒

981
00:31:54,500 --> 00:31:55,700
快了大概兩倍

982
00:31:55,700 --> 00:31:59,500
但是還是不如你自己手寫SSE來得快

983
00:31:59,500 --> 00:32:01,500
那如何讓編譯器更快

984
00:32:01,500 --> 00:32:02,500
如何讓編譯器更快

985
00:32:02,500 --> 00:32:05,500
就是去當一個對SYND友善的工程師

986
00:32:05,500 --> 00:32:07,500
我們又回到剛剛的catch locality

987
00:32:07,500 --> 00:32:08,500
剛才提過

988
00:32:08,500 --> 00:32:10,500
catch locality就是讓你常用的資料

989
00:32:10,500 --> 00:32:11,500
盡量放在一起

990
00:32:11,500 --> 00:32:13,500
那其中有一個重要的概念就是

991
00:32:13,500 --> 00:32:14,500
SOA和AOS

992
00:32:14,500 --> 00:32:16,500
什麼是SOA

993
00:32:16,500 --> 00:32:17,500
Struct of Array

994
00:32:17,500 --> 00:32:19,500
Array的Struct

995
00:32:19,500 --> 00:32:20,500
什麼是Array的Struct

996
00:32:20,500 --> 00:32:22,500
就是你今天把

997
00:32:22,500 --> 00:32:26,500
一堆Array寫在Struct裡面

998
00:32:26,500 --> 00:32:27,500
那另一個概念是什麼

999
00:32:27,500 --> 00:32:29,500
是AOS

1000
00:32:29,500 --> 00:32:30,500
AOS是Array of Struct

1001
00:32:30,500 --> 00:32:32,500
就是Struct的Array

1002
00:32:32,500 --> 00:32:33,500
那什麼是Struct Array

1003
00:32:33,500 --> 00:32:35,500
就是你今天先定一個Struct

1004
00:32:35,500 --> 00:32:37,500
然後把它聲明成一個Array

1005
00:32:37,500 --> 00:32:38,500
這兩種寫法

1006
00:32:38,500 --> 00:32:40,500
存的資料都一樣多

1007
00:32:40,500 --> 00:32:41,500
但是通常來說

1008
00:32:41,500 --> 00:32:44,500
下面那個AOS的程式執行

1009
00:32:44,500 --> 00:32:45,500
會比較快

1010
00:32:45,500 --> 00:32:46,500
為什麼

1011
00:32:46,500 --> 00:32:47,500
因為你在編譯器裡面

1012
00:32:47,500 --> 00:32:48,500
加入-O3參數以後

1013
00:32:48,500 --> 00:32:50,500
今天編譯器看到AOS的東西

1014
00:32:50,500 --> 00:32:52,500
它可以清楚地辨識到說

1015
00:32:52,500 --> 00:32:54,500
這些記憶體放在一起

1016
00:32:54,500 --> 00:32:55,500
它們鄰近

1017
00:32:55,500 --> 00:32:57,500
那我可以對它們用SSE

1018
00:32:57,500 --> 00:33:01,500
或者是更多的Vector Instruction做加速

1019
00:33:01,500 --> 00:33:03,500
所以我們今天學習這些

1020
00:33:03,500 --> 00:33:04,500
第一點當然就是

1021
00:33:04,500 --> 00:33:05,500
你知道有這個東西

1022
00:33:05,500 --> 00:33:07,500
你可能可以讓編譯器去編

1023
00:33:07,500 --> 00:33:08,500
第二點就是

1024
00:33:08,500 --> 00:33:10,500
你可以寫出一些程式碼

1025
00:33:10,500 --> 00:33:11,500
幫助編譯器

1026
00:33:11,500 --> 00:33:13,500
更好的編好更好的程式碼

1027
00:33:13,500 --> 00:33:14,500
也就是說

1028
00:33:14,500 --> 00:33:16,500
你可以選擇當一個超神的人

1029
00:33:16,500 --> 00:33:17,500
全部都手寫

1030
00:33:17,500 --> 00:33:19,500
那就算你懂一點點

1031
00:33:19,500 --> 00:33:22,500
你也可以稍微地讓它加速

1032
00:33:22,500 --> 00:33:23,500
我們來看它的結論

1033
00:33:23,500 --> 00:33:25,500
今天我們講了三個Case

1034
00:33:25,500 --> 00:33:27,500
一個是Branch Prediction

1035
00:33:27,500 --> 00:33:28,500
它可以加速我們今天

1036
00:33:28,500 --> 00:33:30,500
程式中有if的情況

1037
00:33:30,500 --> 00:33:31,500
第二個是Catch Locality

1038
00:33:31,500 --> 00:33:32,500
我們指的是

1039
00:33:32,500 --> 00:33:34,500
如果你今天用到的變數

1040
00:33:34,500 --> 00:33:37,500
它們在短時間內被使用

1041
00:33:37,500 --> 00:33:39,500
或者是短空間內被使用

1042
00:33:39,500 --> 00:33:40,500
那盡量把它們寫在一起

1043
00:33:40,500 --> 00:33:42,500
或者是盡量把它運用好

1044
00:33:42,500 --> 00:33:44,500
那最後一個就是Vector Processing

1045
00:33:44,500 --> 00:33:45,500
我們希望可以去了解一些

1046
00:33:45,500 --> 00:33:48,500
現在計算機結構發展的趨勢

1047
00:33:48,500 --> 00:33:49,500
去用好那些CPU廠商

1048
00:33:49,500 --> 00:33:51,500
如Intel、AMD

1049
00:33:51,500 --> 00:33:52,500
像今天AMD的贊助商

1050
00:33:52,500 --> 00:33:54,500
他很努力地開發Vector Processing

1051
00:33:54,500 --> 00:33:56,500
所以去把它們寫好東西用好

1052
00:33:56,500 --> 00:33:57,500
也算是一個Programmer

1053
00:33:57,500 --> 00:34:01,500
能盡好的職責

1054
00:34:01,500 --> 00:34:02,500
OK

1055
00:34:02,500 --> 00:34:04,500
那到這邊就是這個結論

1056
00:34:04,500 --> 00:34:05,500
那最後就是

1057
00:34:05,500 --> 00:34:07,500
如果大家對這樣的領域有興趣

1058
00:34:07,500 --> 00:34:09,500
那可以去聽什麼樣的內容

1059
00:34:09,500 --> 00:34:10,500
那第一點就是

1060
00:34:10,500 --> 00:34:11,500
這個Joseph老師

1061
00:34:11,500 --> 00:34:13,500
就是早上的Keynote講者

1062
00:34:13,500 --> 00:34:14,500
他其實在這個

1063
00:34:14,500 --> 00:34:15,500
比較底層的方面

1064
00:34:15,500 --> 00:34:16,500
有很多的著墨

1065
00:34:16,500 --> 00:34:18,500
也寫了非常多有趣的文章

1066
00:34:18,500 --> 00:34:20,500
像是CSAPP

1067
00:34:20,500 --> 00:34:22,500
這本書的資源整理

1068
00:34:22,500 --> 00:34:23,500
那大家如果有興趣

1069
00:34:23,500 --> 00:34:24,500
在我們今天的共筆上面

1070
00:34:24,500 --> 00:34:26,500
可以找到我的簡報連結

1071
00:34:26,500 --> 00:34:27,500
那點連結進去

1072
00:34:27,500 --> 00:34:30,500
應該就可以看到這個超連結

1073
00:34:30,500 --> 00:34:31,500
那這門課裡面

1074
00:34:31,500 --> 00:34:33,500
會概略的介紹

1075
00:34:33,500 --> 00:34:35,500
整個CS的領域裡面

1076
00:34:35,500 --> 00:34:37,500
你可能需要知道的知識

1077
00:34:37,500 --> 00:34:40,500
包括我上面剛剛講到那三個

1078
00:34:40,500 --> 00:34:41,500
那第二個就是

1079
00:34:41,500 --> 00:34:42,500
如果你對於最後一個

1080
00:34:42,500 --> 00:34:43,500
Factor Processing有興趣

1081
00:34:43,500 --> 00:34:45,500
那你可以休息的課程是

1082
00:34:45,500 --> 00:34:47,500
平行程式相關的課程

1083
00:34:47,500 --> 00:34:50,500
那因為我是清大學生

1084
00:34:50,500 --> 00:34:51,500
我們教授有把它

1085
00:34:51,500 --> 00:34:52,500
平行程式的課程

1086
00:34:52,500 --> 00:34:54,500
做為一個OCW放在網路上

1087
00:34:54,500 --> 00:34:55,500
那如果大家對於

1088
00:34:55,500 --> 00:34:56,500
剛剛那樣的東西有興趣

1089
00:34:56,500 --> 00:34:57,500
可以去聽它一整套

1090
00:34:57,500 --> 00:34:58,500
完整的課程

1091
00:34:58,500 --> 00:34:59,500
它會告訴你

1092
00:34:59,500 --> 00:35:00,500
用什麼樣的方式

1093
00:35:00,500 --> 00:35:02,500
可以去加速你的程式

1094
00:35:02,500 --> 00:35:04,500
平行的方式加速你的程式

1095
00:35:04,500 --> 00:35:05,500
那最後就是

1096
00:35:05,500 --> 00:35:07,500
我們來就是工商時間

1097
00:35:07,500 --> 00:35:08,500
那如果大家對於這些

1098
00:35:08,500 --> 00:35:09,500
都很有興趣

1099
00:35:09,500 --> 00:35:10,500
然後你又想要

1100
00:35:10,500 --> 00:35:11,500
真的去接觸這麼

1101
00:35:11,500 --> 00:35:12,500
底層的一體東西

1102
00:35:12,500 --> 00:35:13,500
那歡迎來到清大

1103
00:35:13,500 --> 00:35:14,500
然後我們有一個

1104
00:35:14,500 --> 00:35:15,500
超算團隊

1105
00:35:15,500 --> 00:35:17,500
那什麼是超算團隊呢

1106
00:35:17,500 --> 00:35:18,500
就是一個專門用好

1107
00:35:18,500 --> 00:35:19,500
超級電腦的團隊

1108
00:35:19,500 --> 00:35:21,500
那我們在這個團隊裡面

1109
00:35:21,500 --> 00:35:22,500
會去從硬體

1110
00:35:22,500 --> 00:35:23,500
然後系統

1111
00:35:23,500 --> 00:35:25,500
然後到軟體

1112
00:35:25,500 --> 00:35:27,500
去整套的去理解

1113
00:35:27,500 --> 00:35:28,500
這個計算機架構

1114
00:35:28,500 --> 00:35:30,500
然後去把每一個地方

1115
00:35:30,500 --> 00:35:31,500
能夠加速的加速

1116
00:35:31,500 --> 00:35:33,500
能夠最佳化的最佳化

1117
00:35:33,500 --> 00:35:35,500
那如果你剛好是清大學生

1118
00:35:35,500 --> 00:35:36,500
那又對這個有興趣

1119
00:35:36,500 --> 00:35:37,500
就可以到來找我

1120
00:35:37,500 --> 00:35:39,500
找我報名這樣子

1121
00:35:39,500 --> 00:35:41,500
那再來就是

1122
00:35:41,500 --> 00:35:42,500
如果你對於

1123
00:35:42,500 --> 00:35:43,500
這樣底層的東西有興趣

1124
00:35:43,500 --> 00:35:44,500
然後想加入一個

1125
00:35:44,500 --> 00:35:45,500
Telegram群聊的話

1126
00:35:45,500 --> 00:35:47,500
那這裡有一個QR Code

1127
00:35:47,500 --> 00:35:48,500
希望能掃

1128
00:35:48,500 --> 00:35:49,500
不能掃的話看工筆

1129
00:35:49,500 --> 00:35:51,500
那這個群組裡面

1130
00:35:51,500 --> 00:35:53,500
主要就是會討論一些

1131
00:35:53,500 --> 00:35:55,500
這麼奇怪的知識

1132
00:35:55,500 --> 00:35:57,500
那其實我去年的演講

1133
00:35:57,500 --> 00:35:58,500
都已經提過一次了

1134
00:35:58,500 --> 00:35:59,500
那希望大家可以

1135
00:35:59,500 --> 00:36:00,500
如果你有興趣的話

1136
00:36:00,500 --> 00:36:02,500
可以再加入

1137
00:36:02,500 --> 00:36:04,500
還有三分五十五秒

1138
00:36:04,500 --> 00:36:05,500
那最後就是

1139
00:36:05,500 --> 00:36:06,500
我是William Mo

1140
00:36:06,500 --> 00:36:07,500
那不管你聽不聽過

1141
00:36:07,500 --> 00:36:08,500
反正你現在看過我了

1142
00:36:08,500 --> 00:36:10,500
那我是今年的紀錄組

1143
00:36:10,500 --> 00:36:11,500
所以你可能看到我在拍照

1144
00:36:11,500 --> 00:36:12,500
那我是去年的副招

1145
00:36:12,500 --> 00:36:13,500
是之前的議程組

1146
00:36:13,500 --> 00:36:14,500
那如果大家對於

1147
00:36:14,500 --> 00:36:15,500
參與社群的部分

1148
00:36:15,500 --> 00:36:16,500
有想跟我聊聊

1149
00:36:16,500 --> 00:36:18,500
也歡迎來找我聊聊

1150
00:36:18,500 --> 00:36:20,500
對 C-COM是一個好地方

1151
00:36:20,500 --> 00:36:22,500
那大家可以分享自己的東西

1152
00:36:22,500 --> 00:36:23,500
那再來就是

1153
00:36:23,500 --> 00:36:24,500
我現在是清華大學

1154
00:36:24,500 --> 00:36:26,500
實驗教育大四的學生

1155
00:36:26,500 --> 00:36:27,500
那是特殊選材進去的

1156
00:36:27,500 --> 00:36:28,500
所以如果你剛好

1157
00:36:28,500 --> 00:36:29,500
也是特殊選材的學生

1158
00:36:29,500 --> 00:36:30,500
也想找我聊聊

1159
00:36:30,500 --> 00:36:31,500
也可以找我聊聊

1160
00:36:31,500 --> 00:36:33,500
那我平常接觸的領域是

1161
00:36:33,500 --> 00:36:34,500
高性能計算

1162
00:36:34,500 --> 00:36:36,500
太空 天文和攝影

1163
00:36:38,500 --> 00:36:39,500
OK 那到這邊

1164
00:36:39,500 --> 00:36:40,500
就是我的簡報

1165
00:36:40,500 --> 00:36:41,500
最後一張投影片

1166
00:36:41,500 --> 00:36:43,500
我的Telegram是William Mo

1167
00:36:43,500 --> 00:36:44,500
然後Twitter是William底線Mo

1168
00:36:44,500 --> 00:36:45,500
然後Facebook是

1169
00:36:45,500 --> 00:36:47,500
某展右碩的中文名字

1170
00:36:47,500 --> 00:36:49,500
那如果你不想實體見到我

1171
00:36:49,500 --> 00:36:51,500
你可以用以上方式去找到我

1172
00:36:51,500 --> 00:36:53,500
對 有人可能比較怕生

1173
00:36:53,500 --> 00:36:54,500
那到這邊

1174
00:36:54,500 --> 00:36:56,500
那請幫我切Slide do

1175
00:36:56,500 --> 00:36:57,500
謝謝

1176
00:36:59,500 --> 00:37:01,500
這些觀念在其他層

1177
00:37:01,500 --> 00:37:03,500
為什麼內存不是記憶體

1178
00:37:03,500 --> 00:37:04,500
那也就是因為

1179
00:37:04,500 --> 00:37:05,500
我剛才在趕簡報的時候

1180
00:37:05,500 --> 00:37:06,500
太趕了

1181
00:37:06,500 --> 00:37:07,500
然後Google翻譯戳下去

1182
00:37:07,500 --> 00:37:08,500
它是內存

1183
00:37:08,500 --> 00:37:09,500
很難過啊

1184
00:37:09,500 --> 00:37:10,500
Google翻譯翻傳體中文

1185
00:37:10,500 --> 00:37:11,500
居然是內存 非常的難過

1186
00:37:11,500 --> 00:37:13,500
但是我口語上都講記憶體

1187
00:37:13,500 --> 00:37:14,500
希望大家不要被帶壞

1188
00:37:14,500 --> 00:37:15,500
另外我剛剛有些

1189
00:37:15,500 --> 00:37:16,500
講到優化的地方

1190
00:37:16,500 --> 00:37:18,500
其實應該講最佳化

1191
00:37:18,500 --> 00:37:19,500
請支持翻譯中文的

1192
00:37:19,500 --> 00:37:21,500
技術語言

1193
00:37:24,500 --> 00:37:25,500
對 我每次講完就會變這樣

1194
00:37:25,500 --> 00:37:27,500
大前年也是

1195
00:37:27,500 --> 00:37:29,500
那大家自己修正一下

1196
00:37:29,500 --> 00:37:30,500
好 這些觀念

1197
00:37:30,500 --> 00:37:32,500
在其他程式語言也適用嗎

1198
00:37:32,500 --> 00:37:35,500
那這些觀念在底層的語言

1199
00:37:35,500 --> 00:37:36,500
其實C++也不太底層

1200
00:37:36,500 --> 00:37:38,500
那對於這樣的語言在

1201
00:37:38,500 --> 00:37:40,500
對於在C++這樣的語言

1202
00:37:40,500 --> 00:37:41,500
會有比較明顯的差異

1203
00:37:41,500 --> 00:37:43,500
但是以剛剛那個

1204
00:37:43,500 --> 00:37:45,500
Branch Prediction的例子來說

1205
00:37:45,500 --> 00:37:47,500
Python中也看得到

1206
00:37:47,500 --> 00:37:49,500
它的描述的差異

1207
00:37:49,500 --> 00:37:50,500
所以其他語言中

1208
00:37:50,500 --> 00:37:51,500
其實也基本上適用的

1209
00:37:51,500 --> 00:37:53,500
而且有些語言在這些東西中

1210
00:37:53,500 --> 00:37:55,500
就是有對它進行的最佳化

1211
00:37:55,500 --> 00:37:57,500
那你可能沒有察覺到

1212
00:37:57,500 --> 00:37:58,500
但他們在編譯器

1213
00:37:58,500 --> 00:37:59,500
或者是直譯器的過程中

1214
00:37:59,500 --> 00:38:00,500
也確實的運用了

1215
00:38:00,500 --> 00:38:02,500
這些硬體知識

1216
00:38:02,500 --> 00:38:04,500
那在大眾取向的應用

1217
00:38:04,500 --> 00:38:06,500
讓程式跟指令集

1218
00:38:06,500 --> 00:38:08,500
偶合是好的嗎

1219
00:38:11,500 --> 00:38:12,500
這題可能要看你的

1220
00:38:12,500 --> 00:38:13,500
大眾取向的程式

1221
00:38:13,500 --> 00:38:14,500
到底是多大眾取向

1222
00:38:14,500 --> 00:38:16,500
以我在座的程式來說

1223
00:38:16,500 --> 00:38:17,500
我們很多的

1224
00:38:17,500 --> 00:38:19,500
跟科學運算有關的東西

1225
00:38:19,500 --> 00:38:20,500
那它的確是給科學家用的

1226
00:38:20,500 --> 00:38:22,500
那在學術領域裡面

1227
00:38:22,500 --> 00:38:23,500
也是大眾取向

1228
00:38:23,500 --> 00:38:26,500
那它把它緊密的連在一起

1229
00:38:26,500 --> 00:38:27,500
的確有助於這些科學家

1230
00:38:27,500 --> 00:38:28,500
用更短的時間

1231
00:38:28,500 --> 00:38:30,500
做出更快的加速

1232
00:38:30,500 --> 00:38:31,500
那所以這當然取決於

1233
00:38:31,500 --> 00:38:32,500
你的使用者

1234
00:38:32,500 --> 00:38:34,500
是否能夠支援這些指令集

1235
00:38:34,500 --> 00:38:35,500
那又或者是你就相信

1236
00:38:35,500 --> 00:38:36,500
Open Hardware的迅速發展

1237
00:38:36,500 --> 00:38:38,500
導致你可以幫每個使用者

1238
00:38:38,500 --> 00:38:40,500
訂自己一個屬於他自己的SoC

1239
00:38:40,500 --> 00:38:41,500
也可以解決這個問題

1240
00:38:41,500 --> 00:38:43,500
加大了可以加超讚團隊嗎

1241
00:38:43,500 --> 00:38:45,500
不行 你可以找上面那個留言

1242
00:38:45,500 --> 00:38:47,500
那個留言內存的人

1243
00:38:47,500 --> 00:38:48,500
去跟他創一個

1244
00:38:48,500 --> 00:38:51,500
然後Sort中是不是也包含

1245
00:38:51,500 --> 00:38:52,500
對每個數字做比較嗎

1246
00:38:52,500 --> 00:38:55,500
為什麼加了Sort還會變快

1247
00:38:55,500 --> 00:38:57,500
因為這裡最主要的差異在於

1248
00:38:57,500 --> 00:38:59,500
我最下面做了十萬次的這個

1249
00:38:59,500 --> 00:39:01,500
十萬次的這個加總

1250
00:39:01,500 --> 00:39:03,500
來放大了這個程式的性能

1251
00:39:03,500 --> 00:39:05,500
那因為加總的次數

1252
00:39:05,500 --> 00:39:07,500
遠大於Sort的次數

1253
00:39:07,500 --> 00:39:08,500
所以它變快了

1254
00:39:08,500 --> 00:39:09,500
那為什麼會這樣做

1255
00:39:09,500 --> 00:39:10,500
是因為我們實際的場域中

1256
00:39:10,500 --> 00:39:12,500
也常常發生這樣的狀況

1257
00:39:12,500 --> 00:39:14,500
的確我們更常的情況下是

1258
00:39:14,500 --> 00:39:15,500
排序一次

1259
00:39:15,500 --> 00:39:17,500
但是大量的去使用它

1260
00:39:17,500 --> 00:39:18,500
那在Branch Prediction中

1261
00:39:18,500 --> 00:39:19,500
是誰去猜的

1262
00:39:19,500 --> 00:39:20,500
是CPU去猜的嗎

1263
00:39:20,500 --> 00:39:21,500
沒錯 是CPU去猜的

1264
00:39:21,500 --> 00:39:22,500
猜有很多種方法

1265
00:39:22,500 --> 00:39:23,500
請去學你的季節課本

1266
00:39:23,500 --> 00:39:25,500
它會跟你說它是怎麼猜的

1267
00:39:25,500 --> 00:39:28,500
那是不是有編輯優化的程式

1268
00:39:28,500 --> 00:39:29,500
反而破壞我們改三分之一

1269
00:39:29,500 --> 00:39:30,500
預測程式碼的情況

1270
00:39:30,500 --> 00:39:31,500
有機會

1271
00:39:31,500 --> 00:39:32,500
你在加了O3之後

1272
00:39:32,500 --> 00:39:33,500
其實有很多情況

1273
00:39:33,500 --> 00:39:34,500
都會讓編輯器

1274
00:39:34,500 --> 00:39:35,500
破壞你原本優化的東西

1275
00:39:35,500 --> 00:39:36,500
所以大家要仔細的去

1276
00:39:36,500 --> 00:39:38,500
稍微閱讀一下

1277
00:39:38,500 --> 00:39:40,500
那Effector Processing為例子

1278
00:39:40,500 --> 00:39:42,500
如果Pose只跟Pose影響

1279
00:39:42,500 --> 00:39:44,500
是否寫成Structural Array

1280
00:39:44,500 --> 00:39:46,500
效能會更好

1281
00:39:46,500 --> 00:39:47,500
Pose只跟Pose影響

1282
00:39:47,500 --> 00:39:48,500
是否寫成Structural Array

1283
00:39:48,500 --> 00:39:49,500
效能會更好

1284
00:39:49,500 --> 00:39:50,500
這個主要看你Pose

1285
00:39:50,500 --> 00:39:52,500
跟Pose的使用方法

1286
00:39:52,500 --> 00:39:53,500
如果你都是連續的

1287
00:39:53,500 --> 00:39:54,500
使用Pose的話

1288
00:39:54,500 --> 00:39:55,500
那AOS好

1289
00:39:55,500 --> 00:39:57,500
那如果你沒有連續的使用

1290
00:39:57,500 --> 00:39:58,500
那XOA好

1291
00:39:58,500 --> 00:40:00,500
工筆上的實在連結打不開

1292
00:40:00,500 --> 00:40:02,500
那這是什麼

1293
00:40:02,500 --> 00:40:04,500
那High Resolution Card

1294
00:40:04,500 --> 00:40:05,500
跟Standard Card

1295
00:40:05,500 --> 00:40:06,500
有什麼區別

1296
00:40:06,500 --> 00:40:08,500
這個要查文件

1297
00:40:08,500 --> 00:40:09,500
沒有背完

1298
00:40:09,500 --> 00:40:10,500
這東西不要背

1299
00:40:10,500 --> 00:40:11,500
以晶片設計來說

1300
00:40:11,500 --> 00:40:12,500
這些做法可以算

1301
00:40:12,500 --> 00:40:13,500
犧牲晶片空間

1302
00:40:13,500 --> 00:40:14,500
來換取處理器的時間

1303
00:40:14,500 --> 00:40:15,500
減少碼量

1304
00:40:15,500 --> 00:40:16,500
全加百萬

1305
00:40:16,500 --> 00:40:17,500
半加百萬

1306
00:40:17,500 --> 00:40:18,500
這些差別

1307
00:40:18,500 --> 00:40:19,500
對

1308
00:40:19,500 --> 00:40:20,500
這個都是在

1309
00:40:20,500 --> 00:40:21,500
犧牲晶片的空間

1310
00:40:21,500 --> 00:40:22,500
或者是犧牲晶片的頻率

1311
00:40:22,500 --> 00:40:23,500
例如我們的Intel

1312
00:40:23,500 --> 00:40:24,500
大大採用了

1313
00:40:24,500 --> 00:40:25,500
AVM512的指令集

1314
00:40:25,500 --> 00:40:26,500
它就導致

1315
00:40:26,500 --> 00:40:27,500
它在使用這個指令集的時候

1316
00:40:27,500 --> 00:40:28,500
頻率下降的非常快

1317
00:40:28,500 --> 00:40:29,500
那AMD就沒有出現這個問題

1318
00:40:29,500 --> 00:40:30,500
真的很棒

1319
00:40:30,500 --> 00:40:31,500
那可能是它還沒有推出

1320
00:40:31,500 --> 00:40:32,500
AVM512指令集

1321
00:40:32,500 --> 00:40:33,500
對

1322
00:40:33,500 --> 00:40:34,500
所以這都是一個Tradeoff

1323
00:40:34,500 --> 00:40:35,500
取決於你的使用者是誰

1324
00:40:35,500 --> 00:40:36,500
如果你使用者是科學家

1325
00:40:36,500 --> 00:40:38,500
那他覺得Tradeoff是划算的

1326
00:40:38,500 --> 00:40:39,500
如果使用者是一般貴重

1327
00:40:39,500 --> 00:40:40,500
那他覺得這是不划算的

1328
00:40:40,500 --> 00:40:41,500
所以對

1329
00:40:41,500 --> 00:40:42,500
我還是覺得

1330
00:40:42,500 --> 00:40:43,500
這個CPU應該分為兩種產品

1331
00:40:43,500 --> 00:40:45,500
現在才是最好的發展過程

1332
00:40:45,500 --> 00:40:47,500
進程跟專案推薦哪個

1333
00:40:47,500 --> 00:40:48,500
如果你要特選

1334
00:40:48,500 --> 00:40:49,500
就現在只能選進程

1335
00:40:49,500 --> 00:40:50,500
沒得選

1336
00:40:50,500 --> 00:40:51,500
然後

1337
00:40:51,500 --> 00:40:52,500
雖然我不是進程上的

1338
00:40:52,500 --> 00:40:53,500
對

1339
00:40:53,500 --> 00:40:54,500
我是靠專案上的

1340
00:40:54,500 --> 00:40:55,500
但是我事實上不分析

1341
00:40:55,500 --> 00:40:56,500
對

1342
00:40:56,500 --> 00:40:57,500
清大直共還是只收進程

1343
00:40:57,500 --> 00:40:58,500
對

1344
00:40:58,500 --> 00:40:59,500
然後學長會物理滲透嗎

1345
00:40:59,500 --> 00:41:00,500
可能不會

1346
00:41:00,500 --> 00:41:01,500
可能會

1347
00:41:01,500 --> 00:41:02,500
那這算壓長處的一種嗎

1348
00:41:02,500 --> 00:41:03,500
我覺得

1349
00:41:03,500 --> 00:41:05,500
我覺得有點算

1350
00:41:05,500 --> 00:41:06,500
有點算

1351
00:41:06,500 --> 00:41:07,500
對 有點算

1352
00:41:07,500 --> 00:41:08,500
那有沒有AV5S的

1353
00:41:08,500 --> 00:41:09,500
暫存器不夠用

1354
00:41:09,500 --> 00:41:11,500
要看你用多少

1355
00:41:11,500 --> 00:41:12,500
你用得太多

1356
00:41:12,500 --> 00:41:13,500
當然不夠用

1357
00:41:13,500 --> 00:41:14,500
那有沒有考慮到

1358
00:41:14,500 --> 00:41:15,500
你的老舌

1359
00:41:15,500 --> 00:41:16,500
沒有 謝謝

1360
00:41:16,500 --> 00:41:17,500
Branch Prediction

1361
00:41:17,500 --> 00:41:18,500
這個抄寫會太久

1362
00:41:18,500 --> 00:41:19,500
反正當然是總招

1363
00:41:19,500 --> 00:41:20,500
對不對

1364
00:41:20,500 --> 00:41:22,500
副招想多一點是可以的

1365
00:41:22,500 --> 00:41:23,500
Branch Prediction

1366
00:41:23,500 --> 00:41:25,500
那選擇去處理DataHash嗎

1367
00:41:25,500 --> 00:41:26,500
對

1368
00:41:26,500 --> 00:41:27,500
他沒猜錯

1369
00:41:27,500 --> 00:41:28,500
他猜錯的情況下

1370
00:41:28,500 --> 00:41:29,500
就是因為DataHash

1371
00:41:29,500 --> 00:41:30,500
所以他就爛掉了

1372
00:41:30,500 --> 00:41:31,500
你講話這麼快

1373
00:41:31,500 --> 00:41:32,500
有用Branch Prediction嗎

1374
00:41:32,500 --> 00:41:33,500
腦袋自建

1375
00:41:33,500 --> 00:41:36,500
你可以去安裝一下

1376
00:41:36,500 --> 00:41:37,500
好

1377
00:41:37,500 --> 00:41:38,500
那這是超算的範圍嗎

1378
00:41:38,500 --> 00:41:39,500
是

1379
00:41:39,500 --> 00:41:40,500
超算的範圍

1380
00:41:40,500 --> 00:41:41,500
從硬體的超頻

1381
00:41:41,500 --> 00:41:44,500
到平行程式都有

1382
00:41:44,500 --> 00:41:45,500
這個這不

1383
00:41:45,500 --> 00:41:46,500
你問他

1384
00:41:46,500 --> 00:41:47,500
然後

1385
00:41:47,500 --> 00:41:48,500
有沒有主持人IG

1386
00:41:48,500 --> 00:41:49,500
問他

1387
00:41:49,500 --> 00:41:50,500
非貴校有加入超算團隊

1388
00:41:50,500 --> 00:41:52,500
跟有審核條件嗎

1389
00:41:52,500 --> 00:41:53,500
沒有

1390
00:41:53,500 --> 00:41:54,500
加入我們清大

1391
00:41:54,500 --> 00:41:55,500
清大學生加入超算團隊

1392
00:41:55,500 --> 00:41:56,500
沒有審核條件

1393
00:41:56,500 --> 00:41:58,500
就是你只要跟下去

1394
00:41:58,500 --> 00:41:59,500
就會成長

1395
00:41:59,500 --> 00:42:00,500
對 我們沒有任何審核條件

1396
00:42:00,500 --> 00:42:01,500
那非貴校

1397
00:42:01,500 --> 00:42:02,500
我就不知道

1398
00:42:02,500 --> 00:42:03,500
去問你們學校

1399
00:42:03,500 --> 00:42:04,500
聽說成大也有

1400
00:42:04,500 --> 00:42:05,500
然後

1401
00:42:05,500 --> 00:42:06,500
特殊院台怎麼準備

1402
00:42:06,500 --> 00:42:07,500
你去問早上的開放式議程

1403
00:42:07,500 --> 00:42:08,500
問我幹嘛

1404
00:42:08,500 --> 00:42:09,500
我已經大四了

1405
00:42:09,500 --> 00:42:10,500
然後

1406
00:42:10,500 --> 00:42:11,500
嘴巴超頻算嗎

1407
00:42:11,500 --> 00:42:12,500
不算

1408
00:42:12,500 --> 00:42:13,500
可能算

1409
00:42:13,500 --> 00:42:14,500
英文的話就可能算

1410
00:42:14,500 --> 00:42:15,500
求CUDA版

1411
00:42:15,500 --> 00:42:16,500
你去找那邊有一個

1412
00:42:16,500 --> 00:42:17,500
CUDA的大師

1413
00:42:17,500 --> 00:42:18,500
或者是NVIDIA的實習的人

1414
00:42:18,500 --> 00:42:19,500
對

1415
00:42:19,500 --> 00:42:20,500
NVIDIA跟ND是對手

1416
00:42:20,500 --> 00:42:21,500
我們不能在那邊講

1417
00:42:21,500 --> 00:42:22,500
然後

1418
00:42:22,500 --> 00:42:23,500
想要投稿明年試試看

1419
00:42:23,500 --> 00:42:24,500
要怎麼準備

1420
00:42:24,500 --> 00:42:25,500
不知道

1421
00:42:25,500 --> 00:42:26,500
想交男朋友嗎

1422
00:42:26,500 --> 00:42:27,500
應該沒有

1423
00:42:27,500 --> 00:42:29,500
什麼時候幫交大創一個

1424
00:42:29,500 --> 00:42:30,500
去問交大仔

1425
00:42:30,500 --> 00:42:31,500
這是清大的

1426
00:42:31,500 --> 00:42:32,500
關我什麼事

1427
00:42:32,500 --> 00:42:33,500
那個青椒小靜反過來念

1428
00:42:33,500 --> 00:42:34,500
我們再說嘛

1429
00:42:34,500 --> 00:42:35,500
青椒小靜

1430
00:42:35,500 --> 00:42:36,500
都念青椒小靜再說嘛

1431
00:42:36,500 --> 00:42:37,500
那

1432
00:42:37,500 --> 00:42:38,500
那個Hus

1433
00:42:38,500 --> 00:42:39,500
是Control Hus嗎

1434
00:42:39,500 --> 00:42:40,500
Hus

1435
00:42:40,500 --> 00:42:41,500
我想一下

1436
00:42:41,500 --> 00:42:42,500
是

1437
00:42:44,500 --> 00:42:46,500
吃葡萄不吐葡萄皮

1438
00:42:49,500 --> 00:42:50,500
那

1439
00:42:50,500 --> 00:42:51,500
對

1440
00:42:52,500 --> 00:42:53,500
霹靂卡霹靂啦啦

1441
00:42:53,500 --> 00:42:54,500
啵啵叮噹

1442
00:42:54,500 --> 00:42:55,500
貝貝魯多

1443
00:42:55,500 --> 00:42:56,500
應該沒有了對不對

1444
00:42:56,500 --> 00:42:57,500
好 謝謝大家

1445
00:42:57,500 --> 00:42:58,500
那

1446
00:42:58,500 --> 00:42:59,500
對

1447
00:42:59,500 --> 00:43:00,500
謝謝

1448
00:43:00,500 --> 00:43:01,500
下面的總導主

