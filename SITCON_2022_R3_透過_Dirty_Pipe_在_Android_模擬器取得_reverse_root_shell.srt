1
00:00:00,000 --> 00:00:07,680
大家好，我是來帶大家看這場議程的講者

2
00:00:07,680 --> 00:00:13,320
我們題目就是透過 Dirty Pi 在 Android 模擬器上取得 Reverse-to-Show

3
00:00:13,320 --> 00:00:16,200
大家可能會聽著聽著不曉得啥

4
00:00:16,200 --> 00:00:22,000
大家可能都會，我們這場比較硬核一點，希望大家可以撐到最後

5
00:00:22,000 --> 00:00:25,080
先來自我介紹一下

6
00:00:25,080 --> 00:00:28,520
下面那一個是螢幕，這是我的 ID

7
00:00:28,520 --> 00:00:33,120
我現在就在 Team T5 擔任第三九的實習生

8
00:00:33,120 --> 00:00:36,960
我是在做一個 Vulnerability Researcher

9
00:00:36,960 --> 00:00:40,040
就這間公司，這邊也看得到

10
00:00:40,040 --> 00:00:44,640
我們應該有擺攤，可以去稍微逛一下

11
00:00:44,640 --> 00:00:49,000
另外的話是李仁，他一樣就是

12
00:00:49,000 --> 00:00:54,640
大家好，我也是 T5 的實習生，現在是中山治安所的研究生

13
00:00:55,640 --> 00:01:01,640
目前 Focus 在 Mobile Security 跟 Linux Kernel 的安全

14
00:01:01,640 --> 00:01:05,640
反正我們就是一群喜歡治安的傢伙

15
00:01:05,640 --> 00:01:10,640
希望在座各位可能對治安會有些興趣

16
00:01:10,640 --> 00:01:15,640
我們可能就會跟你說，治安不是這麼的簡單

17
00:01:15,640 --> 00:01:21,640
接著是我們的 slide 的部分

18
00:01:22,640 --> 00:01:25,640
首先來講一下我們到底是在幹嘛

19
00:01:25,640 --> 00:01:27,640
因為我們的題目可以看到

20
00:01:27,640 --> 00:01:30,640
我們會想要在 Android 上面去做一個 Exploring

21
00:01:30,640 --> 00:01:33,640
我們的目標是用一個 Kernel 上的 CVE

22
00:01:33,640 --> 00:01:36,640
這個 CVE 的話，因為是 Kernel

23
00:01:36,640 --> 00:01:38,640
Android 它用到的 Kernel 是 Linux Kernel

24
00:01:38,640 --> 00:01:40,640
我們的目標是做提權

25
00:01:40,640 --> 00:01:42,640
所以說我們就要先來看一下

26
00:01:42,640 --> 00:01:45,640
怎麼在基本的 Linux 上去做一個提權部分

27
00:01:45,640 --> 00:01:48,640
正常情況下我們可以看到說

28
00:01:48,640 --> 00:01:51,640
就是我們會想要去做 APD Install 一個東西

29
00:01:51,640 --> 00:01:53,640
我們這邊 Install 一個 Seq, 雖然它不存在

30
00:01:53,640 --> 00:01:56,640
但你可以看到說它就是會有一個 Permission Deny 的部分

31
00:01:56,640 --> 00:01:58,640
就是代表你沒有權限嘛

32
00:01:58,640 --> 00:02:01,640
那在這種時候我們通常會想要去做一件事情就是

33
00:02:01,640 --> 00:02:04,640
Sudo, 沒錯，這大家應該都知道

34
00:02:04,640 --> 00:02:09,640
我們就直接 Sudo 下去，Install, 就可以成功了，讚

35
00:02:09,640 --> 00:02:12,640
那就是因為我是要做一些提權部分

36
00:02:12,640 --> 00:02:15,640
那我先來看一下 Sudo 這件事情到底在做什麼事

37
00:02:15,640 --> 00:02:17,640
首先的話，這 Sudo 的話它就先去看

38
00:02:17,640 --> 00:02:19,640
你的當前這個 User 是不是一個 Sudoers

39
00:02:19,640 --> 00:02:22,640
如果你是 Sudoers 的話，它就會再去跟你說

40
00:02:22,640 --> 00:02:25,640
你要給我就是你這 Sudoers 的密碼

41
00:02:25,640 --> 00:02:29,640
那這密碼正確之後，就是它才會去做提權部分

42
00:02:29,640 --> 00:02:34,640
那提權做的事情其實它是在去執行到一個 System Code

43
00:02:34,640 --> 00:02:37,640
Needle Scroll 的一個 System Code, 叫做 Set UID

44
00:02:37,640 --> 00:02:41,640
那做完 Set UID 之後，你就會把你的 UID 轉換成 0

45
00:02:41,640 --> 00:02:43,640
也就是你就切換到 Root 這個 User

46
00:02:43,640 --> 00:02:47,640
那 Root 這個 User 就是有一個非常高權限的一個 User

47
00:02:47,640 --> 00:02:49,640
你就可以直接做 APT Install 這樣

48
00:02:49,640 --> 00:02:53,640
對，然後你這邊的話可以看到就是

49
00:02:53,640 --> 00:02:55,640
除此之外，就是我這 Sudo 這個 Binary

50
00:02:55,640 --> 00:02:59,640
它其實是帶有一個 Ninus 的一個 Flag

51
00:02:59,640 --> 00:03:01,640
叫 Set UID Flag

52
00:03:01,640 --> 00:03:03,640
那有這個 Flag 的情況下

53
00:03:03,640 --> 00:03:07,640
Ninus 才會允許你出去做 Set UID 轉換成 Root

54
00:03:07,640 --> 00:03:09,640
對，沒錯，就會有一個這樣的機制

55
00:03:09,640 --> 00:03:11,640
這就是一些 Ninus 的一些背景

56
00:03:12,640 --> 00:03:14,640
那我們稍微來看一下 Root 是啥

57
00:03:14,640 --> 00:03:18,640
這邊的話是擷取自 Manual7 Capabilities 的部分

58
00:03:18,640 --> 00:03:21,640
那你可以看到它上面其實要講的事情就是

59
00:03:21,640 --> 00:03:24,640
當你是 Root 這個 User 的時候

60
00:03:24,640 --> 00:03:28,640
Kernel 那邊的就是檢查機制全部 line 過

61
00:03:28,640 --> 00:03:31,640
沒錯，所以就是 Root 超強

62
00:03:31,640 --> 00:03:34,640
沒錯，所以 Root 就可以像是這個超級肌肉彩彩

63
00:03:34,640 --> 00:03:37,640
而其他 User 就是非常

64
00:03:37,640 --> 00:03:40,640
就是可以拿到的 Capabilities 比較少

65
00:03:41,640 --> 00:03:44,640
但是就是說我們會有碰到一個情況

66
00:03:44,640 --> 00:03:48,640
因為我們現在是要做一個非法的提權

67
00:03:48,640 --> 00:03:50,640
我們是透過一個 Exploit 去做一個非法的提權

68
00:03:50,640 --> 00:03:55,640
那非法提權我們當然不見得會拿一個有 stoolers 的 User 來去做提權

69
00:03:55,640 --> 00:03:58,640
而且除此之外我們也可能會

70
00:03:58,640 --> 00:04:01,640
就算我們是一個 stoolers 我們也有可能不會沒有 password

71
00:04:01,640 --> 00:04:05,640
那我們就沒辦法去做就是後續的 setEUID 來去做提權的部分

72
00:04:05,640 --> 00:04:08,640
所以你就可以看到這邊就是 stool

73
00:04:08,640 --> 00:04:11,640
他做了 stool 但是因為你不是 stooler

74
00:04:11,640 --> 00:04:14,640
所以我還是不行來哈哈沒錯

75
00:04:14,640 --> 00:04:16,640
所以我們這邊的話就會要去做一個就是

76
00:04:16,640 --> 00:04:18,640
不正常的一個提權的手段

77
00:04:18,640 --> 00:04:21,640
那這邊的話就是利用 linux kernel 的一個

78
00:04:21,640 --> 00:04:24,640
就是的一個 vulnerability 來去做提權

79
00:04:24,640 --> 00:04:29,640
那我們來看一下我們到底是用到哪一個就是漏洞的部分

80
00:04:29,640 --> 00:04:32,640
ok 那這邊我們用到的就是我們標題所說到的 dirtypy 這個漏洞

81
00:04:32,640 --> 00:04:34,640
那這個漏洞的話它是

82
00:04:34,640 --> 00:04:37,640
因為通常我們在去講漏洞的時候我們會提到一個編號

83
00:04:37,640 --> 00:04:41,640
就是代表這個漏洞那它是 cv20220847

84
00:04:41,640 --> 00:04:45,640
那大家就可以去有空就可以去看一下 cv 到底是什麼一個概念

85
00:04:45,640 --> 00:04:49,640
它其實就是一個漏洞的管理的一個資料庫這樣

86
00:04:49,640 --> 00:04:51,640
那它後來是一個 linux kernel 的漏洞

87
00:04:51,640 --> 00:04:54,640
那它這個漏洞能做的事情就是可以去對一個 reonly file

88
00:04:54,640 --> 00:04:56,640
可以去做就是任意寫

89
00:04:56,640 --> 00:04:59,640
也就是因為你們通常應該有寫過

90
00:04:59,640 --> 00:05:03,640
就是對 file 的就是去做 rewrite 的部分就知道

91
00:05:03,640 --> 00:05:07,640
如果你去 open 一個 file 是 reonly 的一個權限

92
00:05:07,640 --> 00:05:08,640
那你是沒辦法去做 rewrite 的

93
00:05:08,640 --> 00:05:12,640
但在這個漏洞下你可以去對一個 reonly 的 file

94
00:05:12,640 --> 00:05:14,640
去做一個就是寫入的部分

95
00:05:14,640 --> 00:05:18,640
但它就還是會有一些限制

96
00:05:18,640 --> 00:05:21,640
就是你至少還是要能夠去對一個 file 去進行 open 和 read

97
00:05:21,640 --> 00:05:24,640
而且它一次就只能去寫一個 page 的 size

98
00:05:24,640 --> 00:05:26,640
也就是 0x4096 這個大小

99
00:05:26,640 --> 00:05:28,640
0x100 就是 4096 這個大小的 size

100
00:05:28,640 --> 00:05:32,640
而且它就是每一個 page 就是第一個 byte 是沒辦法去寫的

101
00:05:32,640 --> 00:05:34,640
會有這樣的一個限制

102
00:05:34,640 --> 00:05:38,640
但它其實還是在 linux 上還蠻好用的

103
00:05:38,640 --> 00:05:40,640
就是因為 sudo 它是一個 ELF

104
00:05:40,640 --> 00:05:42,640
就是如果大家知道的話就是

105
00:05:42,640 --> 00:05:45,640
ELF 就是一個可以執行檔案的一個格式

106
00:05:45,640 --> 00:05:48,640
那這個格式裡面就會帶有就是一個片段

107
00:05:48,640 --> 00:05:52,640
就是代表著你現在準備要執行的那個 code

108
00:05:52,640 --> 00:05:53,640
那我們就可以直接

109
00:05:53,640 --> 00:05:56,640
然後這個突然這個檔案它會是一個 reonly 的檔案

110
00:05:56,640 --> 00:05:58,640
那這樣我可以去對 reonly 的檔案去寫的話

111
00:05:58,640 --> 00:06:02,640
我們就可以今天把這個檔案把它寫成就是

112
00:06:02,640 --> 00:06:05,640
讓它就直接去 set euid

113
00:06:05,640 --> 00:06:07,640
不做檢查你是不是 sudo 了

114
00:06:07,640 --> 00:06:09,640
也不去檢查你有沒有 password

115
00:06:09,640 --> 00:06:12,640
直接去做提升權限到 root 的部分

116
00:06:12,640 --> 00:06:14,640
對這樣就可以直接去做就是

117
00:06:14,640 --> 00:06:17,640
拿到就是 root 的權限了

118
00:06:17,640 --> 00:06:18,640
沒錯

119
00:06:18,640 --> 00:06:21,640
所以在 linux 上的就是非法提前就這麼簡單

120
00:06:21,640 --> 00:06:22,640
對

121
00:06:22,640 --> 00:06:24,640
我就只要去找到 sudo 這個 binary

122
00:06:24,640 --> 00:06:25,640
把它的 code 改一下

123
00:06:25,640 --> 00:06:28,640
然後其實那個要改 code 網路上都找得到

124
00:06:28,640 --> 00:06:30,640
對就稍微複製貼上改一下

125
00:06:30,640 --> 00:06:31,640
然後就可以去提權了

126
00:06:31,640 --> 00:06:32,640
對

127
00:06:32,640 --> 00:06:36,640
ok 那接著要講 android 的部分就先交給李恩

128
00:06:36,640 --> 00:06:39,640
好那我們剛剛看完了

129
00:06:39,640 --> 00:06:42,640
我們在一般 linux 後上用 dirty pipe 提權方式

130
00:06:42,640 --> 00:06:43,640
其實是很簡單

131
00:06:43,640 --> 00:06:45,640
那我們接下來就是換到 android 環境

132
00:06:45,640 --> 00:06:49,640
那在 android 環境其實就是沒有一般 linux 上

133
00:06:49,640 --> 00:06:51,640
像是有 suid flag 的 binary

134
00:06:51,640 --> 00:06:53,640
像是沒有 sudo binary 沒有 su binary

135
00:06:53,640 --> 00:06:55,640
那的話我們就要思考一個問題說

136
00:06:55,640 --> 00:06:57,640
那我們還有什麼方式來能夠提權

137
00:06:57,640 --> 00:07:00,640
那第二點就是我們對於環境的可能會比較陌生

138
00:07:00,640 --> 00:07:02,640
可能會遇到像是 debug 的問題

139
00:07:02,640 --> 00:07:03,640
然後架構上的問題

140
00:07:03,640 --> 00:07:06,640
那我們這些問題也是我們需要處理的

141
00:07:06,640 --> 00:07:08,640
那第三點就是魔王守門員

142
00:07:08,640 --> 00:07:10,640
就是其實 android 的系統底層

143
00:07:10,640 --> 00:07:13,640
它裡面是有一個叫做 SE linux 的保護機制

144
00:07:13,640 --> 00:07:18,640
那這個東西其實是非常的頭痛的東西

145
00:07:18,640 --> 00:07:20,640
那我們就來想想看有什麼想法

146
00:07:20,640 --> 00:07:22,640
那我們的第一個想法可能是

147
00:07:22,640 --> 00:07:24,640
如果我們人在 android 的系統上

148
00:07:24,640 --> 00:07:27,640
我們能夠控制到一支比較高權限的 process 的話

149
00:07:27,640 --> 00:07:30,640
那我們是不是就有比較高的權限了

150
00:07:30,640 --> 00:07:32,640
那其實在理論上手機一開機

151
00:07:32,640 --> 00:07:35,640
或是系統一開機都會有一些程式執行

152
00:07:35,640 --> 00:07:37,640
那執行的時候應該是那些東西都是

153
00:07:37,640 --> 00:07:40,640
帶有比較高權限的 process

154
00:07:40,640 --> 00:07:42,640
所以我們可能就會選擇像是 init 啊

155
00:07:42,640 --> 00:07:45,640
或是什麼 uid 之類的 process

156
00:07:45,640 --> 00:07:48,640
那我們接下來就是想辦法去寫一些檔案

157
00:07:48,640 --> 00:07:49,640
就是我們用 3dpy

158
00:07:49,640 --> 00:07:51,640
我們可以去對 readonly 的檔案進行寫入

159
00:07:51,640 --> 00:07:53,640
那我們就去寫一些檔案

160
00:07:53,640 --> 00:07:56,640
那我們嘗試來改變到這些 process 的執行流程

161
00:07:56,640 --> 00:08:00,640
進而來控制它

162
00:08:00,640 --> 00:08:01,640
好 那我們要怎麼做

163
00:08:01,640 --> 00:08:04,640
我們首先要先決定我們要解釋的 process

164
00:08:04,640 --> 00:08:06,640
那我們這邊選擇的是 init process

165
00:08:06,640 --> 00:08:10,640
也就是手機一開機第一支執行的 process

166
00:08:10,640 --> 00:08:12,640
那 init 除了有 root 的權限以外

167
00:08:12,640 --> 00:08:14,640
其實它在 s-linear 上有一些

168
00:08:14,640 --> 00:08:17,640
它路上有一些還不錯而且很好用的東西

169
00:08:17,640 --> 00:08:19,640
以及我們在 bypass

170
00:08:19,640 --> 00:08:23,640
把 s-linear 繞掉的時候會很方便的一個路

171
00:08:23,640 --> 00:08:26,640
那在後面會再介紹到

172
00:08:26,640 --> 00:08:28,640
那第三個就是我們要想我們要怎麼做

173
00:08:28,640 --> 00:08:30,640
我們要怎麼解釋

174
00:08:30,640 --> 00:08:33,640
可是我們剛剛講到的是什麼

175
00:08:33,640 --> 00:08:35,640
s-linear

176
00:08:35,640 --> 00:08:37,640
它其實就是一個非常噁心

177
00:08:37,640 --> 00:08:39,640
就是它 policy 跟那個 rule 之類的

178
00:08:39,640 --> 00:08:41,640
都是非常討人厭的

179
00:08:41,640 --> 00:08:43,640
所以很多人聽到這個字

180
00:08:43,640 --> 00:08:47,640
身體就會抖一下這樣子

181
00:08:47,640 --> 00:08:49,640
來到我們解釋 process 的部分

182
00:08:49,640 --> 00:08:51,640
那我們可以從漏洞可以做到的事情

183
00:08:51,640 --> 00:08:53,640
開始思考說

184
00:08:53,640 --> 00:08:56,640
怎麼解釋才是一個我們可以做到的事情

185
00:08:56,640 --> 00:08:58,640
那我們要解釋的 process

186
00:08:58,640 --> 00:09:01,640
我們必須要先對這支 process 有一定程度的了解

187
00:09:01,640 --> 00:09:04,640
我們要去追一下這支 process 可能會做哪些事情

188
00:09:04,640 --> 00:09:06,640
那以及這支 process 它有沒有

189
00:09:06,640 --> 00:09:07,640
它可能用了哪些東西

190
00:09:07,640 --> 00:09:11,640
像是用了哪個 library 之類的

191
00:09:11,640 --> 00:09:13,640
那 initprocess 就是它開機完以後

192
00:09:13,640 --> 00:09:15,640
它會進入到一個 while loop 的狀態

193
00:09:15,640 --> 00:09:18,640
它就是一直在那邊睡覺等待一些事件的觸發

194
00:09:18,640 --> 00:09:21,640
那並且 init 是一支 C++ 所編譯出來的 binary

195
00:09:21,640 --> 00:09:23,640
所以說它就有 lib

196
00:09:23,640 --> 00:09:27,640
它一定會用到 libc++ 的 function

197
00:09:27,640 --> 00:09:30,640
所以我們就可以嘗試去改 libc++.so

198
00:09:30,640 --> 00:09:33,640
這個 shared library

199
00:09:33,640 --> 00:09:34,640
那接下來就是看看說

200
00:09:34,640 --> 00:09:36,640
我們用什麼方式可以觸發到它的事件

201
00:09:36,640 --> 00:09:37,640
讓它起床

202
00:09:37,640 --> 00:09:41,640
就是讓它 wake 起來

203
00:09:41,640 --> 00:09:43,640
那我們接下來就是來劫持它

204
00:09:43,640 --> 00:09:46,640
那我們發現到說

205
00:09:46,640 --> 00:09:48,640
我們可以用 cplot 這個 convent

206
00:09:48,640 --> 00:09:49,640
可以讓 init 的醒來

207
00:09:49,640 --> 00:09:50,640
就是它在醒來以後

208
00:09:50,640 --> 00:09:52,640
它就處理一些事件

209
00:09:52,640 --> 00:09:54,640
那它其實就是會跟它

210
00:09:54,640 --> 00:09:57,640
所 listen 的 file destructor 進行溝通

211
00:09:57,640 --> 00:09:59,640
那我們就是去看

212
00:09:59,640 --> 00:10:01,640
它在處理事件的地方

213
00:10:01,640 --> 00:10:06,640
有沒有用到 libc++.so 的 function

214
00:10:06,640 --> 00:10:09,640
那其實在改 library 的時候

215
00:10:09,640 --> 00:10:10,640
我們會需要注意到一點

216
00:10:10,640 --> 00:10:12,640
就是我們希望我們改到的內容

217
00:10:12,640 --> 00:10:13,640
其實是越少越好

218
00:10:13,640 --> 00:10:15,640
畢竟我們改 library 的話

219
00:10:15,640 --> 00:10:17,640
其他 process 或其他 service

220
00:10:17,640 --> 00:10:19,640
它用到這個 library 的時候

221
00:10:19,640 --> 00:10:21,640
它可能也會有一些問題

222
00:10:21,640 --> 00:10:23,640
那可能導致直接手機壞掉

223
00:10:23,640 --> 00:10:25,640
或者是它就直接 reboot

224
00:10:25,640 --> 00:10:27,640
那要一步一步去 debug

225
00:10:27,640 --> 00:10:28,640
會變得很麻煩

226
00:10:28,640 --> 00:10:29,640
所以我們會希望說

227
00:10:29,640 --> 00:10:30,640
我們改到的 code

228
00:10:30,640 --> 00:10:34,640
其實比較少一點會比較好

229
00:10:34,640 --> 00:10:35,640
那接下來就直接講到

230
00:10:35,640 --> 00:10:37,640
我們改的 target

231
00:10:37,640 --> 00:10:38,640
我們直接去改的是

232
00:10:38,640 --> 00:10:41,640
iOS base init 這個 function

233
00:10:41,640 --> 00:10:43,640
我們就改它 jump

234
00:10:43,640 --> 00:10:45,640
就是它下面紅色框

235
00:10:45,640 --> 00:10:46,640
那個 jump 的 introduction

236
00:10:46,640 --> 00:10:48,640
它原本預期會 jump 到

237
00:10:48,640 --> 00:10:50,640
一個 locate 這個 function

238
00:10:50,640 --> 00:10:51,640
那我們直接讓它

239
00:10:51,640 --> 00:10:52,640
jump 到我們的 shellcode 上

240
00:10:52,640 --> 00:10:53,640
我們用 derivative

241
00:10:53,640 --> 00:10:54,640
直接寫五個 byte

242
00:10:54,640 --> 00:10:56,640
讓它 jump 到我們的 shellcode 上

243
00:10:56,640 --> 00:10:57,640
那我們 shellcode

244
00:10:57,640 --> 00:10:59,640
放的位置是哪裡呢

245
00:10:59,640 --> 00:11:00,640
我們 shellcode 放的是

246
00:11:00,640 --> 00:11:02,640
cxiv cdelete 的這個 function 上

247
00:11:02,640 --> 00:11:04,640
那為什麼會選擇這一塊

248
00:11:04,640 --> 00:11:06,640
是因為說我們在經過測試的時候

249
00:11:06,640 --> 00:11:08,640
我們發現說我們把

250
00:11:08,640 --> 00:11:09,640
shellcode 放在上面

251
00:11:09,640 --> 00:11:12,640
它不會有任何系統 crash 的事情

252
00:11:12,640 --> 00:11:13,640
意思就是說

253
00:11:13,640 --> 00:11:14,640
可能其他的 service

254
00:11:14,640 --> 00:11:15,640
或者是什麼 process

255
00:11:15,640 --> 00:11:18,640
幾乎不會 call 到這個 function

256
00:11:18,640 --> 00:11:20,640
好 那我們 exploit

257
00:11:20,640 --> 00:11:22,640
想要在 CI 裡面

258
00:11:22,640 --> 00:11:23,640
為所欲為的話

259
00:11:23,640 --> 00:11:24,640
我們可以先把 shellcode

260
00:11:24,640 --> 00:11:25,640
先丟上去

261
00:11:25,640 --> 00:11:27,640
因為它完全不會壞掉

262
00:11:27,640 --> 00:11:28,640
那我們再透過 derivative

263
00:11:28,640 --> 00:11:31,640
把 iOS base init 的 jump 指令改掉

264
00:11:31,640 --> 00:11:35,640
讓它 jump 到我們的 shellcode 上

265
00:11:35,640 --> 00:11:37,640
那我們以圖來稍微說明

266
00:11:37,640 --> 00:11:38,640
就是這樣

267
00:11:38,640 --> 00:11:39,640
我們一開始淺藍色那一塊

268
00:11:39,640 --> 00:11:41,640
就是我們先把 shellcode 丟上去

269
00:11:41,640 --> 00:11:42,640
那 shellcode 丟上去以後

270
00:11:42,640 --> 00:11:44,640
我們就去改

271
00:11:44,640 --> 00:11:46,640
那個 iOS base init 這個 function

272
00:11:46,640 --> 00:11:48,640
我們就讓它 jump 到我們的 shellcode 上

273
00:11:48,640 --> 00:11:49,640
所以就是一個蠻簡單的

274
00:11:49,640 --> 00:11:53,640
jump throw 的 attack

275
00:11:53,640 --> 00:11:55,640
好 那整個劫持過程是這樣子的

276
00:11:55,640 --> 00:11:56,640
是我們在一般的

277
00:11:56,640 --> 00:11:58,640
使用者的情況下

278
00:11:58,640 --> 00:12:00,640
我們 shell user 我們是

279
00:12:00,640 --> 00:12:02,640
做 separate command 的時候

280
00:12:02,640 --> 00:12:03,640
它會觸發到

281
00:12:03,640 --> 00:12:05,640
se-permission 的 error

282
00:12:05,640 --> 00:12:07,640
那觸發到 se-permission error 的時候

283
00:12:07,640 --> 00:12:08,640
它系統上會有

284
00:12:08,640 --> 00:12:10,640
會嘗試想要把這個

285
00:12:10,640 --> 00:12:11,640
這個狀態記錄起來

286
00:12:11,640 --> 00:12:12,640
所以它會 call 到

287
00:12:12,640 --> 00:12:13,640
log message 的這個 function

288
00:12:13,640 --> 00:12:14,640
那 call 到 log message 的 function

289
00:12:14,640 --> 00:12:15,640
它跟 IO 相關

290
00:12:15,640 --> 00:12:16,640
所以它就是會再 call 到

291
00:12:16,640 --> 00:12:18,640
iOS base init

292
00:12:18,640 --> 00:12:19,640
那 iOS base init 這個 function

293
00:12:19,640 --> 00:12:20,640
就是已經被我們改掉

294
00:12:20,640 --> 00:12:22,640
會去 jump 到我們 shellcode 上了

295
00:12:22,640 --> 00:12:23,640
所以我們就是會

296
00:12:23,640 --> 00:12:25,640
jump 到我們 shellcode 上

297
00:12:25,640 --> 00:12:26,640
好 那我們 shellcode

298
00:12:26,640 --> 00:12:28,640
做了些什麼事情呢

299
00:12:28,640 --> 00:12:29,640
那我們 shellcode

300
00:12:29,640 --> 00:12:31,640
首先我們會先去檢查

301
00:12:31,640 --> 00:12:32,640
當下的 register

302
00:12:32,640 --> 00:12:33,640
就是我們會把

303
00:12:33,640 --> 00:12:35,640
我們會先把當下的 register 存下來

304
00:12:35,640 --> 00:12:37,640
然後拿到當下的 RIP

305
00:12:37,640 --> 00:12:38,640
然後我們會去檢查

306
00:12:38,640 --> 00:12:40,640
PID 是不是 init process

307
00:12:40,640 --> 00:12:42,640
那如果不是 init process 的話

308
00:12:42,640 --> 00:12:43,640
我們就直接透過 jump 的方式

309
00:12:43,640 --> 00:12:44,640
直接 return 回去

310
00:12:44,640 --> 00:12:45,640
它原本要去的那個

311
00:12:45,640 --> 00:12:47,640
locate 的那個 function

312
00:12:47,640 --> 00:12:48,640
那如果是 init process 的話

313
00:12:48,640 --> 00:12:50,640
就是我們要劫持的目標的話

314
00:12:50,640 --> 00:12:51,640
我們就直接 fork 出來

315
00:12:51,640 --> 00:12:53,640
那我們 fork 出一隻

316
00:12:53,640 --> 00:12:55,640
我們就把它 init fork 出來

317
00:12:55,640 --> 00:12:57,640
那它會去 nmap

318
00:12:57,640 --> 00:12:58,640
libui.so 進來

319
00:12:58,640 --> 00:12:59,640
那為什麼會 nmap

320
00:12:59,640 --> 00:13:00,640
libui.so 進來

321
00:13:00,640 --> 00:13:02,640
libui.so 進來是因為 init process

322
00:13:02,640 --> 00:13:03,640
它沒有用到 libui.so

323
00:13:03,640 --> 00:13:05,640
那並且說我們會需要

324
00:13:05,640 --> 00:13:06,640
用到第二段的 export

325
00:13:06,640 --> 00:13:08,640
在 init 的權限下執行

326
00:13:08,640 --> 00:13:09,640
所以說我們還有再把

327
00:13:09,640 --> 00:13:10,640
第二階段的 export

328
00:13:10,640 --> 00:13:11,640
寫到 libui.so

329
00:13:11,640 --> 00:13:13,640
讓它跳過來執行

330
00:13:13,640 --> 00:13:15,640
那後面我們就直接

331
00:13:15,640 --> 00:13:17,640
jump 到 libui.so 上了嘛

332
00:13:17,640 --> 00:13:18,640
那 libui.so 執行

333
00:13:18,640 --> 00:13:19,640
我們 export2 的時候

334
00:13:19,640 --> 00:13:24,640
就是帶有 init 的權限執行的

335
00:13:24,640 --> 00:13:25,640
好那等一下

336
00:13:25,640 --> 00:13:26,640
接下來要講到 s-init 的部分

337
00:13:26,640 --> 00:13:29,640
我們再還給以莫

338
00:13:29,640 --> 00:13:30,640
那其實大家剛才聽下來

339
00:13:30,640 --> 00:13:33,640
就可以知道就是

340
00:13:33,640 --> 00:13:34,640
我們在做 export 的時候

341
00:13:34,640 --> 00:13:36,640
就是要對一些背景的知識

342
00:13:36,640 --> 00:13:37,640
要比較熟一點

343
00:13:37,640 --> 00:13:38,640
對就像是我們在去做

344
00:13:38,640 --> 00:13:40,640
Linux 上的題權部分

345
00:13:40,640 --> 00:13:41,640
那我們就是要對

346
00:13:41,640 --> 00:13:42,640
Linux 上像是一些

347
00:13:42,640 --> 00:13:44,640
system code 之類的

348
00:13:44,640 --> 00:13:45,640
那要夠熟

349
00:13:45,640 --> 00:13:46,640
才可以就是可以比較

350
00:13:46,640 --> 00:13:49,640
了解我們剛才在講什麼這樣

351
00:13:49,640 --> 00:13:50,640
那因為接下來我們要繼續

352
00:13:50,640 --> 00:13:52,640
對 s-init 去進行 export

353
00:13:52,640 --> 00:13:53,640
所以接下來要先

354
00:13:53,640 --> 00:13:54,640
就帶大家認識一下

355
00:13:54,640 --> 00:13:55,640
s-init 的部分

356
00:13:55,640 --> 00:13:58,640
就希望大家撐住

357
00:13:58,640 --> 00:13:59,640
那 s-init 的話

358
00:13:59,640 --> 00:14:01,640
它其實是一個就是一個

359
00:14:01,640 --> 00:14:03,640
去做權限管控的一個方法

360
00:14:03,640 --> 00:14:04,640
然後它的做法是

361
00:14:04,640 --> 00:14:06,640
以白名單的方式去做

362
00:14:06,640 --> 00:14:07,640
就像是你可以去看到

363
00:14:07,640 --> 00:14:10,640
你在一個 Linux 系統上

364
00:14:10,640 --> 00:14:12,640
Linux 系統上就是會有

365
00:14:12,640 --> 00:14:14,640
你的答案會有一些

366
00:14:14,640 --> 00:14:15,640
可以去表示它

367
00:14:15,640 --> 00:14:17,640
就是你的 group user

368
00:14:17,640 --> 00:14:18,640
可以有 open rewrite

369
00:14:18,640 --> 00:14:19,640
哪一些權限

370
00:14:19,640 --> 00:14:20,640
應該是 rxw

371
00:14:20,640 --> 00:14:21,640
rwx 的權限

372
00:14:21,640 --> 00:14:23,640
對就像那個機制一樣

373
00:14:23,640 --> 00:14:24,640
它就是一個去

374
00:14:24,640 --> 00:14:25,640
管理答案權限

375
00:14:25,640 --> 00:14:26,640
可不可以去就是

376
00:14:26,640 --> 00:14:28,640
SS 的一個機制

377
00:14:28,640 --> 00:14:29,640
那它的做法

378
00:14:29,640 --> 00:14:31,640
因為它是要用白名單

379
00:14:31,640 --> 00:14:33,640
所以就是我們會要去設定

380
00:14:33,640 --> 00:14:35,640
非常非常多的白名單的

381
00:14:35,640 --> 00:14:36,640
Lore 來去限制說

382
00:14:36,640 --> 00:14:37,640
我這個系統上

383
00:14:37,640 --> 00:14:38,640
到底有哪些的

384
00:14:38,640 --> 00:14:39,640
就是權限

385
00:14:39,640 --> 00:14:40,640
就是哪些 process

386
00:14:40,640 --> 00:14:41,640
可以對哪些 file

387
00:14:41,640 --> 00:14:42,640
去進行 open rew

388
00:14:42,640 --> 00:14:44,640
就是 rwx 的部分

389
00:14:44,640 --> 00:14:46,640
那並且因為它白名單

390
00:14:46,640 --> 00:14:48,640
所以就一定要有一個 context

391
00:14:48,640 --> 00:14:49,640
就是一個名文來表示說

392
00:14:49,640 --> 00:14:51,640
就是有沒有一個

393
00:14:51,640 --> 00:14:53,640
就是有沒有一個權限存在了

394
00:14:53,640 --> 00:14:55,640
不然就是一律都是

395
00:14:55,640 --> 00:14:57,640
你不代表你沒有權限

396
00:14:57,640 --> 00:14:58,640
那就像是

397
00:14:58,640 --> 00:14:59,640
我們剛才提到的就是

398
00:14:59,640 --> 00:15:00,640
我們會要去 hydrate

399
00:15:00,640 --> 00:15:01,640
init 這個 process

400
00:15:01,640 --> 00:15:02,640
那 init 這個 process 的話

401
00:15:02,640 --> 00:15:03,640
它就是會

402
00:15:03,640 --> 00:15:04,640
可以對 system file

403
00:15:04,640 --> 00:15:06,640
帶有這個

404
00:15:06,640 --> 00:15:08,640
就是我們叫 context

405
00:15:08,640 --> 00:15:09,640
就是帶有這個

406
00:15:09,640 --> 00:15:10,640
屬性的一個

407
00:15:10,640 --> 00:15:11,640
label 的一個檔案

408
00:15:11,640 --> 00:15:13,640
它有 open rew 的一個權限

409
00:15:13,640 --> 00:15:14,640
對

410
00:15:14,640 --> 00:15:15,640
那它就只有 open rew

411
00:15:15,640 --> 00:15:16,640
這樣的權限

412
00:15:16,640 --> 00:15:17,640
那你可能想要去

413
00:15:17,640 --> 00:15:18,640
對它做 execute

414
00:15:18,640 --> 00:15:19,640
那就它沒有權限

415
00:15:19,640 --> 00:15:20,640
那它就會去

416
00:15:20,640 --> 00:15:21,640
表示說你沒有權限

417
00:15:21,640 --> 00:15:23,640
然後你就沒辦法做這樣

418
00:15:23,640 --> 00:15:24,640
對

419
00:15:24,640 --> 00:15:25,640
那除此之外就是

420
00:15:25,640 --> 00:15:26,640
我們會有一個

421
00:15:26,640 --> 00:15:27,640
就可能後續會一直聽到

422
00:15:27,640 --> 00:15:28,640
一個名詞叫 policy

423
00:15:28,640 --> 00:15:29,640
但是 policy 的話

424
00:15:29,640 --> 00:15:30,640
其實就是

425
00:15:30,640 --> 00:15:31,640
我這個系統上

426
00:15:31,640 --> 00:15:32,640
所有的 rule 就是說

427
00:15:32,640 --> 00:15:33,640
規則的集合

428
00:15:33,640 --> 00:15:34,640
也就是我這個系統上

429
00:15:34,640 --> 00:15:35,640
就所有的權限

430
00:15:35,640 --> 00:15:36,640
到底有哪些的意思

431
00:15:36,640 --> 00:15:37,640
對

432
00:15:37,640 --> 00:15:38,640
好 還有一條

433
00:15:38,640 --> 00:15:39,640
就是比較特別的 rule

434
00:15:39,640 --> 00:15:40,640
叫做 transition

435
00:15:40,640 --> 00:15:41,640
那這條 rule 的話

436
00:15:41,640 --> 00:15:42,640
其實它的作用是這樣的

437
00:15:42,640 --> 00:15:44,640
就是在通常情況下

438
00:15:44,640 --> 00:15:45,640
我們有一個 process

439
00:15:45,640 --> 00:15:46,640
它可以去對

440
00:15:46,640 --> 00:15:47,640
某些特定的 context

441
00:15:47,640 --> 00:15:48,640
去做一些

442
00:15:48,640 --> 00:15:49,640
它有的操作

443
00:15:49,640 --> 00:15:50,640
但我要去改變

444
00:15:50,640 --> 00:15:51,640
我當前 process 的權限

445
00:15:51,640 --> 00:15:52,640
要怎麼辦

446
00:15:52,640 --> 00:15:53,640
那這樣的做法

447
00:15:53,640 --> 00:15:55,640
它在 ACNAS 的做法是這樣

448
00:15:55,640 --> 00:15:56,640
就是當我的

449
00:15:56,640 --> 00:15:58,640
當前權限去

450
00:15:58,640 --> 00:15:59,640
一插 ACB

451
00:15:59,640 --> 00:16:00,640
另外一個

452
00:16:00,640 --> 00:16:02,640
在我另外一個 context 的答案的時候

453
00:16:02,640 --> 00:16:04,640
如果有一條 transition rule 的話

454
00:16:04,640 --> 00:16:05,640
那我就會轉換到

455
00:16:05,640 --> 00:16:06,640
就是那個

456
00:16:06,640 --> 00:16:09,640
那條 rule 所指定的 context

457
00:16:09,640 --> 00:16:11,640
就是所指定的那個權限

458
00:16:11,640 --> 00:16:12,640
那我就會換到

459
00:16:12,640 --> 00:16:13,640
另外一個權限

460
00:16:13,640 --> 00:16:14,640
去執行我接下來

461
00:16:14,640 --> 00:16:15,640
一插 ACB 的那個答案

462
00:16:15,640 --> 00:16:16,640
對

463
00:16:16,640 --> 00:16:17,640
那這樣我就可以做到

464
00:16:17,640 --> 00:16:18,640
一個權限答案的部分

465
00:16:18,640 --> 00:16:19,640
改變我當前權限的

466
00:16:19,640 --> 00:16:20,640
一個部分

467
00:16:20,640 --> 00:16:23,640
那 ACNAS 當然就是

468
00:16:23,640 --> 00:16:24,640
稍微講一下

469
00:16:24,640 --> 00:16:25,640
它的一些優缺點的部分

470
00:16:25,640 --> 00:16:26,640
那它優點的話其實就是

471
00:16:26,640 --> 00:16:28,640
它可以做到非常精確的

472
00:16:28,640 --> 00:16:29,640
一個權限管控

473
00:16:29,640 --> 00:16:30,640
就我每一個

474
00:16:30,640 --> 00:16:31,640
你要做什麼操作

475
00:16:31,640 --> 00:16:32,640
都要有一條 rule 去表示

476
00:16:32,640 --> 00:16:33,640
你可以做你想做

477
00:16:33,640 --> 00:16:34,640
這就非常一個

478
00:16:34,640 --> 00:16:36,640
強烈的一個權限管控部分

479
00:16:36,640 --> 00:16:37,640
那如果它就是會解決一個

480
00:16:37,640 --> 00:16:39,640
ACNAS 上一個很大問題

481
00:16:39,640 --> 00:16:40,640
就是我們前天提到

482
00:16:40,640 --> 00:16:41,640
root 超強

483
00:16:41,640 --> 00:16:42,640
對

484
00:16:42,640 --> 00:16:43,640
那這邊就可以解決說

485
00:16:43,640 --> 00:16:44,640
就是因為它把權限

486
00:16:44,640 --> 00:16:46,640
分成了很多條 rule 來去管理

487
00:16:46,640 --> 00:16:48,640
所以那個 root 的部分

488
00:16:48,640 --> 00:16:49,640
就沒有那麼強的權限

489
00:16:49,640 --> 00:16:50,640
我怎麼都可以做

490
00:16:50,640 --> 00:16:51,640
對

491
00:16:51,640 --> 00:16:52,640
那缺點的部分

492
00:16:52,640 --> 00:16:53,640
第一個的話就是

493
00:16:53,640 --> 00:16:54,640
它的 rule 很難設定

494
00:16:54,640 --> 00:16:55,640
就是因為說

495
00:16:55,640 --> 00:16:56,640
要設定 rule 超級多

496
00:16:56,640 --> 00:16:57,640
對

497
00:16:57,640 --> 00:16:58,640
另外一個部分的話就是

498
00:16:58,640 --> 00:17:00,640
你在之後

499
00:17:00,640 --> 00:17:02,640
如果你拿到一台機器

500
00:17:02,640 --> 00:17:03,640
那機器上有 ACNAS

501
00:17:03,640 --> 00:17:05,640
然後你想要去做

502
00:17:05,640 --> 00:17:06,640
輸出 apt install

503
00:17:06,640 --> 00:17:07,640
然後你就會發現它爛掉了

504
00:17:07,640 --> 00:17:08,640
對

505
00:17:08,640 --> 00:17:09,640
因為你的輸出

506
00:17:09,640 --> 00:17:10,640
就不像之前那麼強了

507
00:17:10,640 --> 00:17:11,640
沒有錯

508
00:17:11,640 --> 00:17:12,640
就會有這樣的一個問題

509
00:17:12,640 --> 00:17:14,640
那對於這個機制的話

510
00:17:14,640 --> 00:17:16,640
其實 ACNAS 有其中兩個機制

511
00:17:16,640 --> 00:17:17,640
來去做解決

512
00:17:17,640 --> 00:17:18,640
第一個的話是

513
00:17:18,640 --> 00:17:19,640
enforce permissive

514
00:17:19,640 --> 00:17:20,640
另外一個的話是

515
00:17:20,640 --> 00:17:21,640
permissive domain

516
00:17:21,640 --> 00:17:22,640
那 enforce permissive 的部分就是

517
00:17:22,640 --> 00:17:25,640
我可以將我當前 ACNAS 的狀態

518
00:17:25,640 --> 00:17:26,640
設定成 permissive

519
00:17:26,640 --> 00:17:27,640
那這意思就是

520
00:17:27,640 --> 00:17:30,640
接下來你要做操作

521
00:17:30,640 --> 00:17:31,640
ACNAS 都不會阻擋你

522
00:17:31,640 --> 00:17:32,640
但我會留下 log

523
00:17:32,640 --> 00:17:34,640
也就是你的這個系統上

524
00:17:34,640 --> 00:17:35,640
就只是多了一層

525
00:17:35,640 --> 00:17:37,640
會幫你 log 的一個 ACNAS

526
00:17:37,640 --> 00:17:39,640
但剩下的情況就是跟

527
00:17:39,640 --> 00:17:40,640
沒有 ACNAS 的情況

528
00:17:40,640 --> 00:17:41,640
是一模一樣的

529
00:17:41,640 --> 00:17:42,640
對

530
00:17:42,640 --> 00:17:44,640
那就通常在 Red Hat 的

531
00:17:44,640 --> 00:17:45,640
換機是 6.0 的

532
00:17:45,640 --> 00:17:47,640
某一個教科書

533
00:17:47,640 --> 00:17:48,640
它的第一頁就是表示

534
00:17:48,640 --> 00:17:50,640
請關掉你的 ACNAS

535
00:17:50,640 --> 00:17:51,640
把它設成 permissive

536
00:17:51,640 --> 00:17:52,640
對

537
00:17:52,640 --> 00:17:53,640
所以就

538
00:17:53,640 --> 00:17:54,640
就還

539
00:17:54,640 --> 00:17:56,640
而且 Red Hat 是

540
00:17:56,640 --> 00:17:57,640
ACNAS 的

541
00:17:57,640 --> 00:17:59,640
就是管理的公司

542
00:17:59,640 --> 00:18:00,640
對

543
00:18:00,640 --> 00:18:01,640
所以就還

544
00:18:01,640 --> 00:18:02,640
還蠻有趣的這樣

545
00:18:02,640 --> 00:18:03,640
然後另外一個的話

546
00:18:03,640 --> 00:18:04,640
就是有一個特別的入口

547
00:18:04,640 --> 00:18:05,640
叫 permissive domain

548
00:18:05,640 --> 00:18:07,640
那它其實就是一個權限

549
00:18:07,640 --> 00:18:09,640
表示一個特別的權限

550
00:18:09,640 --> 00:18:11,640
那當你切換到這個權限下

551
00:18:11,640 --> 00:18:12,640
你的行為就跟

552
00:18:12,640 --> 00:18:14,640
enforce 設成 permissive 是一樣的

553
00:18:14,640 --> 00:18:15,640
就是只會有 log

554
00:18:15,640 --> 00:18:17,640
但是什麼操作都還是讓你過

555
00:18:17,640 --> 00:18:18,640
沒錯

556
00:18:18,640 --> 00:18:19,640
所以這邊就可以看到

557
00:18:19,640 --> 00:18:20,640
set enforced

558
00:18:20,640 --> 00:18:21,640
就是我把那個 enforce

559
00:18:21,640 --> 00:18:22,640
設成 permissive 的意思

560
00:18:22,640 --> 00:18:23,640
對

561
00:18:23,640 --> 00:18:24,640
就大家都

562
00:18:24,640 --> 00:18:25,640
開機先看看就對了

563
00:18:25,640 --> 00:18:26,640
好

564
00:18:26,640 --> 00:18:27,640
但因為我們在 Android 上面

565
00:18:27,640 --> 00:18:29,640
它的那個 ACNAS 是沒辦法 set

566
00:18:29,640 --> 00:18:30,640
就是

567
00:18:30,640 --> 00:18:31,640
就是一定是打開的

568
00:18:31,640 --> 00:18:33,640
所以我還是要想辦法去

569
00:18:33,640 --> 00:18:34,640
bypass 它

570
00:18:34,640 --> 00:18:35,640
那我就接著來看一下

571
00:18:35,640 --> 00:18:37,640
它在 kernel 中的一些運作流程

572
00:18:37,640 --> 00:18:38,640
會是長這樣

573
00:18:38,640 --> 00:18:39,640
對

574
00:18:39,640 --> 00:18:40,640
那首先的話就是

575
00:18:40,640 --> 00:18:41,640
當你去做一些

576
00:18:41,640 --> 00:18:42,640
system code

577
00:18:42,640 --> 00:18:43,640
就是前面提到的

578
00:18:43,640 --> 00:18:44,640
這些 system code 的時候

579
00:18:44,640 --> 00:18:45,640
它其實會 call 到一個

580
00:18:45,640 --> 00:18:47,640
叫 LSM hook 的一個 function

581
00:18:47,640 --> 00:18:48,640
而這個 function

582
00:18:48,640 --> 00:18:49,640
它在第一層

583
00:18:49,640 --> 00:18:50,640
就在 ACNAS 這個環境下

584
00:18:50,640 --> 00:18:51,640
它就是對

585
00:18:51,640 --> 00:18:52,640
它就會去

586
00:18:52,640 --> 00:18:53,640
hook 到就是

587
00:18:53,640 --> 00:18:54,640
ACNAS 的 function

588
00:18:54,640 --> 00:18:55,640
那第一層的

589
00:18:55,640 --> 00:18:57,640
這 ACNAS 的 function 呢

590
00:18:57,640 --> 00:18:58,640
就會去做的事情

591
00:18:58,640 --> 00:18:59,640
就是去收集一些

592
00:18:59,640 --> 00:19:00,640
我的一些

593
00:19:00,640 --> 00:19:01,640
所需要的一些資訊

594
00:19:01,640 --> 00:19:02,640
像是就是

595
00:19:02,640 --> 00:19:03,640
這邊提到

596
00:19:03,640 --> 00:19:04,640
SSID TSID

597
00:19:04,640 --> 00:19:05,640
class unpermitted

598
00:19:05,640 --> 00:19:06,640
還有 requested 的部分

599
00:19:06,640 --> 00:19:08,640
那這幾個東西其實就是

600
00:19:08,640 --> 00:19:09,640
SSID 就是

601
00:19:09,640 --> 00:19:12,640
我現在這個 process 的權限

602
00:19:12,640 --> 00:19:13,640
TSID 就是我

603
00:19:13,640 --> 00:19:14,640
這 process 要對

604
00:19:14,640 --> 00:19:15,640
哪一個檔案執行的

605
00:19:15,640 --> 00:19:16,640
就是那個檔案的權限

606
00:19:16,640 --> 00:19:17,640
是哪一個

607
00:19:17,640 --> 00:19:18,640
那接著

608
00:19:18,640 --> 00:19:19,640
好 接著的話就會去看

609
00:19:19,640 --> 00:19:20,640
我需要哪些權限

610
00:19:20,640 --> 00:19:21,640
就 requested

611
00:19:21,640 --> 00:19:22,640
就是我會需要

612
00:19:22,640 --> 00:19:23,640
哪些權限的意思

613
00:19:23,640 --> 00:19:24,640
對 就是剛才提到

614
00:19:24,640 --> 00:19:25,640
open rewrite 這三個權限

615
00:19:25,640 --> 00:19:26,640
對

616
00:19:26,640 --> 00:19:27,640
那就會把這些資訊

617
00:19:27,640 --> 00:19:28,640
就傳給到就是

618
00:19:28,640 --> 00:19:30,640
叫 AVC has no audit

619
00:19:30,640 --> 00:19:31,640
的

620
00:19:31,640 --> 00:19:33,640
AVC has no audit

621
00:19:33,640 --> 00:19:34,640
不好意思口誤

622
00:19:34,640 --> 00:19:35,640
對 這個 function

623
00:19:35,640 --> 00:19:36,640
那這 function 會做的事情

624
00:19:36,640 --> 00:19:37,640
就是實際的去

625
00:19:37,640 --> 00:19:38,640
去看說你有沒有權限的部分

626
00:19:38,640 --> 00:19:39,640
首先的話

627
00:19:39,640 --> 00:19:40,640
它就會先去做

628
00:19:40,640 --> 00:19:41,640
AVC lookup

629
00:19:41,640 --> 00:19:42,640
就去一個 cache 的空間

630
00:19:42,640 --> 00:19:43,640
去看說

631
00:19:43,640 --> 00:19:44,640
我這個判斷的情況

632
00:19:44,640 --> 00:19:45,640
有沒有

633
00:19:45,640 --> 00:19:46,640
之前有沒有提過

634
00:19:46,640 --> 00:19:47,640
如果

635
00:19:47,640 --> 00:19:48,640
如果之前有找過的話

636
00:19:48,640 --> 00:19:49,640
它就會留下一個 cache

637
00:19:49,640 --> 00:19:50,640
在這邊

638
00:19:50,640 --> 00:19:51,640
來去知道就是

639
00:19:51,640 --> 00:19:52,640
你這個操作到

640
00:19:52,640 --> 00:19:53,640
有哪些權限

641
00:19:53,640 --> 00:19:54,640
如果沒有找過的話

642
00:19:54,640 --> 00:19:55,640
它就會再去 call 到

643
00:19:55,640 --> 00:19:56,640
security compute AV

644
00:19:56,640 --> 00:19:57,640
這個 function

645
00:19:57,640 --> 00:19:58,640
這個 function

646
00:19:58,640 --> 00:19:59,640
做的事情就是去

647
00:19:59,640 --> 00:20:00,640
policy 那邊

648
00:20:00,640 --> 00:20:01,640
去把我這個

649
00:20:01,640 --> 00:20:02,640
當前這個執行

650
00:20:02,640 --> 00:20:03,640
TSID 對應到

651
00:20:03,640 --> 00:20:04,640
SSID 對應到

652
00:20:04,640 --> 00:20:05,640
TSID 的這個操作

653
00:20:05,640 --> 00:20:07,640
所用的權限都找出來

654
00:20:07,640 --> 00:20:08,640
那到時候

655
00:20:08,640 --> 00:20:09,640
我就去用這個權限

656
00:20:09,640 --> 00:20:10,640
來去跟

657
00:20:10,640 --> 00:20:11,640
就是

658
00:20:11,640 --> 00:20:12,640
我這邊

659
00:20:12,640 --> 00:20:13,640
所需要 requested 的

660
00:20:13,640 --> 00:20:14,640
來去做比較

661
00:20:14,640 --> 00:20:15,640
如果 requested

662
00:20:15,640 --> 00:20:16,640
需要超過這個權

663
00:20:16,640 --> 00:20:17,640
就是

664
00:20:17,640 --> 00:20:18,640
如果 requested

665
00:20:18,640 --> 00:20:19,640
需要超過我

666
00:20:19,640 --> 00:20:20,640
所能夠擁有的權限的話

667
00:20:20,640 --> 00:20:21,640
它就會去 call 到

668
00:20:21,640 --> 00:20:23,640
AVC deny 的

669
00:20:23,640 --> 00:20:24,640
將你的這個操作

670
00:20:24,640 --> 00:20:25,640
給否決掉

671
00:20:25,640 --> 00:20:26,640
對

672
00:20:26,640 --> 00:20:28,640
那 AVC deny 的

673
00:20:28,640 --> 00:20:29,640
對

674
00:20:29,640 --> 00:20:30,640
不好意思

675
00:20:30,640 --> 00:20:31,640
這邊要再講一下

676
00:20:31,640 --> 00:20:32,640
就是前面提到

677
00:20:32,640 --> 00:20:33,640
就是這個

678
00:20:33,640 --> 00:20:34,640
security compute AV

679
00:20:34,640 --> 00:20:35,640
它會做

680
00:20:35,640 --> 00:20:36,640
它會前面會 call 到一個

681
00:20:36,640 --> 00:20:37,640
叫 EVMARGabit

682
00:20:37,640 --> 00:20:38,640
這個 function

683
00:20:38,640 --> 00:20:39,640
這個 function 就會是

684
00:20:39,640 --> 00:20:40,640
等等我們

685
00:20:40,640 --> 00:20:41,640
就是要做 bypass 的部分

686
00:20:41,640 --> 00:20:42,640
要會用到一個 function

687
00:20:42,640 --> 00:20:43,640
那接著我們回來講一下

688
00:20:43,640 --> 00:20:44,640
AVC deny

689
00:20:44,640 --> 00:20:45,640
那 AVC deny

690
00:20:45,640 --> 00:20:46,640
它做的事情其實很簡單

691
00:20:46,640 --> 00:20:48,640
如果你有寫過 C code 的話

692
00:20:48,640 --> 00:20:49,640
就會知道就是

693
00:20:49,640 --> 00:20:51,640
它可能會有一些 error

694
00:20:51,640 --> 00:20:52,640
就是

695
00:20:52,640 --> 00:20:54,640
大家應該知道 error

696
00:20:54,640 --> 00:20:55,640
error number 這東西

697
00:20:55,640 --> 00:20:56,640
對

698
00:20:56,640 --> 00:20:57,640
那它在 AVC deny

699
00:20:57,640 --> 00:20:58,640
在做的事情就是

700
00:20:58,640 --> 00:20:59,640
return 一個 error number

701
00:20:59,640 --> 00:21:00,640
表示你沒有權限這樣

702
00:21:00,640 --> 00:21:01,640
對

703
00:21:01,640 --> 00:21:02,640
但它有兩個情況

704
00:21:02,640 --> 00:21:03,640
就是

705
00:21:03,640 --> 00:21:04,640
會是 returning

706
00:21:04,640 --> 00:21:05,640
也就是代表著

707
00:21:05,640 --> 00:21:06,640
因為通常 returning 就代表

708
00:21:06,640 --> 00:21:07,640
這操作成功了

709
00:21:07,640 --> 00:21:08,640
你有權限這樣

710
00:21:08,640 --> 00:21:09,640
對

711
00:21:09,640 --> 00:21:10,640
它有兩個情況是 returning 的

712
00:21:10,640 --> 00:21:11,640
第二的話就是

713
00:21:11,640 --> 00:21:12,640
它會去

714
00:21:12,640 --> 00:21:13,640
但你

715
00:21:13,640 --> 00:21:14,640
它會去判斷說

716
00:21:14,640 --> 00:21:15,640
enforce

717
00:21:15,640 --> 00:21:16,640
enable return false 的情況

718
00:21:16,640 --> 00:21:17,640
它會 returning

719
00:21:17,640 --> 00:21:18,640
那這情況其實就是

720
00:21:18,640 --> 00:21:20,640
對應到我們前面提到的

721
00:21:20,640 --> 00:21:22,640
enforce permissive 的這個情況

722
00:21:22,640 --> 00:21:23,640
對

723
00:21:23,640 --> 00:21:24,640
但它會需要就是

724
00:21:24,640 --> 00:21:25,640
在去編譯 gernode 的時候

725
00:21:25,640 --> 00:21:27,640
會需要帶一個 config 在裡面

726
00:21:27,640 --> 00:21:29,640
它這個情況才有可能會是 true

727
00:21:29,640 --> 00:21:30,640
那另外一個情況的話就是

728
00:21:30,640 --> 00:21:32,640
我 afd flag 帶有

729
00:21:32,640 --> 00:21:34,640
就是

730
00:21:34,640 --> 00:21:35,640
no

731
00:21:35,640 --> 00:21:36,640
對

732
00:21:36,640 --> 00:21:37,640
稍微看一下

733
00:21:37,640 --> 00:21:38,640
afd flag permissive

734
00:21:38,640 --> 00:21:39,640
這個 flag

735
00:21:39,640 --> 00:21:40,640
對

736
00:21:40,640 --> 00:21:41,640
那這個 flag 的話就是會對應到

737
00:21:41,640 --> 00:21:42,640
permissive domain 這個情況

738
00:21:42,640 --> 00:21:43,640
也就是

739
00:21:43,640 --> 00:21:45,640
你的當前的就是

740
00:21:45,640 --> 00:21:47,640
權限是 permissive

741
00:21:47,640 --> 00:21:48,640
對

742
00:21:48,640 --> 00:21:49,640
那這個的

743
00:21:49,640 --> 00:21:50,640
這個情況就是

744
00:21:50,640 --> 00:21:51,640
我的這個 flag 要帶有

745
00:21:51,640 --> 00:21:52,640
我的 afd 要帶有 flag 的話

746
00:21:52,640 --> 00:21:53,640
就是要在

747
00:21:53,640 --> 00:21:55,640
一邊要給 return

748
00:21:55,640 --> 00:21:56,640
true 的時候

749
00:21:56,640 --> 00:21:57,640
它才會帶起來

750
00:21:57,640 --> 00:21:58,640
對

751
00:21:58,640 --> 00:21:59,640
那我們接下來就會去想著

752
00:21:59,640 --> 00:22:00,640
試著說

753
00:22:00,640 --> 00:22:02,640
就是看能不能用這條路來去

754
00:22:02,640 --> 00:22:03,640
bypass 掉我 asyns

755
00:22:03,640 --> 00:22:05,640
也就讓我的當前的權限是 permissive

756
00:22:06,640 --> 00:22:07,640
那我們要去繞過

757
00:22:07,640 --> 00:22:09,640
這個 asyns 的方法就

758
00:22:09,640 --> 00:22:10,640
換我們就換個思路

759
00:22:10,640 --> 00:22:11,640
它是 evmark a bit

760
00:22:11,640 --> 00:22:14,640
會去將這個 flag 給設起來

761
00:22:14,640 --> 00:22:15,640
那我們的做法很簡單

762
00:22:15,640 --> 00:22:16,640
我們就改

763
00:22:16,640 --> 00:22:17,640
call evmark c bit

764
00:22:17,640 --> 00:22:19,640
把這個 flag 給設起來

765
00:22:19,640 --> 00:22:20,640
那我們不就

766
00:22:20,640 --> 00:22:21,640
等於我們把 permissive domain

767
00:22:21,640 --> 00:22:22,640
給設起來

768
00:22:22,640 --> 00:22:23,640
那我們就可以 bypass 掉

769
00:22:23,640 --> 00:22:24,640
asyns 的話

770
00:22:24,640 --> 00:22:25,640
對

771
00:22:25,640 --> 00:22:26,640
那

772
00:22:26,640 --> 00:22:28,640
接著我們要做的事情就是

773
00:22:28,640 --> 00:22:29,640
想辦法去 call 到

774
00:22:29,640 --> 00:22:30,640
evmark c bit 這個 function

775
00:22:30,640 --> 00:22:31,640
但因為這個 function 在 kernel 裡面

776
00:22:31,640 --> 00:22:32,640
所以我們可能會要去

777
00:22:32,640 --> 00:22:34,640
做一些其他事情來去

778
00:22:34,640 --> 00:22:36,640
call 到這個 kernel 的 function

779
00:22:36,640 --> 00:22:37,640
沒有錯

780
00:22:37,640 --> 00:22:38,640
那首先的話

781
00:22:38,640 --> 00:22:39,640
我們先回來看一下

782
00:22:39,640 --> 00:22:40,640
就是 init 的

783
00:22:40,640 --> 00:22:42,640
一個權限的部分

784
00:22:42,640 --> 00:22:43,640
對

785
00:22:43,640 --> 00:22:44,640
那

786
00:22:44,640 --> 00:22:45,640
init 的話就是

787
00:22:45,640 --> 00:22:46,640
它會有帶有幾條

788
00:22:46,640 --> 00:22:47,640
比較特別的路

789
00:22:47,640 --> 00:22:48,640
那這邊路的意思

790
00:22:48,640 --> 00:22:49,640
其實是這樣的

791
00:22:49,640 --> 00:22:50,640
就是說

792
00:22:50,640 --> 00:22:51,640
首先的話我 init

793
00:22:51,640 --> 00:22:52,640
它會 transition

794
00:22:52,640 --> 00:22:53,640
就是我改變權限到

795
00:22:53,640 --> 00:22:55,640
random prop 的這個權限

796
00:22:55,640 --> 00:22:56,640
而 random prop

797
00:22:56,640 --> 00:22:57,640
它可以去做

798
00:22:57,640 --> 00:22:58,640
low kernel module

799
00:22:58,640 --> 00:22:59,640
這個權限

800
00:22:59,640 --> 00:23:00,640
所以代表著

801
00:23:00,640 --> 00:23:01,640
我 init 可以去做

802
00:23:01,640 --> 00:23:03,640
到 low kernel module 的意思

803
00:23:03,640 --> 00:23:04,640
對

804
00:23:04,640 --> 00:23:05,640
所以這就是為什麼

805
00:23:05,640 --> 00:23:06,640
當初要去

806
00:23:06,640 --> 00:23:07,640
hijack init 的原因

807
00:23:07,640 --> 00:23:08,640
對

808
00:23:08,640 --> 00:23:09,640
那接著

809
00:23:09,640 --> 00:23:10,640
另外我們這邊

810
00:23:10,640 --> 00:23:11,640
其實稍微有點破梗了

811
00:23:11,640 --> 00:23:12,640
就是我們這邊

812
00:23:12,640 --> 00:23:13,640
會要有 low kernel module

813
00:23:13,640 --> 00:23:14,640
的權限

814
00:23:14,640 --> 00:23:15,640
那這就是為什麼

815
00:23:15,640 --> 00:23:16,640
那這就是我們可以做到去

816
00:23:16,640 --> 00:23:18,640
call 到 kernel 中 function 的方法

817
00:23:18,640 --> 00:23:20,640
也就是我們使用 kernel module

818
00:23:20,640 --> 00:23:21,640
對

819
00:23:21,640 --> 00:23:22,640
那我這個 kernel module

820
00:23:22,640 --> 00:23:23,640
它要去

821
00:23:24,640 --> 00:23:25,640
它要怎麼去

822
00:23:25,640 --> 00:23:26,640
讓它去

823
00:23:26,640 --> 00:23:27,640
就是

824
00:23:28,640 --> 00:23:29,640
對

825
00:23:29,640 --> 00:23:30,640
就是要怎麼去

826
00:23:30,640 --> 00:23:31,640
因為我們其實

827
00:23:31,640 --> 00:23:32,640
我們其實

828
00:23:32,640 --> 00:23:33,640
今天預期是這樣

829
00:23:33,640 --> 00:23:34,640
就是我已經編出一個

830
00:23:34,640 --> 00:23:35,640
kernel module 了

831
00:23:35,640 --> 00:23:36,640
而這個 kernel module

832
00:23:36,640 --> 00:23:37,640
可以做到的事情

833
00:23:37,640 --> 00:23:38,640
就是去做到

834
00:23:38,640 --> 00:23:39,640
那怎麼做的

835
00:23:39,640 --> 00:23:40,640
就大家可以

836
00:23:40,640 --> 00:23:41,640
事後再問我這樣

837
00:23:41,640 --> 00:23:42,640
對

838
00:23:42,640 --> 00:23:43,640
那我今天要做的事情

839
00:23:43,640 --> 00:23:44,640
就是如何把這個 kernel module

840
00:23:44,640 --> 00:23:45,640
可以載入到

841
00:23:45,640 --> 00:23:46,640
那個 linux 的系統裡面

842
00:23:46,640 --> 00:23:47,640
那這邊做法

843
00:23:47,640 --> 00:23:48,640
其實是這樣

844
00:23:48,640 --> 00:23:49,640
就是

845
00:23:49,640 --> 00:23:50,640
我們先

846
00:23:50,640 --> 00:23:51,640
首先的話就是

847
00:23:51,640 --> 00:23:52,640
我們要先去找

848
00:23:52,640 --> 00:23:53,640
就是帶有

849
00:23:53,640 --> 00:23:54,640
vendor toolbars

850
00:23:54,640 --> 00:23:55,640
hiec

851
00:23:55,640 --> 00:23:56,640
這個 context 的一個檔案

852
00:23:56,640 --> 00:23:57,640
也就是剛才提到

853
00:23:57,640 --> 00:23:58,640
我們可以去

854
00:23:58,640 --> 00:23:59,640
轉換權限的那個

855
00:23:59,640 --> 00:24:00,640
所需要的那個

856
00:24:00,640 --> 00:24:01,640
elf binary

857
00:24:01,640 --> 00:24:02,640
然後再去找它

858
00:24:02,640 --> 00:24:03,640
就可以看到就是

859
00:24:03,640 --> 00:24:04,640
vendor toolbars

860
00:24:04,640 --> 00:24:05,640
是帶有這個

861
00:24:05,640 --> 00:24:06,640
這個權限的

862
00:24:06,640 --> 00:24:07,640
對

863
00:24:07,640 --> 00:24:08,640
那接著我們要再去找到

864
00:24:08,640 --> 00:24:09,640
就是

865
00:24:09,640 --> 00:24:10,640
可以被當成

866
00:24:10,640 --> 00:24:11,640
可以去被當成

867
00:24:11,640 --> 00:24:12,640
kernel module

868
00:24:12,640 --> 00:24:13,640
loading system 裡面的

869
00:24:13,640 --> 00:24:14,640
一個檔案

870
00:24:14,640 --> 00:24:15,640
對

871
00:24:15,640 --> 00:24:16,640
那我們找到的話就是

872
00:24:16,640 --> 00:24:17,640
在 vendor lib

873
00:24:17,640 --> 00:24:18,640
和 vendor lib64 下的

874
00:24:18,640 --> 00:24:19,640
所有的 library

875
00:24:19,640 --> 00:24:20,640
都可以被

876
00:24:20,640 --> 00:24:21,640
當作 kernel module

877
00:24:21,640 --> 00:24:22,640
loading system 裡面

878
00:24:22,640 --> 00:24:23,640
對

879
00:24:23,640 --> 00:24:24,640
那我們這邊的

880
00:24:24,640 --> 00:24:25,640
做的海嘉的方法

881
00:24:25,640 --> 00:24:26,640
就是這樣

882
00:24:26,640 --> 00:24:27,640
首先的話就是

883
00:24:27,640 --> 00:24:28,640
因為

884
00:24:28,640 --> 00:24:29,640
這兩個 context

885
00:24:29,640 --> 00:24:30,640
帶有這兩個權限

886
00:24:30,640 --> 00:24:31,640
他們都可以被

887
00:24:31,640 --> 00:24:32,640
init 去做 open con read

888
00:24:32,640 --> 00:24:33,640
那我們就可以用

889
00:24:33,640 --> 00:24:34,640
dirty pipe 來去對

890
00:24:34,640 --> 00:24:35,640
這兩個檔案

891
00:24:35,640 --> 00:24:37,640
來去做 overwrite 部分

892
00:24:37,640 --> 00:24:38,640
雖然他們就是

893
00:24:38,640 --> 00:24:39,640
不可被寫

894
00:24:39,640 --> 00:24:40,640
但不管

895
00:24:40,640 --> 00:24:41,640
我們就要寫它

896
00:24:41,640 --> 00:24:42,640
對

897
00:24:42,640 --> 00:24:43,640
那我們就寫的

898
00:24:43,640 --> 00:24:44,640
過程是這樣的

899
00:24:44,640 --> 00:24:45,640
首先的話

900
00:24:45,640 --> 00:24:46,640
我們先將 toolbars

901
00:24:46,640 --> 00:24:47,640
這個檔案

902
00:24:47,640 --> 00:24:48,640
寫成就是去

903
00:24:48,640 --> 00:24:49,640
做 load kernel module

904
00:24:49,640 --> 00:24:50,640
對

905
00:24:50,640 --> 00:24:51,640
就是

906
00:24:51,640 --> 00:24:52,640
這個對象就是

907
00:24:52,640 --> 00:24:53,640
我們找到的

908
00:24:53,640 --> 00:24:54,640
在 vendor lib

909
00:24:54,640 --> 00:24:55,640
底下一個 library

910
00:24:55,640 --> 00:24:56,640
而

911
00:24:56,640 --> 00:24:57,640
另外的話

912
00:24:57,640 --> 00:24:58,640
我們再將這個 library

913
00:24:58,640 --> 00:24:59,640
就是把 kernel module

914
00:24:59,640 --> 00:25:00,640
寫進這個 library 裡面

915
00:25:00,640 --> 00:25:01,640
那接著我們就可以

916
00:25:01,640 --> 00:25:02,640
去自行這個

917
00:25:02,640 --> 00:25:03,640
就是

918
00:25:03,640 --> 00:25:04,640
這個 vendor toolbars 的部分

919
00:25:04,640 --> 00:25:05,640
他就會去

920
00:25:05,640 --> 00:25:06,640
把這個 library

921
00:25:06,640 --> 00:25:07,640
當作 kernel module

922
00:25:07,640 --> 00:25:08,640
給 load 進 system 裡面

923
00:25:08,640 --> 00:25:09,640
對

924
00:25:09,640 --> 00:25:10,640
那接著的話

925
00:25:10,640 --> 00:25:11,640
就可以去看到

926
00:25:11,640 --> 00:25:12,640
就是我們就可以

927
00:25:12,640 --> 00:25:13,640
這樣子成功地

928
00:25:13,640 --> 00:25:14,640
去拿到一個

929
00:25:14,640 --> 00:25:15,640
reversible shell

930
00:25:15,640 --> 00:25:16,640
對

931
00:25:16,640 --> 00:25:17,640
沒錯

932
00:25:17,640 --> 00:25:18,640
那為什麼我們可以說

933
00:25:18,640 --> 00:25:19,640
我們這是拿 reversible shell 呢

934
00:25:19,640 --> 00:25:20,640
這邊可以看到就是

935
00:25:20,640 --> 00:25:22,640
我們這邊 context 的部分

936
00:25:22,640 --> 00:25:23,640
是 vendor more prop

937
00:25:23,640 --> 00:25:24,640
就是我們已經改變好

938
00:25:24,640 --> 00:25:25,640
我們的

939
00:25:25,640 --> 00:25:26,640
暫前前線的

940
00:25:26,640 --> 00:25:27,640
另外的話

941
00:25:27,640 --> 00:25:28,640
我們可以去 ls

942
00:25:28,640 --> 00:25:29,640
這個 library

943
00:25:29,640 --> 00:25:30,640
他是要

944
00:25:30,640 --> 00:25:31,640
就是

945
00:25:31,640 --> 00:25:32,640
你必須要是在

946
00:25:32,640 --> 00:25:34,640
root 的情況下

947
00:25:34,640 --> 00:25:35,640
而且要

948
00:25:35,640 --> 00:25:36,640
bypass 掉 senus

949
00:25:36,640 --> 00:25:37,640
才有辦法去

950
00:25:37,640 --> 00:25:38,640
ls 他

951
00:25:38,640 --> 00:25:39,640
對

952
00:25:39,640 --> 00:25:40,640
這就是為什麼我們表示

953
00:25:40,640 --> 00:25:41,640
我們已經拿到

954
00:25:41,640 --> 00:25:42,640
成功拿到 reversible shell

955
00:25:42,640 --> 00:25:43,640
的原因

956
00:25:43,640 --> 00:25:44,640
對

957
00:25:44,640 --> 00:25:45,640
那就稍微去

958
00:25:45,640 --> 00:25:46,640
通診一下

959
00:25:46,640 --> 00:25:47,640
就是我們在 android 上面

960
00:25:47,640 --> 00:25:48,640
要去

961
00:25:48,640 --> 00:25:49,640
如果真的去

962
00:25:49,640 --> 00:25:50,640
拿到很高的權限的話

963
00:25:50,640 --> 00:25:52,640
我們就要先把 senus

964
00:25:52,640 --> 00:25:53,640
給 bypass 掉

965
00:25:53,640 --> 00:25:54,640
那 bypass 掉之後

966
00:25:54,640 --> 00:25:55,640
我們可以幹嘛呢

967
00:25:55,640 --> 00:25:57,640
其實我們可以做的事情

968
00:25:57,640 --> 00:25:58,640
就是

969
00:25:58,640 --> 00:25:59,640
首先因為我們已經拿到 root

970
00:25:59,640 --> 00:26:00,640
我們就可以

971
00:26:00,640 --> 00:26:01,640
rm-rf

972
00:26:01,640 --> 00:26:02,640
斜線

973
00:26:02,640 --> 00:26:03,640
就把 android 上面的

974
00:26:03,640 --> 00:26:04,640
的檔案系統

975
00:26:04,640 --> 00:26:05,640
通通刪掉

976
00:26:05,640 --> 00:26:06,640
沒有錯

977
00:26:06,640 --> 00:26:07,640
另外的話其實

978
00:26:07,640 --> 00:26:08,640
真的要去做一些

979
00:26:08,640 --> 00:26:09,640
壞壞事情的話

980
00:26:09,640 --> 00:26:10,640
其實我們可以做手機截圖

981
00:26:10,640 --> 00:26:11,640
對

982
00:26:11,640 --> 00:26:12,640
那就小心

983
00:26:12,640 --> 00:26:13,640
你的手機

984
00:26:13,640 --> 00:26:14,640
沒錯

985
00:26:14,640 --> 00:26:15,640
ok

986
00:26:15,640 --> 00:26:16,640
好

987
00:26:16,640 --> 00:26:17,640
那另外的話就是

988
00:26:17,640 --> 00:26:19,640
就稍微總結一下

989
00:26:19,640 --> 00:26:20,640
就是

990
00:26:20,640 --> 00:26:21,640
因為我們是在一個

991
00:26:21,640 --> 00:26:22,640
kernel 上的 exploit

992
00:26:22,640 --> 00:26:23,640
所以我們會需要去

993
00:26:23,640 --> 00:26:24,640
做一個 kernel module 部分

994
00:26:24,640 --> 00:26:25,640
好

995
00:26:25,640 --> 00:26:26,640
這 kernel module 做的事情

996
00:26:27,640 --> 00:26:28,640
並且去

997
00:26:28,640 --> 00:26:29,640
就是這樣子

998
00:26:29,640 --> 00:26:30,640
來去 bypass

999
00:26:30,640 --> 00:26:31,640
s-index 操作

1000
00:26:31,640 --> 00:26:32,640
所以就是

1001
00:26:32,640 --> 00:26:33,640
沒錯

1002
00:26:33,640 --> 00:26:34,640
我們就去

1003
00:26:34,640 --> 00:26:35,640
拿到一個

1004
00:26:35,640 --> 00:26:36,640
就是

1005
00:26:36,640 --> 00:26:37,640
在你手機上拿到一個

1006
00:26:37,640 --> 00:26:39,640
非常高前線的一個情況

1007
00:26:39,640 --> 00:26:40,640
好

1008
00:26:40,640 --> 00:26:41,640
那最後就稍微

1009
00:26:41,640 --> 00:26:43,640
就是來 demo 一下

1010
00:26:45,640 --> 00:26:46,640
按錯了

1011
00:26:46,640 --> 00:26:47,640
抱歉

1012
00:26:51,640 --> 00:26:52,640
不好意思

1013
00:26:53,640 --> 00:26:54,640
好

1014
00:26:54,640 --> 00:26:55,640
OK

1015
00:26:55,640 --> 00:26:56,640
好了

1016
00:26:56,640 --> 00:26:57,640
OK

1017
00:26:57,640 --> 00:26:58,640
那首先的話

1018
00:26:58,640 --> 00:26:59,640
就是你可以看到

1019
00:26:59,640 --> 00:27:00,640
就是我這邊做的事情

1020
00:27:00,640 --> 00:27:01,640
就是

1021
00:27:01,640 --> 00:27:02,640
去

1022
00:27:02,640 --> 00:27:03,640
去看一下

1023
00:27:03,640 --> 00:27:04,640
我們現在當前 UID 是 show

1024
00:27:04,640 --> 00:27:05,640
這是一個很低的前線

1025
00:27:05,640 --> 00:27:06,640
然後

1026
00:27:06,640 --> 00:27:07,640
我就

1027
00:27:07,640 --> 00:27:08,640
我們的 context 也是

1028
00:27:08,640 --> 00:27:09,640
show

1029
00:27:09,640 --> 00:27:10,640
就我現在是在一個

1030
00:27:10,640 --> 00:27:11,640
非常低的前線

1031
00:27:11,640 --> 00:27:12,640
我沒有那個

1032
00:27:12,640 --> 00:27:13,640
就是可以直接去做

1033
00:27:13,640 --> 00:27:14,640
我沒有 sudo

1034
00:27:14,640 --> 00:27:15,640
就我什麼都沒有

1035
00:27:15,640 --> 00:27:17,640
就這一個非常低的前線

1036
00:27:17,640 --> 00:27:18,640
那另外

1037
00:27:18,640 --> 00:27:19,640
右邊這邊的話

1038
00:27:19,640 --> 00:27:20,640
我們就去

1039
00:27:20,640 --> 00:27:21,640
把一個

1040
00:27:21,640 --> 00:27:22,640
就是

1041
00:27:22,640 --> 00:27:23,640
reverse show 的 server 給打開

1042
00:27:23,640 --> 00:27:24,640
對

1043
00:27:24,640 --> 00:27:25,640
接著我們左邊的部分

1044
00:27:25,640 --> 00:27:26,640
就去執行我們的 exploit

1045
00:27:26,640 --> 00:27:27,640
沒錯

1046
00:27:27,640 --> 00:27:28,640
然後執行完之後

1047
00:27:28,640 --> 00:27:29,640
你可以看到

1048
00:27:29,640 --> 00:27:30,640
右邊的 reverse show

1049
00:27:30,640 --> 00:27:31,640
那邊就彈出一個

1050
00:27:31,640 --> 00:27:32,640
就是 show 的試穿了

1051
00:27:32,640 --> 00:27:33,640
對

1052
00:27:33,640 --> 00:27:34,640
你就可以看到

1053
00:27:34,640 --> 00:27:35,640
我們拿了 show 了

1054
00:27:35,640 --> 00:27:36,640
對

1055
00:27:36,640 --> 00:27:37,640
然後這 show

1056
00:27:37,640 --> 00:27:38,640
它的 ID 是 root

1057
00:27:38,640 --> 00:27:39,640
並且它的 context

1058
00:27:39,640 --> 00:27:40,640
是 randomlyprobe

1059
00:27:40,640 --> 00:27:41,640
這代表我們當前已經

1060
00:27:41,640 --> 00:27:42,640
做完我們的 kernel module

1061
00:27:42,640 --> 00:27:43,640
就是我們已經把

1062
00:27:43,640 --> 00:27:44,640
s-index bypass 掉

1063
00:27:44,640 --> 00:27:45,640
然後我們有 24 線 data

1064
00:27:45,640 --> 00:27:46,640
我們是可以成功去

1065
00:27:46,640 --> 00:27:47,640
就是

1066
00:27:47,640 --> 00:27:48,640
看到這個 data 下面是

1067
00:27:48,640 --> 00:27:49,640
有什麼

1068
00:27:49,640 --> 00:27:50,640
有什麼東西了

1069
00:27:50,640 --> 00:27:51,640
對 沒錯

1070
00:27:51,640 --> 00:27:52,640
那大家可以

1071
00:27:52,640 --> 00:27:53,640
自己去試試看

1072
00:27:53,640 --> 00:27:54,640
就是把你的

1073
00:27:54,640 --> 00:27:55,640
Android 上面

1074
00:27:55,640 --> 00:27:56,640
開一個 show 出來

1075
00:27:56,640 --> 00:27:57,640
你可以去 LA 之前

1076
00:27:57,640 --> 00:27:58,640
去看看

1077
00:27:58,640 --> 00:27:59,640
你會發現是沒辦法做到的

1078
00:27:59,640 --> 00:28:00,640
但我們做到了

1079
00:28:00,640 --> 00:28:01,640
沒錯

1080
00:28:01,640 --> 00:28:02,640
那這邊的話就希望

1081
00:28:02,640 --> 00:28:03,640
大家鼓掌一下

1082
00:28:03,640 --> 00:28:04,640
感謝感謝

1083
00:28:08,640 --> 00:28:09,640
好的

1084
00:28:09,640 --> 00:28:10,640
好 那我們就

1085
00:28:10,640 --> 00:28:11,640
講到這邊

1086
00:28:11,640 --> 00:28:12,640
那就歡迎大家 Q&A

1087
00:28:12,640 --> 00:28:13,640
對

1088
00:28:13,640 --> 00:28:14,640
那這場可能就

1089
00:28:14,640 --> 00:28:15,640
稍微難一點

1090
00:28:15,640 --> 00:28:17,640
就歡迎大家提一些問題

1091
00:28:17,640 --> 00:28:18,640
好

1092
00:28:18,640 --> 00:28:19,640
就可能你剛才

1093
00:28:19,640 --> 00:28:20,640
有哪些就是

1094
00:28:20,640 --> 00:28:21,640
基本部分沒有聽懂

1095
00:28:21,640 --> 00:28:23,640
都可以提問這樣

1096
00:28:37,640 --> 00:28:38,640
那個

1097
00:28:38,640 --> 00:28:39,640
我們今天的

1098
00:28:39,640 --> 00:28:40,640
對

1099
00:28:40,640 --> 00:28:41,640
我們今天發問

1100
00:28:41,640 --> 00:28:42,640
都是在 slido 上面

1101
00:28:42,640 --> 00:28:44,640
所以歡迎大家掃描 QR code

1102
00:28:44,640 --> 00:28:45,640
然後在上面發問

1103
00:28:45,640 --> 00:28:46,640
然後如果你覺得

1104
00:28:46,640 --> 00:28:47,640
別人的問題

1105
00:28:47,640 --> 00:28:48,640
也是你的問題的話

1106
00:28:48,640 --> 00:28:50,640
上面都可以幫我按個讚

1107
00:28:50,640 --> 00:28:51,640
這樣你的問題

1108
00:28:51,640 --> 00:28:52,640
就會被更多人看到

1109
00:28:55,640 --> 00:28:56,640
好 那

1110
00:28:57,640 --> 00:28:58,640
這部分的話就

1111
00:28:58,640 --> 00:28:59,640
一個一個

1112
00:28:59,640 --> 00:29:00,640
請問問題滿少的

1113
00:29:00,640 --> 00:29:01,640
我們就一個一個答

1114
00:29:02,640 --> 00:29:04,640
好 那有人問到說

1115
00:29:04,640 --> 00:29:05,640
怎麼確定說

1116
00:29:05,640 --> 00:29:07,640
shellcode 的地方

1117
00:29:07,640 --> 00:29:08,640
不太會被呼叫到

1118
00:29:08,640 --> 00:29:10,640
應該是指 CXAVCD 的那塊吧

1119
00:29:10,640 --> 00:29:12,640
那那塊其實就是

1120
00:29:12,640 --> 00:29:14,640
你其實可以從 IDA 去擬

1121
00:29:14,640 --> 00:29:15,640
然後你可以從

1122
00:29:15,640 --> 00:29:16,640
close reference 去找

1123
00:29:16,640 --> 00:29:17,640
那其實你丟上去

1124
00:29:17,640 --> 00:29:18,640
直接丟上去跑

1125
00:29:18,640 --> 00:29:19,640
然後跑完以後

1126
00:29:19,640 --> 00:29:20,640
你就會發現

1127
00:29:20,640 --> 00:29:21,640
什麼事都不會發生

1128
00:29:21,640 --> 00:29:22,640
因為你丟到一串

1129
00:29:22,640 --> 00:29:23,640
一直被執行的

1130
00:29:23,640 --> 00:29:24,640
code 的區段的時候

1131
00:29:24,640 --> 00:29:25,640
你一丟上去

1132
00:29:25,640 --> 00:29:26,640
它直接壞掉

1133
00:29:26,640 --> 00:29:27,640
在客戶直接 panic

1134
00:29:27,640 --> 00:29:28,640
所以就直接進 reboot

1135
00:29:28,640 --> 00:29:29,640
那我們就那時候測

1136
00:29:29,640 --> 00:29:30,640
我們就隨便找一塊

1137
00:29:30,640 --> 00:29:32,640
就是隨便找一個 function

1138
00:29:32,640 --> 00:29:33,640
然後開始覺得說

1139
00:29:33,640 --> 00:29:34,640
好像可以

1140
00:29:34,640 --> 00:29:35,640
然後就放上去

1141
00:29:35,640 --> 00:29:36,640
然後跑

1142
00:29:36,640 --> 00:29:37,640
然後它就不會壞掉

1143
00:29:37,640 --> 00:29:38,640
那就選這一塊這樣

1144
00:29:40,640 --> 00:29:41,640
輕鬆通靈法這樣

1145
00:29:41,640 --> 00:29:42,640
我稍微補充一下

1146
00:29:42,640 --> 00:29:43,640
就是其實

1147
00:29:43,640 --> 00:29:44,640
我們當初做的時候

1148
00:29:44,640 --> 00:29:45,640
有把它丟上去

1149
00:29:45,640 --> 00:29:46,640
然後就放著

1150
00:29:46,640 --> 00:29:47,640
我們放多久啊

1151
00:29:47,640 --> 00:29:48,640
我們應該放蠻長一段時間

1152
00:29:48,640 --> 00:29:49,640
應該四五個小時吧

1153
00:29:49,640 --> 00:29:50,640
對 幾個小時

1154
00:29:50,640 --> 00:29:51,640
都沒壞

1155
00:29:51,640 --> 00:29:52,640
那應該就沒事這樣子

1156
00:29:52,640 --> 00:29:54,640
佛系找小口放置法

1157
00:29:54,640 --> 00:29:55,640
沒有錯

1158
00:29:57,640 --> 00:29:59,640
然後第二個問題是問說

1159
00:29:59,640 --> 00:30:01,640
有辦法拿到 precision root 嗎

1160
00:30:01,640 --> 00:30:02,640
像是透過 magisk 之類

1161
00:30:02,640 --> 00:30:03,640
這不行

1162
00:30:03,640 --> 00:30:04,640
因為我們

1163
00:30:04,640 --> 00:30:05,640
我們沒有去 onlabloader

1164
00:30:05,640 --> 00:30:06,640
我們的 export

1165
00:30:06,640 --> 00:30:07,640
也沒有去

1166
00:30:07,640 --> 00:30:08,640
能夠做到 onlabloader

1167
00:30:08,640 --> 00:30:09,640
沒辦法把整個分位

1168
00:30:09,640 --> 00:30:10,640
這樣刷回去

1169
00:30:10,640 --> 00:30:11,640
所以我們沒辦法

1170
00:30:11,640 --> 00:30:12,640
做到 precision root

1171
00:30:16,640 --> 00:30:17,640
好

1172
00:30:17,640 --> 00:30:18,640
那 SE 呢

1173
00:30:18,640 --> 00:30:19,640
這部分我來講一下

1174
00:30:19,640 --> 00:30:20,640
好

1175
00:30:20,640 --> 00:30:21,640
就是

1176
00:30:21,640 --> 00:30:22,640
大家

1177
00:30:22,640 --> 00:30:23,640
就是

1178
00:30:23,640 --> 00:30:24,640
又要改 permissive

1179
00:30:24,640 --> 00:30:25,640
應該可以 disable

1180
00:30:25,640 --> 00:30:26,640
應該可以吧

1181
00:30:26,640 --> 00:30:27,640
這情況是這樣的

1182
00:30:27,640 --> 00:30:29,640
要看你的 Android

1183
00:30:29,640 --> 00:30:31,640
是哪一個廠牌出的

1184
00:30:31,640 --> 00:30:33,640
就是我們目前要

1185
00:30:33,640 --> 00:30:34,640
看到一些情況就是

1186
00:30:34,640 --> 00:30:36,640
Pixel6

1187
00:30:36,640 --> 00:30:38,640
它可以去做

1188
00:30:38,640 --> 00:30:39,640
就是可以去

1189
00:30:39,640 --> 00:30:40,640
去做 set

1190
00:30:40,640 --> 00:30:42,640
就是去 setinforce

1191
00:30:42,640 --> 00:30:43,640
乘 0 的部分

1192
00:30:43,640 --> 00:30:44,640
但這個你需要

1193
00:30:44,640 --> 00:30:45,640
高權限

1194
00:30:45,640 --> 00:30:46,640
所以代表你要

1195
00:30:46,640 --> 00:30:47,640
如果真的你自己要做的話

1196
00:30:47,640 --> 00:30:48,640
就是你要

1197
00:30:48,640 --> 00:30:50,640
將你的手機刷成 root

1198
00:30:50,640 --> 00:30:51,640
並且去把這個

1199
00:30:51,640 --> 00:30:52,640
就是再去做 setinforce

1200
00:30:52,640 --> 00:30:54,640
然後你拿 root 的權限下去

1201
00:30:54,640 --> 00:30:55,640
做 setinforce0

1202
00:30:55,640 --> 00:30:56,640
對

1203
00:30:56,640 --> 00:30:57,640
但其實大部分廠牌的

1204
00:30:57,640 --> 00:30:59,640
Android 的手機

1205
00:30:59,640 --> 00:31:00,640
它都會將

1206
00:31:00,640 --> 00:31:01,640
就是

1207
00:31:01,640 --> 00:31:02,640
因為之前有提到

1208
00:31:02,640 --> 00:31:03,640
就是我要做 setinforce

1209
00:31:03,640 --> 00:31:04,640
那個

1210
00:31:04,640 --> 00:31:05,640
試行的話

1211
00:31:05,640 --> 00:31:06,640
我會需要

1212
00:31:06,640 --> 00:31:07,640
kernel module 要帶有一個

1213
00:31:07,640 --> 00:31:08,640
config 來去編譯

1214
00:31:08,640 --> 00:31:09,640
才會有這個

1215
00:31:09,640 --> 00:31:10,640
才可以去做 setinforce0

1216
00:31:10,640 --> 00:31:11,640
對

1217
00:31:11,640 --> 00:31:13,640
那這個情況其實

1218
00:31:13,640 --> 00:31:14,640
大部分的廠商

1219
00:31:14,640 --> 00:31:15,640
在編 linux kernel 的時候

1220
00:31:15,640 --> 00:31:16,640
就會把這個 flag

1221
00:31:16,640 --> 00:31:18,640
就這個 config 給拔掉

1222
00:31:18,640 --> 00:31:19,640
所以代表你沒辦法去做

1223
00:31:19,640 --> 00:31:20,640
setinforce0 的部分

1224
00:31:20,640 --> 00:31:22,640
那就沒辦法直接做

1225
00:31:22,640 --> 00:31:23,640
對

1226
00:31:23,640 --> 00:31:24,640
好

1227
00:31:24,640 --> 00:31:25,640
那有人問說

1228
00:31:25,640 --> 00:31:27,640
這個攻擊的前置條件

1229
00:31:27,640 --> 00:31:28,640
有哪些版本

1230
00:31:28,640 --> 00:31:30,640
那其實 derivative 影響的版本

1231
00:31:30,640 --> 00:31:32,640
是 kernel5.8 以上

1232
00:31:32,640 --> 00:31:34,640
那它對應到 Android 系統的話

1233
00:31:34,640 --> 00:31:35,640
是 Android12

1234
00:31:35,640 --> 00:31:37,640
那像是我們

1235
00:31:37,640 --> 00:31:39,640
可以在 pixel6

1236
00:31:39,640 --> 00:31:41,640
或是 samsung galaxy22 上

1237
00:31:41,640 --> 00:31:43,640
自行攻擊

1238
00:31:43,640 --> 00:31:45,640
那就順便回答說

1239
00:31:45,640 --> 00:31:46,640
下面有一個說

1240
00:31:46,640 --> 00:31:47,640
有沒有人在 arm 上手機實驗過

1241
00:31:47,640 --> 00:31:48,640
有

1242
00:31:48,640 --> 00:31:49,640
其實我們是

1243
00:31:49,640 --> 00:31:50,640
有打

1244
00:31:50,640 --> 00:31:51,640
就是有用 export

1245
00:31:51,640 --> 00:31:52,640
直接在 pixel6 上

1246
00:31:52,640 --> 00:31:53,640
拿 root

1247
00:31:57,640 --> 00:31:59,640
花了多少時間做到

1248
00:31:59,640 --> 00:32:00,640
是

1249
00:32:00,640 --> 00:32:01,640
我們其實

1250
00:32:01,640 --> 00:32:02,640
做這個大概從

1251
00:32:02,640 --> 00:32:05,640
3 月到 5 月中吧

1252
00:32:05,640 --> 00:32:07,640
大概兩個多月

1253
00:32:07,640 --> 00:32:09,640
從我們對於

1254
00:32:09,640 --> 00:32:11,640
那個環境的不認識

1255
00:32:11,640 --> 00:32:12,640
然後到一路 export

1256
00:32:12,640 --> 00:32:14,640
大概兩個月這樣子

1257
00:32:14,640 --> 00:32:15,640
那從中間的話

1258
00:32:15,640 --> 00:32:17,640
我們就從 invater 上

1259
00:32:17,640 --> 00:32:18,640
開始看

1260
00:32:18,640 --> 00:32:19,640
然後跟

1261
00:32:19,640 --> 00:32:20,640
看 Android 的 source

1262
00:32:20,640 --> 00:32:21,640
看 NS 的保護機制

1263
00:32:21,640 --> 00:32:22,640
跟

1264
00:32:22,640 --> 00:32:24,640
還有做一些黑箱通靈法

1265
00:32:24,640 --> 00:32:25,640
就是

1266
00:32:25,640 --> 00:32:26,640
我們在 debug 的時候

1267
00:32:26,640 --> 00:32:27,640
其實那時候遇到一個

1268
00:32:27,640 --> 00:32:28,640
蠻好笑的問題

1269
00:32:28,640 --> 00:32:29,640
就是我們 invater

1270
00:32:29,640 --> 00:32:31,640
我們要接 GDB server debug 出來

1271
00:32:31,640 --> 00:32:32,640
結果一 attach 上

1272
00:32:32,640 --> 00:32:33,640
init process

1273
00:32:33,640 --> 00:32:34,640
直接爛掉

1274
00:32:34,640 --> 00:32:35,640
我們想說

1275
00:32:35,640 --> 00:32:36,640
是什麼意思

1276
00:32:36,640 --> 00:32:37,640
我們就直接用 panic 的

1277
00:32:37,640 --> 00:32:39,640
那個 message 來做 debug

1278
00:32:43,640 --> 00:32:44,640
那能繞過

1279
00:32:44,640 --> 00:32:47,640
Samsung Knox 的硬體及保護嗎

1280
00:32:48,640 --> 00:32:49,640
我們真的沒有去對

1281
00:32:49,640 --> 00:32:51,640
Samsung 的 Knox

1282
00:32:51,640 --> 00:32:53,640
Samsung Knox 的保護機制

1283
00:32:53,640 --> 00:32:54,640
我們沒有對

1284
00:32:54,640 --> 00:32:55,640
Samsung 的手機做過

1285
00:32:55,640 --> 00:32:56,640
所以這邊

1286
00:32:56,640 --> 00:32:58,640
還沒辦法跟你確定

1287
00:32:58,640 --> 00:33:00,640
對 但 Samsung Knox

1288
00:33:00,640 --> 00:33:01,640
要去繞過

1289
00:33:01,640 --> 00:33:02,640
應該還是會需要

1290
00:33:02,640 --> 00:33:03,640
就是拿到

1291
00:33:03,640 --> 00:33:04,640
跟我們前面提到

1292
00:33:04,640 --> 00:33:05,640
Persistent

1293
00:33:05,640 --> 00:33:06,640
拿到一樣的權限

1294
00:33:06,640 --> 00:33:08,640
就是我們至少要拿到

1295
00:33:08,640 --> 00:33:09,640
EL3 的這樣的權限

1296
00:33:09,640 --> 00:33:11,640
我們才有可能去做

1297
00:33:11,640 --> 00:33:12,640
bypass 掉

1298
00:33:12,640 --> 00:33:13,640
這樣硬體保護機的部分

1299
00:33:13,640 --> 00:33:14,640
那我們現在其實都是

1300
00:33:14,640 --> 00:33:15,640
遊蕩在 EL1 而已

1301
00:33:15,640 --> 00:33:16,640
就是我們可以再去

1302
00:33:16,640 --> 00:33:18,640
Knox 上面去做一些

1303
00:33:18,640 --> 00:33:19,640
乖乖幹一個

1304
00:33:19,640 --> 00:33:20,640
乖乖的事情這樣

1305
00:33:20,640 --> 00:33:21,640
對對對

1306
00:33:21,640 --> 00:33:22,640
我們所有就在 EL1 上而已

1307
00:33:22,640 --> 00:33:24,640
還沒達到 EL3

1308
00:33:25,640 --> 00:33:27,640
現在這個漏洞已經修補了

1309
00:33:27,640 --> 00:33:28,640
對 那個 Dirty Pie

1310
00:33:28,640 --> 00:33:29,640
這個洞已經補起來了

1311
00:33:29,640 --> 00:33:31,640
就是我們那時候測的分位

1312
00:33:31,640 --> 00:33:33,640
是我們從

1313
00:33:33,640 --> 00:33:34,640
因為它是二月

1314
00:33:34,640 --> 00:33:35,640
Dirty Pie 是今年

1315
00:33:35,640 --> 00:33:36,640
二月 release 的一個洞

1316
00:33:36,640 --> 00:33:37,640
二月底 三月初

1317
00:33:37,640 --> 00:33:39,640
那我們測過的洞是

1318
00:33:39,640 --> 00:33:41,640
我們一路測到 Pixel 6 的五月

1319
00:33:41,640 --> 00:33:42,640
它都可以 Exploit

1320
00:33:42,640 --> 00:33:43,640
五月的時候

1321
00:33:43,640 --> 00:33:45,640
Pixel 6 的分位才修好

1322
00:33:45,640 --> 00:33:46,640
對

1323
00:33:46,640 --> 00:33:47,640
好 這邊可以講一個

1324
00:33:47,640 --> 00:33:48,640
滿有趣的事情

1325
00:33:48,640 --> 00:33:49,640
就是我們當初

1326
00:33:49,640 --> 00:33:51,640
在去做 Android 的

1327
00:33:51,640 --> 00:33:53,640
就 Emulator 上面的 Exploit 的時候

1328
00:33:53,640 --> 00:33:54,640
我們其實是

1329
00:33:54,640 --> 00:33:55,640
我是去載

1330
00:33:55,640 --> 00:33:56,640
應該是十二月

1331
00:33:56,640 --> 00:33:58,640
二零二一十二月份的

1332
00:33:58,640 --> 00:34:00,640
的那個就是 Android

1333
00:34:00,640 --> 00:34:01,640
對 但我發現

1334
00:34:01,640 --> 00:34:03,640
它上面的那個

1335
00:34:03,640 --> 00:34:04,640
Dirty Pie 是被 patch 掉了

1336
00:34:04,640 --> 00:34:05,640
超神奇的

1337
00:34:05,640 --> 00:34:06,640
它明明就是

1338
00:34:06,640 --> 00:34:08,640
二零二一年十二月的

1339
00:34:08,640 --> 00:34:09,640
Kernel

1340
00:34:09,640 --> 00:34:10,640
但它 Dirty Pie 是 patch 掉了

1341
00:34:10,640 --> 00:34:11,640
就超怪

1342
00:34:11,640 --> 00:34:12,640
但明明這個東西

1343
00:34:12,640 --> 00:34:13,640
二月才 release

1344
00:34:13,640 --> 00:34:14,640
我就不知道它是

1345
00:34:14,640 --> 00:34:15,640
到底發生什麼事情

1346
00:34:15,640 --> 00:34:16,640
對 可能是

1347
00:34:16,640 --> 00:34:17,640
後面有去做更新之類的吧

1348
00:34:17,640 --> 00:34:18,640
但反正就

1349
00:34:18,640 --> 00:34:19,640
它有 patch 掉這樣

1350
00:34:19,640 --> 00:34:21,640
對 就滿有趣的

1351
00:34:24,640 --> 00:34:25,640
漏洞怎麼補

1352
00:34:25,640 --> 00:34:28,640
漏洞曾經其實是在於說

1353
00:34:28,640 --> 00:34:29,640
Dirty Pie 這個洞

1354
00:34:29,640 --> 00:34:30,640
是它在 Pipe

1355
00:34:30,640 --> 00:34:31,640
拿 Pipe 的時候

1356
00:34:31,640 --> 00:34:33,640
它沒有對 Flag 做 initialize

1357
00:34:33,640 --> 00:34:35,640
就是沒有做初始化

1358
00:34:37,640 --> 00:34:38,640
其實它怎麼補的

1359
00:34:38,640 --> 00:34:41,640
就是在拿 Page Reference 的時候

1360
00:34:41,640 --> 00:34:43,640
直接先做 initialize

1361
00:34:43,640 --> 00:34:45,640
就直接加一個等於零這樣

1362
00:34:45,640 --> 00:34:46,640
就把它補掉了

1363
00:34:49,640 --> 00:34:50,640
詳細其實大家可以

1364
00:34:50,640 --> 00:34:51,640
盡量去搜尋

1365
00:34:51,640 --> 00:34:53,640
就是 Dirty Pie 的

1366
00:34:53,640 --> 00:34:55,640
就這關鍵字

1367
00:34:55,640 --> 00:34:56,640
你去看第一篇文章

1368
00:34:56,640 --> 00:34:57,640
應該就是

1369
00:34:57,640 --> 00:34:59,640
就是當初發 Dirty Pie

1370
00:34:59,640 --> 00:35:02,640
這個 CVE 的那一個作者

1371
00:35:02,640 --> 00:35:03,640
他的 Blog

1372
00:35:03,640 --> 00:35:04,640
那你就可以看到說

1373
00:35:04,640 --> 00:35:05,640
他的詳細的

1374
00:35:05,640 --> 00:35:07,640
他的漏洞是怎麼形成的

1375
00:35:07,640 --> 00:35:09,640
他到底做了怎樣的事情

1376
00:35:09,640 --> 00:35:11,640
他為什麼會碰到這漏洞

1377
00:35:11,640 --> 00:35:12,640
這也蠻有趣的

1378
00:35:12,640 --> 00:35:13,640
然後就是

1379
00:35:13,640 --> 00:35:15,640
他到底是怎麼去把它修掉的

1380
00:35:15,640 --> 00:35:16,640
詳細都可以看到

1381
00:35:16,640 --> 00:35:17,640
如果大家有興趣

1382
00:35:17,640 --> 00:35:18,640
可以去看一下

1383
00:35:19,640 --> 00:35:20,640
我這邊補充一個

1384
00:35:20,640 --> 00:35:22,640
就是 Dirty Pie 其實

1385
00:35:22,640 --> 00:35:23,640
它有一個限制

1386
00:35:23,640 --> 00:35:24,640
就是它不能寫

1387
00:35:24,640 --> 00:35:26,640
每個 Page 的第一個 Button

1388
00:35:26,640 --> 00:35:28,640
其實這個部分讓我們

1389
00:35:28,640 --> 00:35:29,640
因為我們後面有寫 Column Module

1390
00:35:29,640 --> 00:35:30,640
因為 Column Module

1391
00:35:30,640 --> 00:35:32,640
不太可能只有一個 Page 的 Size

1392
00:35:32,640 --> 00:35:33,640
所以我們必須要用

1393
00:35:33,640 --> 00:35:35,640
我們還必須要繞過這個限制

1394
00:35:35,640 --> 00:35:37,640
就是我們 Column Module

1395
00:35:37,640 --> 00:35:39,640
是三個 Page

1396
00:35:39,640 --> 00:35:40,640
所以我們至少

1397
00:35:40,640 --> 00:35:42,640
我們這個還需要去繞這個

1398
00:35:42,640 --> 00:35:43,640
所以這個還是一個蠻有趣的議題

1399
00:35:43,640 --> 00:35:44,640
大家也可以想想看說

1400
00:35:44,640 --> 00:35:45,640
當你這個

1401
00:35:45,640 --> 00:35:47,640
你這個洞被限制的時候

1402
00:35:47,640 --> 00:35:49,640
你有什麼方法可以去

1403
00:35:49,640 --> 00:35:51,640
就是你的 Export 也被限制住

1404
00:35:51,640 --> 00:35:52,640
那你還要怎麼去 Export

1405
00:35:52,640 --> 00:35:54,640
也是一個蠻有趣的問題

1406
00:35:54,640 --> 00:35:55,640
我稍微補充一下

1407
00:35:55,640 --> 00:35:57,640
就是這邊的限制其實是這樣

1408
00:35:57,640 --> 00:35:58,640
就是因為我們沒辦法去

1409
00:35:58,640 --> 00:36:00,640
寫到第一個 Byte

1410
00:36:00,640 --> 00:36:01,640
就是我們每 Page 的第一個 Byte

1411
00:36:01,640 --> 00:36:02,640
所以代表我們沒辦法去寫到

1412
00:36:02,640 --> 00:36:03,640
D0 D0X1 0 0 0

1413
00:36:03,640 --> 00:36:04,640
D0X2 0 0 0

1414
00:36:04,640 --> 00:36:05,640
這三個位置

1415
00:36:05,640 --> 00:36:06,640
因為我剛才有說

1416
00:36:06,640 --> 00:36:08,640
是三個 Page 的大小的 Column Module

1417
00:36:08,640 --> 00:36:09,640
所以我這三個位置是不能寫的

1418
00:36:09,640 --> 00:36:11,640
那既然這三個位置不能寫的話

1419
00:36:11,640 --> 00:36:13,640
代表我們寫上去 Column Module

1420
00:36:13,640 --> 00:36:15,640
它會有三個 Byte 是壞掉的

1421
00:36:15,640 --> 00:36:16,640
那這個問題的話

1422
00:36:16,640 --> 00:36:18,640
其實就會去影響到一些事情

1423
00:36:18,640 --> 00:36:20,640
但我這邊直接爆雷好了

1424
00:36:20,640 --> 00:36:21,640
就是我們的做法是這樣的

1425
00:36:21,640 --> 00:36:22,640
其實大家可以去

1426
00:36:22,640 --> 00:36:24,640
有興趣可以去看一看

1427
00:36:24,640 --> 00:36:25,640
那我這邊就稍微講一下

1428
00:36:25,640 --> 00:36:27,640
就我們 HeatKan 到時候應該

1429
00:36:27,640 --> 00:36:28,640
在 HeatKan 的 YouTube 上面

1430
00:36:28,640 --> 00:36:31,640
應該會 release 我們在 HeatKan 上的發表

1431
00:36:31,640 --> 00:36:32,640
然後這邊的話就是

1432
00:36:32,640 --> 00:36:34,640
HeatKan 的那個 NERF 版本

1433
00:36:34,640 --> 00:36:35,640
沒有錯

1434
00:36:35,640 --> 00:36:36,640
就到時候有興趣可以看

1435
00:36:36,640 --> 00:36:37,640
那我這邊稍微講一下就是

1436
00:36:37,640 --> 00:36:39,640
我們是怎麼擺 Page 它的

1437
00:36:39,640 --> 00:36:41,640
首先的話就是 D0X0 的部分

1438
00:36:41,640 --> 00:36:42,640
因為我們是一個 Column Module

1439
00:36:42,640 --> 00:36:45,640
去 Override 到 Library 裡面

1440
00:36:45,640 --> 00:36:46,640
Column Module 和 Library

1441
00:36:46,640 --> 00:36:48,640
它們都是 ELF 的格式碼

1442
00:36:48,640 --> 00:36:49,640
所以在 D0 的位置

1443
00:36:49,640 --> 00:36:51,640
它一定是一個 Major Number

1444
00:36:51,640 --> 00:36:53,640
所以這部分一定是一樣的

1445
00:36:53,640 --> 00:36:54,640
所以我沒寫到它

1446
00:36:54,640 --> 00:36:55,640
它也是會一樣就沒差

1447
00:36:55,640 --> 00:36:57,640
但在 D0X1000

1448
00:36:57,640 --> 00:36:59,640
和 D0X2000 這兩個位置的部分的話

1449
00:36:59,640 --> 00:37:02,640
就比較麻煩

1450
00:37:02,640 --> 00:37:04,640
我們是怎麼做的呢

1451
00:37:04,640 --> 00:37:05,640
通靈

1452
00:37:05,640 --> 00:37:06,640
沒錯

1453
00:37:06,640 --> 00:37:08,640
我們就直接去硬找一個 Library

1454
00:37:08,640 --> 00:37:09,640
跟我們 Column Module 上面

1455
00:37:09,640 --> 00:37:10,640
這兩個位置的值是一樣的

1456
00:37:10,640 --> 00:37:12,640
找到我們就成功了

1457
00:37:12,640 --> 00:37:13,640
沒錯

1458
00:37:13,640 --> 00:37:15,640
就是這麼做的

1459
00:37:15,640 --> 00:37:16,640
但其實我們沒有找到啦

1460
00:37:16,640 --> 00:37:18,640
我們其實只有找到

1461
00:37:18,640 --> 00:37:20,640
在 D0X2000 位置是一樣的

1462
00:37:20,640 --> 00:37:21,640
但 D0X1000 位置不一樣

1463
00:37:21,640 --> 00:37:23,640
但我們找到那個位置的值

1464
00:37:23,640 --> 00:37:25,640
有一個 Library 那個值是 90

1465
00:37:25,640 --> 00:37:26,640
0X90

1466
00:37:26,640 --> 00:37:27,640
就是一個 Nope

1467
00:37:27,640 --> 00:37:28,640
沒錯

1468
00:37:28,640 --> 00:37:29,640
在 X823 是一個 Nope

1469
00:37:29,640 --> 00:37:30,640
那既然它是 Nope 的話

1470
00:37:30,640 --> 00:37:31,640
我就在 Column Module 那個位置

1471
00:37:31,640 --> 00:37:32,640
塞一個 Nope 進去

1472
00:37:32,640 --> 00:37:33,640
搞定

1473
00:37:33,640 --> 00:37:34,640
這樣

1474
00:37:34,640 --> 00:37:35,640
沒錯

1475
00:37:35,640 --> 00:37:37,640
那這邊就有這樣的一個小小故事

1476
00:37:37,640 --> 00:37:38,640
那有人問說

1477
00:37:38,640 --> 00:37:41,640
手機的本地體圈怎麼利用

1478
00:37:41,640 --> 00:37:43,640
是問說我們是

1479
00:37:43,640 --> 00:37:46,640
怎麼用漏洞利用的嗎

1480
00:37:46,640 --> 00:37:47,640
還是

1481
00:37:47,640 --> 00:37:48,640
我們如果是用漏洞利用的話

1482
00:37:48,640 --> 00:37:50,640
其實跟 Emitter 其實差不多

1483
00:37:50,640 --> 00:37:51,640
它變成 ARM 架構

1484
00:37:51,640 --> 00:37:52,640
就是

1485
00:37:52,640 --> 00:37:53,640
我們 Emitter 是 X86

1486
00:37:53,640 --> 00:37:54,640
那我們就是

1487
00:37:54,640 --> 00:37:55,640
把它

1488
00:37:55,640 --> 00:37:56,640
把可能 Shellcode

1489
00:37:56,640 --> 00:37:57,640
把那些東西變成 ARM

1490
00:37:57,640 --> 00:37:58,640
那其實

1491
00:37:58,640 --> 00:37:59,640
還有遇到一個問題

1492
00:37:59,640 --> 00:38:00,640
就是蠻好笑的

1493
00:38:00,640 --> 00:38:02,640
蠻有趣的問題就是

1494
00:38:02,640 --> 00:38:04,640
其實它的 Policy 也有變

1495
00:38:04,640 --> 00:38:06,640
就是實際手機跟 Emitter 上的

1496
00:38:06,640 --> 00:38:07,640
Policy 有變

1497
00:38:07,640 --> 00:38:08,640
它沒有 Transition 到

1498
00:38:08,640 --> 00:38:10,640
Mandelbrot Part 那條路

1499
00:38:10,640 --> 00:38:12,640
但是我們是選擇用 Transition 到

1500
00:38:12,640 --> 00:38:14,640
另外一個叫 Init-Ethermode.sh

1501
00:38:14,640 --> 00:38:15,640
的另外一個路上

1502
00:38:15,640 --> 00:38:16,640
對

1503
00:38:16,640 --> 00:38:17,640
那

1504
00:38:17,640 --> 00:38:18,640
那邊的話會

1505
00:38:18,640 --> 00:38:20,640
就比較抽象跟複雜一點

1506
00:38:20,640 --> 00:38:21,640
就是

1507
00:38:21,640 --> 00:38:22,640
這邊沒有

1508
00:38:22,640 --> 00:38:23,640
沒有準備到

1509
00:38:23,640 --> 00:38:24,640
手機的本地體權

1510
00:38:24,640 --> 00:38:25,640
怎麼利用

1511
00:38:25,640 --> 00:38:27,640
的 Slide

1512
00:38:27,640 --> 00:38:28,640
喔

1513
00:38:28,640 --> 00:38:29,640
喔

1514
00:38:29,640 --> 00:38:30,640
如果你是想要這個漏洞

1515
00:38:30,640 --> 00:38:31,640
到底可以做哪些

1516
00:38:31,640 --> 00:38:32,640
破壞的事情的話

1517
00:38:32,640 --> 00:38:33,640
就它只有把它包裝成

1518
00:38:33,640 --> 00:38:34,640
武器的部分的話

1519
00:38:34,640 --> 00:38:35,640
首先的話就是

1520
00:38:35,640 --> 00:38:36,640
這東西其實可以

1521
00:38:36,640 --> 00:38:37,640
包裝成一個 App 的

1522
00:38:37,640 --> 00:38:38,640
對

1523
00:38:38,640 --> 00:38:39,640
那我們就可以把

1524
00:38:39,640 --> 00:38:40,640
這個 App 散播出去

1525
00:38:40,640 --> 00:38:41,640
那只要

1526
00:38:41,640 --> 00:38:42,640
只要你載到這個 App

1527
00:38:42,640 --> 00:38:43,640
你就會在我們這邊

1528
00:38:43,640 --> 00:38:44,640
彈一個 Reversio 出來

1529
00:38:44,640 --> 00:38:45,640
那我們就可以對你

1530
00:38:45,640 --> 00:38:46,640
做一些事情這樣

1531
00:38:46,640 --> 00:38:47,640
沒錯

1532
00:38:47,640 --> 00:38:48,640
對

1533
00:38:48,640 --> 00:38:49,640
它是可以做成 App 的

1534
00:38:53,640 --> 00:38:54,640
看大家還有什麼

1535
00:38:55,640 --> 00:38:56,640
問題嗎

1536
00:39:08,640 --> 00:39:09,640
硬體設計

1537
00:39:09,640 --> 00:39:11,640
有辦法避免漏洞嗎

1538
00:39:12,640 --> 00:39:13,640
嗯

1539
00:39:14,640 --> 00:39:15,640
這個

1540
00:39:15,640 --> 00:39:16,640
這個

1541
00:39:29,640 --> 00:39:30,640
這我們不是

1542
00:39:31,640 --> 00:39:32,640
很確定

1543
00:39:32,640 --> 00:39:33,640
但是

1544
00:39:33,640 --> 00:39:34,640
因為我們打的是在科農城

1545
00:39:34,640 --> 00:39:35,640
所以

1546
00:39:36,640 --> 00:39:37,640
嗯

1547
00:39:37,640 --> 00:39:38,640
硬體設計應該是

1548
00:39:38,640 --> 00:39:39,640
現在還是

1549
00:39:39,640 --> 00:39:40,640
對

1550
00:39:40,640 --> 00:39:41,640
沒辦法去避免掉這個洞

1551
00:39:43,640 --> 00:39:44,640
那能夠抓 RC 嗎

1552
00:39:45,640 --> 00:39:46,640
我們拿到 Reversible Shell 以後

1553
00:39:46,640 --> 00:39:47,640
我們就可以做

1554
00:39:47,640 --> 00:39:48,640
任何事情

1555
00:39:48,640 --> 00:39:50,640
然後我們就是在

1556
00:39:50,640 --> 00:39:51,640
用這個動作 RC

1557
00:39:51,640 --> 00:39:52,640
沒錯

1558
00:39:58,640 --> 00:39:59,640
市面上

1559
00:39:59,640 --> 00:40:00,640
直接在

1560
00:40:00,640 --> 00:40:01,640
本機 Root

1561
00:40:01,640 --> 00:40:02,640
嗯

1562
00:40:02,640 --> 00:40:03,640
市面上像是

1563
00:40:03,640 --> 00:40:04,640
你刷 Root

1564
00:40:04,640 --> 00:40:05,640
就是你可以用

1565
00:40:05,640 --> 00:40:07,640
剛有人提到一個 Magisk 的 Tool

1566
00:40:07,640 --> 00:40:09,640
它其實會去 Page 你的 Boot 的 Image

1567
00:40:09,640 --> 00:40:11,640
就是它會去換成它自己的

1568
00:40:12,640 --> 00:40:13,640
就是它自己的

1569
00:40:13,640 --> 00:40:14,640
那個 Sudo

1570
00:40:14,640 --> 00:40:15,640
或是 InitProcess

1571
00:40:15,640 --> 00:40:17,640
然後會先把你的 SEDs 關掉

1572
00:40:17,640 --> 00:40:19,640
然後它會去註冊一個

1573
00:40:19,640 --> 00:40:21,640
AllowAllPolicy 的 Service 上去

1574
00:40:21,640 --> 00:40:22,640
然後它就是會有 Sudo

1575
00:40:22,640 --> 00:40:24,640
就是它其實可以做提權

1576
00:40:24,640 --> 00:40:25,640
就它自己 Magisk

1577
00:40:25,640 --> 00:40:26,640
它其實會塞一個

1578
00:40:26,640 --> 00:40:27,640
自己的 SU 進去

1579
00:40:27,640 --> 00:40:29,640
所以不一定是都是用漏洞

1580
00:40:29,640 --> 00:40:30,640
有些也是用

1581
00:40:30,640 --> 00:40:31,640
它原本底層開機的時候

1582
00:40:31,640 --> 00:40:32,640
來做到的

1583
00:40:33,640 --> 00:40:34,640
但你要先 Unlock 不漏的

1584
00:40:34,640 --> 00:40:35,640
對 刷機的話

1585
00:40:36,640 --> 00:40:37,640
對 重點就是

1586
00:40:37,640 --> 00:40:38,640
因為 Unlock 不

1587
00:40:38,640 --> 00:40:39,640
為什麼要 Unlock 不漏的

1588
00:40:39,640 --> 00:40:41,640
就是因為 Unlock 完不漏的之後

1589
00:40:41,640 --> 00:40:43,640
它就才不會去做 Secure Boot

1590
00:40:43,640 --> 00:40:44,640
就是會去檢查

1591
00:40:44,640 --> 00:40:46,640
你當前的 Image

1592
00:40:46,640 --> 00:40:47,640
有沒有被更改過

1593
00:40:47,640 --> 00:40:49,640
但就是因為這樣子

1594
00:40:49,640 --> 00:40:50,640
所以我們沒辦法去把

1595
00:40:50,640 --> 00:40:52,640
就是它 Image 給改掉

1596
00:40:52,640 --> 00:40:53,640
改掉的話它就會去發現

1597
00:40:53,640 --> 00:40:54,640
在 Secure Boot 的時候

1598
00:40:54,640 --> 00:40:55,640
就會發現

1599
00:40:55,640 --> 00:40:56,640
欸 你改掉了

1600
00:40:56,640 --> 00:40:57,640
我們就隨時

1601
00:40:57,640 --> 00:40:58,640
然後就直接

1602
00:40:58,640 --> 00:41:00,640
直接試給你看 對

1603
00:41:00,640 --> 00:41:01,640
所以這就是為什麼

1604
00:41:01,640 --> 00:41:02,640
我們沒辦法去做到 Persistent 的部分

1605
00:41:02,640 --> 00:41:03,640
對 因為我們沒辦法

1606
00:41:03,640 --> 00:41:04,640
Unlock 不漏的

1607
00:41:04,640 --> 00:41:06,640
對 那個東西叫做 DM Vertify

1608
00:41:06,640 --> 00:41:07,640
DM Vertify

1609
00:41:07,640 --> 00:41:08,640
那你可以去

1610
00:41:08,640 --> 00:41:09,640
有興趣的可以 Google

1611
00:41:09,640 --> 00:41:10,640
Android DM Vertify

1612
00:41:10,640 --> 00:41:12,640
它就是不漏的檢查的一個機制

1613
00:41:13,640 --> 00:41:15,640
它會一層一層的驗你的 Hash

1614
00:41:17,640 --> 00:41:18,640
好 那時間差不多了

1615
00:41:18,640 --> 00:41:19,640
那就到這邊

1616
00:41:19,640 --> 00:41:20,640
感謝大家提問

1617
00:41:20,640 --> 00:41:21,640
幫我們撐完最後十分鐘


