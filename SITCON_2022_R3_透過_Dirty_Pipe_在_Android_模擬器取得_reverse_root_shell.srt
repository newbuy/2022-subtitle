1
00:00:00,000 --> 00:00:07,680
大家好,我是來帶大家看這場議程的講者

2
00:00:07,680 --> 00:00:13,320
我們題目就是透過Dirty Pi在Android模擬器上取得Reverse-to-Show

3
00:00:13,320 --> 00:00:16,200
大家可能會聽著聽著不曉得啥

4
00:00:16,200 --> 00:00:22,000
大家可能都會,我們這場比較硬核一點,希望大家可以撐到最後

5
00:00:22,000 --> 00:00:25,080
先來自我介紹一下

6
00:00:25,080 --> 00:00:28,520
下面那一個是螢幕,這是我的ID

7
00:00:28,520 --> 00:00:33,120
我現在就在Team T5擔任第三九的實習生

8
00:00:33,120 --> 00:00:36,960
我是在做一個Vulnerability Researcher

9
00:00:36,960 --> 00:00:40,040
就這間公司,這邊也看得到

10
00:00:40,040 --> 00:00:44,640
我們應該有擺攤,可以去稍微逛一下

11
00:00:44,640 --> 00:00:49,000
另外的話是李仁,他一樣就是

12
00:00:49,000 --> 00:00:54,640
大家好,我也是T5的實習生,現在是中山治安所的研究生

13
00:00:55,640 --> 00:01:01,640
目前Focus在Mobile Security跟Linux Kernel的安全

14
00:01:01,640 --> 00:01:05,640
反正我們就是一群喜歡治安的傢伙

15
00:01:05,640 --> 00:01:10,640
希望在座各位可能對治安會有些興趣

16
00:01:10,640 --> 00:01:15,640
我們可能就會跟你說,治安不是這麼的簡單

17
00:01:15,640 --> 00:01:21,640
接著是我們的slide的部分

18
00:01:22,640 --> 00:01:25,640
首先來講一下我們到底是在幹嘛

19
00:01:25,640 --> 00:01:27,640
因為我們的題目可以看到

20
00:01:27,640 --> 00:01:30,640
我們會想要在Android上面去做一個Exploring

21
00:01:30,640 --> 00:01:33,640
我們的目標是用一個Kernel上的CVE

22
00:01:33,640 --> 00:01:36,640
這個CVE的話,因為是Kernel

23
00:01:36,640 --> 00:01:38,640
Android它用到的Kernel是Linux Kernel

24
00:01:38,640 --> 00:01:40,640
我們的目標是做提權

25
00:01:40,640 --> 00:01:42,640
所以說我們就要先來看一下

26
00:01:42,640 --> 00:01:45,640
怎麼在基本的Linux上去做一個提權部分

27
00:01:45,640 --> 00:01:48,640
正常情況下我們可以看到說

28
00:01:48,640 --> 00:01:51,640
就是我們會想要去做APD Install一個東西

29
00:01:51,640 --> 00:01:53,640
我們這邊Install一個Seq,雖然它不存在

30
00:01:53,640 --> 00:01:56,640
但你可以看到說它就是會有一個Permission Deny的部分

31
00:01:56,640 --> 00:01:58,640
就是代表你沒有權限嘛

32
00:01:58,640 --> 00:02:01,640
那在這種時候我們通常會想要去做一件事情就是

33
00:02:01,640 --> 00:02:04,640
Sudo,沒錯,這大家應該都知道

34
00:02:04,640 --> 00:02:09,640
我們就直接Sudo下去,Install,就可以成功了,讚

35
00:02:09,640 --> 00:02:12,640
那就是因為我是要做一些提權部分

36
00:02:12,640 --> 00:02:15,640
那我先來看一下Sudo這件事情到底在做什麼事

37
00:02:15,640 --> 00:02:17,640
首先的話,這Sudo的話它就先去看

38
00:02:17,640 --> 00:02:19,640
你的當前這個User是不是一個Sudoers

39
00:02:19,640 --> 00:02:22,640
如果你是Sudoers的話,它就會再去跟你說

40
00:02:22,640 --> 00:02:25,640
你要給我就是你這Sudoers的密碼

41
00:02:25,640 --> 00:02:29,640
那這密碼正確之後,就是它才會去做提權部分

42
00:02:29,640 --> 00:02:34,640
那提權做的事情其實它是在去執行到一個System Code

43
00:02:34,640 --> 00:02:37,640
Needle Scroll的一個System Code,叫做Set UID

44
00:02:37,640 --> 00:02:41,640
那做完Set UID之後,你就會把你的UID轉換成0

45
00:02:41,640 --> 00:02:43,640
也就是你就切換到Root這個User

46
00:02:43,640 --> 00:02:47,640
那Root這個User就是有一個非常高權限的一個User

47
00:02:47,640 --> 00:02:49,640
你就可以直接做APT Install這樣

48
00:02:49,640 --> 00:02:53,640
對,然後你這邊的話可以看到就是

49
00:02:53,640 --> 00:02:55,640
除此之外,就是我這Sudo這個Binary

50
00:02:55,640 --> 00:02:59,640
它其實是帶有一個Ninus的一個Flag

51
00:02:59,640 --> 00:03:01,640
叫Set UID Flag

52
00:03:01,640 --> 00:03:03,640
那有這個Flag的情況下

53
00:03:03,640 --> 00:03:07,640
Ninus才會允許你出去做Set UID轉換成Root

54
00:03:07,640 --> 00:03:09,640
對,沒錯,就會有一個這樣的機制

55
00:03:09,640 --> 00:03:11,640
這就是一些Ninus的一些背景

56
00:03:12,640 --> 00:03:14,640
那我們稍微來看一下Root是啥

57
00:03:14,640 --> 00:03:18,640
這邊的話是擷取自Manual7 Capabilities的部分

58
00:03:18,640 --> 00:03:21,640
那你可以看到它上面其實要講的事情就是

59
00:03:21,640 --> 00:03:24,640
當你是Root這個User的時候

60
00:03:24,640 --> 00:03:28,640
Kernel那邊的就是檢查機制全部line過

61
00:03:28,640 --> 00:03:31,640
沒錯,所以就是Root超強

62
00:03:31,640 --> 00:03:34,640
沒錯,所以Root就可以像是這個超級肌肉彩彩

63
00:03:34,640 --> 00:03:37,640
而其他User就是非常

64
00:03:37,640 --> 00:03:40,640
就是可以拿到的Capabilities比較少

65
00:03:41,640 --> 00:03:44,640
但是就是說我們會有碰到一個情況

66
00:03:44,640 --> 00:03:48,640
因為我們現在是要做一個非法的提權

67
00:03:48,640 --> 00:03:50,640
我們是透過一個Exploit去做一個非法的提權

68
00:03:50,640 --> 00:03:55,640
那非法提權我們當然不見得會拿一個有stoolers的User來去做提權

69
00:03:55,640 --> 00:03:58,640
而且除此之外我們也可能會

70
00:03:58,640 --> 00:04:01,640
就算我們是一個stoolers我們也有可能不會沒有password

71
00:04:01,640 --> 00:04:05,640
那我們就沒辦法去做就是後續的setEUID來去做提權的部分

72
00:04:05,640 --> 00:04:08,640
所以你就可以看到這邊就是stool

73
00:04:08,640 --> 00:04:11,640
他做了stool但是因為你不是stooler

74
00:04:11,640 --> 00:04:14,640
所以我還是不行來哈哈沒錯

75
00:04:14,640 --> 00:04:16,640
所以我們這邊的話就會要去做一個就是

76
00:04:16,640 --> 00:04:18,640
不正常的一個提權的手段

77
00:04:18,640 --> 00:04:21,640
那這邊的話就是利用linux kernel的一個

78
00:04:21,640 --> 00:04:24,640
就是的一個vulnerability來去做提權

79
00:04:24,640 --> 00:04:29,640
那我們來看一下我們到底是用到哪一個就是漏洞的部分

80
00:04:29,640 --> 00:04:32,640
ok那這邊我們用到的就是我們標題所說到的dirtypy這個漏洞

81
00:04:32,640 --> 00:04:34,640
那這個漏洞的話它是

82
00:04:34,640 --> 00:04:37,640
因為通常我們在去講漏洞的時候我們會提到一個編號

83
00:04:37,640 --> 00:04:41,640
就是代表這個漏洞那它是cv20220847

84
00:04:41,640 --> 00:04:45,640
那大家就可以去有空就可以去看一下cv到底是什麼一個概念

85
00:04:45,640 --> 00:04:49,640
它其實就是一個漏洞的管理的一個資料庫這樣

86
00:04:49,640 --> 00:04:51,640
那它後來是一個linux kernel的漏洞

87
00:04:51,640 --> 00:04:54,640
那它這個漏洞能做的事情就是可以去對一個reonly file

88
00:04:54,640 --> 00:04:56,640
可以去做就是任意寫

89
00:04:56,640 --> 00:04:59,640
也就是因為你們通常應該有寫過

90
00:04:59,640 --> 00:05:03,640
就是對file的就是去做rewrite的部分就知道

91
00:05:03,640 --> 00:05:07,640
如果你去open一個file是reonly的一個權限

92
00:05:07,640 --> 00:05:08,640
那你是沒辦法去做rewrite的

93
00:05:08,640 --> 00:05:12,640
但在這個漏洞下你可以去對一個reonly的file

94
00:05:12,640 --> 00:05:14,640
去做一個就是寫入的部分

95
00:05:14,640 --> 00:05:18,640
但它就還是會有一些限制

96
00:05:18,640 --> 00:05:21,640
就是你至少還是要能夠去對一個file去進行open和read

97
00:05:21,640 --> 00:05:24,640
而且它一次就只能去寫一個page的size

98
00:05:24,640 --> 00:05:26,640
也就是0x4096這個大小

99
00:05:26,640 --> 00:05:28,640
0x100就是4096這個大小的size

100
00:05:28,640 --> 00:05:32,640
而且它就是每一個page就是第一個byte是沒辦法去寫的

101
00:05:32,640 --> 00:05:34,640
會有這樣的一個限制

102
00:05:34,640 --> 00:05:38,640
但它其實還是在linux上還蠻好用的

103
00:05:38,640 --> 00:05:40,640
就是因為sudo它是一個ELF

104
00:05:40,640 --> 00:05:42,640
就是如果大家知道的話就是

105
00:05:42,640 --> 00:05:45,640
ELF就是一個可以執行檔案的一個格式

106
00:05:45,640 --> 00:05:48,640
那這個格式裡面就會帶有就是一個片段

107
00:05:48,640 --> 00:05:52,640
就是代表著你現在準備要執行的那個code

108
00:05:52,640 --> 00:05:53,640
那我們就可以直接

109
00:05:53,640 --> 00:05:56,640
然後這個突然這個檔案它會是一個reonly的檔案

110
00:05:56,640 --> 00:05:58,640
那這樣我可以去對reonly的檔案去寫的話

111
00:05:58,640 --> 00:06:02,640
我們就可以今天把這個檔案把它寫成就是

112
00:06:02,640 --> 00:06:05,640
讓它就直接去set euid

113
00:06:05,640 --> 00:06:07,640
不做檢查你是不是sudo了

114
00:06:07,640 --> 00:06:09,640
也不去檢查你有沒有password

115
00:06:09,640 --> 00:06:12,640
直接去做提升權限到root的部分

116
00:06:12,640 --> 00:06:14,640
對這樣就可以直接去做就是

117
00:06:14,640 --> 00:06:17,640
拿到就是root的權限了

118
00:06:17,640 --> 00:06:18,640
沒錯

119
00:06:18,640 --> 00:06:21,640
所以在linux上的就是非法提前就這麼簡單

120
00:06:21,640 --> 00:06:22,640
對

121
00:06:22,640 --> 00:06:24,640
我就只要去找到sudo這個binary

122
00:06:24,640 --> 00:06:25,640
把它的code改一下

123
00:06:25,640 --> 00:06:28,640
然後其實那個要改code網路上都找得到

124
00:06:28,640 --> 00:06:30,640
對就稍微複製貼上改一下

125
00:06:30,640 --> 00:06:31,640
然後就可以去提權了

126
00:06:31,640 --> 00:06:32,640
對

127
00:06:32,640 --> 00:06:36,640
ok那接著要講android的部分就先交給李恩

128
00:06:36,640 --> 00:06:39,640
好那我們剛剛看完了

129
00:06:39,640 --> 00:06:42,640
我們在一般linux後上用dirty pipe提權方式

130
00:06:42,640 --> 00:06:43,640
其實是很簡單

131
00:06:43,640 --> 00:06:45,640
那我們接下來就是換到android環境

132
00:06:45,640 --> 00:06:49,640
那在android環境其實就是沒有一般linux上

133
00:06:49,640 --> 00:06:51,640
像是有suid flag的binary

134
00:06:51,640 --> 00:06:53,640
像是沒有sudo binary沒有su binary

135
00:06:53,640 --> 00:06:55,640
那的話我們就要思考一個問題說

136
00:06:55,640 --> 00:06:57,640
那我們還有什麼方式來能夠提權

137
00:06:57,640 --> 00:07:00,640
那第二點就是我們對於環境的可能會比較陌生

138
00:07:00,640 --> 00:07:02,640
可能會遇到像是debug的問題

139
00:07:02,640 --> 00:07:03,640
然後架構上的問題

140
00:07:03,640 --> 00:07:06,640
那我們這些問題也是我們需要處理的

141
00:07:06,640 --> 00:07:08,640
那第三點就是魔王守門員

142
00:07:08,640 --> 00:07:10,640
就是其實android的系統底層

143
00:07:10,640 --> 00:07:13,640
它裡面是有一個叫做SE linux的保護機制

144
00:07:13,640 --> 00:07:18,640
那這個東西其實是非常的頭痛的東西

145
00:07:18,640 --> 00:07:20,640
那我們就來想想看有什麼想法

146
00:07:20,640 --> 00:07:22,640
那我們的第一個想法可能是

147
00:07:22,640 --> 00:07:24,640
如果我們人在android的系統上

148
00:07:24,640 --> 00:07:27,640
我們能夠控制到一支比較高權限的process的話

149
00:07:27,640 --> 00:07:30,640
那我們是不是就有比較高的權限了

150
00:07:30,640 --> 00:07:32,640
那其實在理論上手機一開機

151
00:07:32,640 --> 00:07:35,640
或是系統一開機都會有一些程式執行

152
00:07:35,640 --> 00:07:37,640
那執行的時候應該是那些東西都是

153
00:07:37,640 --> 00:07:40,640
帶有比較高權限的process

154
00:07:40,640 --> 00:07:42,640
所以我們可能就會選擇像是init啊

155
00:07:42,640 --> 00:07:45,640
或是什麼uid之類的process

156
00:07:45,640 --> 00:07:48,640
那我們接下來就是想辦法去寫一些檔案

157
00:07:48,640 --> 00:07:49,640
就是我們用3dpy

158
00:07:49,640 --> 00:07:51,640
我們可以去對readonly的檔案進行寫入

159
00:07:51,640 --> 00:07:53,640
那我們就去寫一些檔案

160
00:07:53,640 --> 00:07:56,640
那我們嘗試來改變到這些process的執行流程

161
00:07:56,640 --> 00:08:00,640
進而來控制它

162
00:08:00,640 --> 00:08:01,640
好 那我們要怎麼做

163
00:08:01,640 --> 00:08:04,640
我們首先要先決定我們要解釋的process

164
00:08:04,640 --> 00:08:06,640
那我們這邊選擇的是init process

165
00:08:06,640 --> 00:08:10,640
也就是手機一開機第一支執行的process

166
00:08:10,640 --> 00:08:12,640
那init除了有root的權限以外

167
00:08:12,640 --> 00:08:14,640
其實它在s-linear上有一些

168
00:08:14,640 --> 00:08:17,640
它路上有一些還不錯而且很好用的東西

169
00:08:17,640 --> 00:08:19,640
以及我們在bypass

170
00:08:19,640 --> 00:08:23,640
把s-linear繞掉的時候會很方便的一個路

171
00:08:23,640 --> 00:08:26,640
那在後面會再介紹到

172
00:08:26,640 --> 00:08:28,640
那第三個就是我們要想我們要怎麼做

173
00:08:28,640 --> 00:08:30,640
我們要怎麼解釋

174
00:08:30,640 --> 00:08:33,640
可是我們剛剛講到的是什麼

175
00:08:33,640 --> 00:08:35,640
s-linear

176
00:08:35,640 --> 00:08:37,640
它其實就是一個非常噁心

177
00:08:37,640 --> 00:08:39,640
就是它policy跟那個rule之類的

178
00:08:39,640 --> 00:08:41,640
都是非常討人厭的

179
00:08:41,640 --> 00:08:43,640
所以很多人聽到這個字

180
00:08:43,640 --> 00:08:47,640
身體就會抖一下這樣子

181
00:08:47,640 --> 00:08:49,640
來到我們解釋process的部分

182
00:08:49,640 --> 00:08:51,640
那我們可以從漏洞可以做到的事情

183
00:08:51,640 --> 00:08:53,640
開始思考說

184
00:08:53,640 --> 00:08:56,640
怎麼解釋才是一個我們可以做到的事情

185
00:08:56,640 --> 00:08:58,640
那我們要解釋的process

186
00:08:58,640 --> 00:09:01,640
我們必須要先對這支process有一定程度的了解

187
00:09:01,640 --> 00:09:04,640
我們要去追一下這支process可能會做哪些事情

188
00:09:04,640 --> 00:09:06,640
那以及這支process它有沒有

189
00:09:06,640 --> 00:09:07,640
它可能用了哪些東西

190
00:09:07,640 --> 00:09:11,640
像是用了哪個library之類的

191
00:09:11,640 --> 00:09:13,640
那initprocess就是它開機完以後

192
00:09:13,640 --> 00:09:15,640
它會進入到一個while loop的狀態

193
00:09:15,640 --> 00:09:18,640
它就是一直在那邊睡覺等待一些事件的觸發

194
00:09:18,640 --> 00:09:21,640
那並且init是一支C++所編譯出來的binary

195
00:09:21,640 --> 00:09:23,640
所以說它就有lib

196
00:09:23,640 --> 00:09:27,640
它一定會用到libc++的function

197
00:09:27,640 --> 00:09:30,640
所以我們就可以嘗試去改libc++.so

198
00:09:30,640 --> 00:09:33,640
這個shared library

199
00:09:33,640 --> 00:09:34,640
那接下來就是看看說

200
00:09:34,640 --> 00:09:36,640
我們用什麼方式可以觸發到它的事件

201
00:09:36,640 --> 00:09:37,640
讓它起床

202
00:09:37,640 --> 00:09:41,640
就是讓它wake起來

203
00:09:41,640 --> 00:09:43,640
那我們接下來就是來劫持它

204
00:09:43,640 --> 00:09:46,640
那我們發現到說

205
00:09:46,640 --> 00:09:48,640
我們可以用cplot這個convent

206
00:09:48,640 --> 00:09:49,640
可以讓init的醒來

207
00:09:49,640 --> 00:09:50,640
就是它在醒來以後

208
00:09:50,640 --> 00:09:52,640
它就處理一些事件

209
00:09:52,640 --> 00:09:54,640
那它其實就是會跟它

210
00:09:54,640 --> 00:09:57,640
所listen的file destructor進行溝通

211
00:09:57,640 --> 00:09:59,640
那我們就是去看

212
00:09:59,640 --> 00:10:01,640
它在處理事件的地方

213
00:10:01,640 --> 00:10:06,640
有沒有用到libc++.so的function

214
00:10:06,640 --> 00:10:09,640
那其實在改library的時候

215
00:10:09,640 --> 00:10:10,640
我們會需要注意到一點

216
00:10:10,640 --> 00:10:12,640
就是我們希望我們改到的內容

217
00:10:12,640 --> 00:10:13,640
其實是越少越好

218
00:10:13,640 --> 00:10:15,640
畢竟我們改library的話

219
00:10:15,640 --> 00:10:17,640
其他process或其他service

220
00:10:17,640 --> 00:10:19,640
它用到這個library的時候

221
00:10:19,640 --> 00:10:21,640
它可能也會有一些問題

222
00:10:21,640 --> 00:10:23,640
那可能導致直接手機壞掉

223
00:10:23,640 --> 00:10:25,640
或者是它就直接reboot

224
00:10:25,640 --> 00:10:27,640
那要一步一步去debug

225
00:10:27,640 --> 00:10:28,640
會變得很麻煩

226
00:10:28,640 --> 00:10:29,640
所以我們會希望說

227
00:10:29,640 --> 00:10:30,640
我們改到的code

228
00:10:30,640 --> 00:10:34,640
其實比較少一點會比較好

229
00:10:34,640 --> 00:10:35,640
那接下來就直接講到

230
00:10:35,640 --> 00:10:37,640
我們改的target

231
00:10:37,640 --> 00:10:38,640
我們直接去改的是

232
00:10:38,640 --> 00:10:41,640
iOS base init這個function

233
00:10:41,640 --> 00:10:43,640
我們就改它jump

234
00:10:43,640 --> 00:10:45,640
就是它下面紅色框

235
00:10:45,640 --> 00:10:46,640
那個jump的introduction

236
00:10:46,640 --> 00:10:48,640
它原本預期會jump到

237
00:10:48,640 --> 00:10:50,640
一個locate這個function

238
00:10:50,640 --> 00:10:51,640
那我們直接讓它

239
00:10:51,640 --> 00:10:52,640
jump到我們的shellcode上

240
00:10:52,640 --> 00:10:53,640
我們用derivative

241
00:10:53,640 --> 00:10:54,640
直接寫五個byte

242
00:10:54,640 --> 00:10:56,640
讓它jump到我們的shellcode上

243
00:10:56,640 --> 00:10:57,640
那我們shellcode

244
00:10:57,640 --> 00:10:59,640
放的位置是哪裡呢

245
00:10:59,640 --> 00:11:00,640
我們shellcode放的是

246
00:11:00,640 --> 00:11:02,640
cxiv cdelete的這個function上

247
00:11:02,640 --> 00:11:04,640
那為什麼會選擇這一塊

248
00:11:04,640 --> 00:11:06,640
是因為說我們在經過測試的時候

249
00:11:06,640 --> 00:11:08,640
我們發現說我們把

250
00:11:08,640 --> 00:11:09,640
shellcode放在上面

251
00:11:09,640 --> 00:11:12,640
它不會有任何系統crash的事情

252
00:11:12,640 --> 00:11:13,640
意思就是說

253
00:11:13,640 --> 00:11:14,640
可能其他的service

254
00:11:14,640 --> 00:11:15,640
或者是什麼process

255
00:11:15,640 --> 00:11:18,640
幾乎不會call到這個function

256
00:11:18,640 --> 00:11:20,640
好 那我們exploit

257
00:11:20,640 --> 00:11:22,640
想要在CI裡面

258
00:11:22,640 --> 00:11:23,640
為所欲為的話

259
00:11:23,640 --> 00:11:24,640
我們可以先把shellcode

260
00:11:24,640 --> 00:11:25,640
先丟上去

261
00:11:25,640 --> 00:11:27,640
因為它完全不會壞掉

262
00:11:27,640 --> 00:11:28,640
那我們再透過derivative

263
00:11:28,640 --> 00:11:31,640
把iOS base init的jump指令改掉

264
00:11:31,640 --> 00:11:35,640
讓它jump到我們的shellcode上

265
00:11:35,640 --> 00:11:37,640
那我們以圖來稍微說明

266
00:11:37,640 --> 00:11:38,640
就是這樣

267
00:11:38,640 --> 00:11:39,640
我們一開始淺藍色那一塊

268
00:11:39,640 --> 00:11:41,640
就是我們先把shellcode丟上去

269
00:11:41,640 --> 00:11:42,640
那shellcode丟上去以後

270
00:11:42,640 --> 00:11:44,640
我們就去改

271
00:11:44,640 --> 00:11:46,640
那個iOS base init這個function

272
00:11:46,640 --> 00:11:48,640
我們就讓它jump到我們的shellcode上

273
00:11:48,640 --> 00:11:49,640
所以就是一個蠻簡單的

274
00:11:49,640 --> 00:11:53,640
jump throw的attack

275
00:11:53,640 --> 00:11:55,640
好 那整個劫持過程是這樣子的

276
00:11:55,640 --> 00:11:56,640
是我們在一般的

277
00:11:56,640 --> 00:11:58,640
使用者的情況下

278
00:11:58,640 --> 00:12:00,640
我們shell user我們是

279
00:12:00,640 --> 00:12:02,640
做separate command的時候

280
00:12:02,640 --> 00:12:03,640
它會觸發到

281
00:12:03,640 --> 00:12:05,640
se-permission的error

282
00:12:05,640 --> 00:12:07,640
那觸發到se-permission error的時候

283
00:12:07,640 --> 00:12:08,640
它系統上會有

284
00:12:08,640 --> 00:12:10,640
會嘗試想要把這個

285
00:12:10,640 --> 00:12:11,640
這個狀態記錄起來

286
00:12:11,640 --> 00:12:12,640
所以它會call到

287
00:12:12,640 --> 00:12:13,640
log message的這個function

288
00:12:13,640 --> 00:12:14,640
那call到log message的function

289
00:12:14,640 --> 00:12:15,640
它跟IO相關

290
00:12:15,640 --> 00:12:16,640
所以它就是會再call到

291
00:12:16,640 --> 00:12:18,640
iOS base init

292
00:12:18,640 --> 00:12:19,640
那iOS base init這個function

293
00:12:19,640 --> 00:12:20,640
就是已經被我們改掉

294
00:12:20,640 --> 00:12:22,640
會去jump到我們shellcode上了

295
00:12:22,640 --> 00:12:23,640
所以我們就是會

296
00:12:23,640 --> 00:12:25,640
jump到我們shellcode上

297
00:12:25,640 --> 00:12:26,640
好 那我們shellcode

298
00:12:26,640 --> 00:12:28,640
做了些什麼事情呢

299
00:12:28,640 --> 00:12:29,640
那我們shellcode

300
00:12:29,640 --> 00:12:31,640
首先我們會先去檢查

301
00:12:31,640 --> 00:12:32,640
當下的register

302
00:12:32,640 --> 00:12:33,640
就是我們會把

303
00:12:33,640 --> 00:12:35,640
我們會先把當下的register存下來

304
00:12:35,640 --> 00:12:37,640
然後拿到當下的RIP

305
00:12:37,640 --> 00:12:38,640
然後我們會去檢查

306
00:12:38,640 --> 00:12:40,640
PID是不是init process

307
00:12:40,640 --> 00:12:42,640
那如果不是init process的話

308
00:12:42,640 --> 00:12:43,640
我們就直接透過jump的方式

309
00:12:43,640 --> 00:12:44,640
直接return回去

310
00:12:44,640 --> 00:12:45,640
它原本要去的那個

311
00:12:45,640 --> 00:12:47,640
locate的那個function

312
00:12:47,640 --> 00:12:48,640
那如果是init process的話

313
00:12:48,640 --> 00:12:50,640
就是我們要劫持的目標的話

314
00:12:50,640 --> 00:12:51,640
我們就直接fork出來

315
00:12:51,640 --> 00:12:53,640
那我們fork出一隻

316
00:12:53,640 --> 00:12:55,640
我們就把它init fork出來

317
00:12:55,640 --> 00:12:57,640
那它會去nmap

318
00:12:57,640 --> 00:12:58,640
libui.so進來

319
00:12:58,640 --> 00:12:59,640
那為什麼會nmap

320
00:12:59,640 --> 00:13:00,640
libui.so進來

321
00:13:00,640 --> 00:13:02,640
libui.so進來是因為init process

322
00:13:02,640 --> 00:13:03,640
它沒有用到libui.so

323
00:13:03,640 --> 00:13:05,640
那並且說我們會需要

324
00:13:05,640 --> 00:13:06,640
用到第二段的export

325
00:13:06,640 --> 00:13:08,640
在init的權限下執行

326
00:13:08,640 --> 00:13:09,640
所以說我們還有再把

327
00:13:09,640 --> 00:13:10,640
第二階段的export

328
00:13:10,640 --> 00:13:11,640
寫到libui.so

329
00:13:11,640 --> 00:13:13,640
讓它跳過來執行

330
00:13:13,640 --> 00:13:15,640
那後面我們就直接

331
00:13:15,640 --> 00:13:17,640
jump到libui.so上了嘛

332
00:13:17,640 --> 00:13:18,640
那libui.so執行

333
00:13:18,640 --> 00:13:19,640
我們export2的時候

334
00:13:19,640 --> 00:13:24,640
就是帶有init的權限執行的

335
00:13:24,640 --> 00:13:25,640
好那等一下

336
00:13:25,640 --> 00:13:26,640
接下來要講到s-init的部分

337
00:13:26,640 --> 00:13:29,640
我們再還給以莫

338
00:13:29,640 --> 00:13:30,640
那其實大家剛才聽下來

339
00:13:30,640 --> 00:13:33,640
就可以知道就是

340
00:13:33,640 --> 00:13:34,640
我們在做export的時候

341
00:13:34,640 --> 00:13:36,640
就是要對一些背景的知識

342
00:13:36,640 --> 00:13:37,640
要比較熟一點

343
00:13:37,640 --> 00:13:38,640
對就像是我們在去做

344
00:13:38,640 --> 00:13:40,640
Linux上的題權部分

345
00:13:40,640 --> 00:13:41,640
那我們就是要對

346
00:13:41,640 --> 00:13:42,640
Linux上像是一些

347
00:13:42,640 --> 00:13:44,640
system code之類的

348
00:13:44,640 --> 00:13:45,640
那要夠熟

349
00:13:45,640 --> 00:13:46,640
才可以就是可以比較

350
00:13:46,640 --> 00:13:49,640
了解我們剛才在講什麼這樣

351
00:13:49,640 --> 00:13:50,640
那因為接下來我們要繼續

352
00:13:50,640 --> 00:13:52,640
對s-init去進行export

353
00:13:52,640 --> 00:13:53,640
所以接下來要先

354
00:13:53,640 --> 00:13:54,640
就帶大家認識一下

355
00:13:54,640 --> 00:13:55,640
s-init的部分

356
00:13:55,640 --> 00:13:58,640
就希望大家撐住

357
00:13:58,640 --> 00:13:59,640
那s-init的話

358
00:13:59,640 --> 00:14:01,640
它其實是一個就是一個

359
00:14:01,640 --> 00:14:03,640
去做權限管控的一個方法

360
00:14:03,640 --> 00:14:04,640
然後它的做法是

361
00:14:04,640 --> 00:14:06,640
以白名單的方式去做

362
00:14:06,640 --> 00:14:07,640
就像是你可以去看到

363
00:14:07,640 --> 00:14:10,640
你在一個Linux系統上

364
00:14:10,640 --> 00:14:12,640
Linux系統上就是會有

365
00:14:12,640 --> 00:14:14,640
你的答案會有一些

366
00:14:14,640 --> 00:14:15,640
可以去表示它

367
00:14:15,640 --> 00:14:17,640
就是你的group user

368
00:14:17,640 --> 00:14:18,640
可以有open rewrite

369
00:14:18,640 --> 00:14:19,640
哪一些權限

370
00:14:19,640 --> 00:14:20,640
應該是rxw

371
00:14:20,640 --> 00:14:21,640
rwx的權限

372
00:14:21,640 --> 00:14:23,640
對就像那個機制一樣

373
00:14:23,640 --> 00:14:24,640
它就是一個去

374
00:14:24,640 --> 00:14:25,640
管理答案權限

375
00:14:25,640 --> 00:14:26,640
可不可以去就是

376
00:14:26,640 --> 00:14:28,640
SS的一個機制

377
00:14:28,640 --> 00:14:29,640
那它的做法

378
00:14:29,640 --> 00:14:31,640
因為它是要用白名單

379
00:14:31,640 --> 00:14:33,640
所以就是我們會要去設定

380
00:14:33,640 --> 00:14:35,640
非常非常多的白名單的

381
00:14:35,640 --> 00:14:36,640
Lore來去限制說

382
00:14:36,640 --> 00:14:37,640
我這個系統上

383
00:14:37,640 --> 00:14:38,640
到底有哪些的

384
00:14:38,640 --> 00:14:39,640
就是權限

385
00:14:39,640 --> 00:14:40,640
就是哪些process

386
00:14:40,640 --> 00:14:41,640
可以對哪些file

387
00:14:41,640 --> 00:14:42,640
去進行open rew

388
00:14:42,640 --> 00:14:44,640
就是rwx的部分

389
00:14:44,640 --> 00:14:46,640
那並且因為它白名單

390
00:14:46,640 --> 00:14:48,640
所以就一定要有一個context

391
00:14:48,640 --> 00:14:49,640
就是一個名文來表示說

392
00:14:49,640 --> 00:14:51,640
就是有沒有一個

393
00:14:51,640 --> 00:14:53,640
就是有沒有一個權限存在了

394
00:14:53,640 --> 00:14:55,640
不然就是一律都是

395
00:14:55,640 --> 00:14:57,640
你不代表你沒有權限

396
00:14:57,640 --> 00:14:58,640
那就像是

397
00:14:58,640 --> 00:14:59,640
我們剛才提到的就是

398
00:14:59,640 --> 00:15:00,640
我們會要去hydrate

399
00:15:00,640 --> 00:15:01,640
init這個process

400
00:15:01,640 --> 00:15:02,640
那init這個process的話

401
00:15:02,640 --> 00:15:03,640
它就是會

402
00:15:03,640 --> 00:15:04,640
可以對system file

403
00:15:04,640 --> 00:15:06,640
帶有這個

404
00:15:06,640 --> 00:15:08,640
就是我們叫context

405
00:15:08,640 --> 00:15:09,640
就是帶有這個

406
00:15:09,640 --> 00:15:10,640
屬性的一個

407
00:15:10,640 --> 00:15:11,640
label的一個檔案

408
00:15:11,640 --> 00:15:13,640
它有open rew的一個權限

409
00:15:13,640 --> 00:15:14,640
對

410
00:15:14,640 --> 00:15:15,640
那它就只有open rew

411
00:15:15,640 --> 00:15:16,640
這樣的權限

412
00:15:16,640 --> 00:15:17,640
那你可能想要去

413
00:15:17,640 --> 00:15:18,640
對它做execute

414
00:15:18,640 --> 00:15:19,640
那就它沒有權限

415
00:15:19,640 --> 00:15:20,640
那它就會去

416
00:15:20,640 --> 00:15:21,640
表示說你沒有權限

417
00:15:21,640 --> 00:15:23,640
然後你就沒辦法做這樣

418
00:15:23,640 --> 00:15:24,640
對

419
00:15:24,640 --> 00:15:25,640
那除此之外就是

420
00:15:25,640 --> 00:15:26,640
我們會有一個

421
00:15:26,640 --> 00:15:27,640
就可能後續會一直聽到

422
00:15:27,640 --> 00:15:28,640
一個名詞叫policy

423
00:15:28,640 --> 00:15:29,640
但是policy的話

424
00:15:29,640 --> 00:15:30,640
其實就是

425
00:15:30,640 --> 00:15:31,640
我這個系統上

426
00:15:31,640 --> 00:15:32,640
所有的rule就是說

427
00:15:32,640 --> 00:15:33,640
規則的集合

428
00:15:33,640 --> 00:15:34,640
也就是我這個系統上

429
00:15:34,640 --> 00:15:35,640
就所有的權限

430
00:15:35,640 --> 00:15:36,640
到底有哪些的意思

431
00:15:36,640 --> 00:15:37,640
對

432
00:15:37,640 --> 00:15:38,640
好 還有一條

433
00:15:38,640 --> 00:15:39,640
就是比較特別的rule

434
00:15:39,640 --> 00:15:40,640
叫做transition

435
00:15:40,640 --> 00:15:41,640
那這條rule的話

436
00:15:41,640 --> 00:15:42,640
其實它的作用是這樣的

437
00:15:42,640 --> 00:15:44,640
就是在通常情況下

438
00:15:44,640 --> 00:15:45,640
我們有一個process

439
00:15:45,640 --> 00:15:46,640
它可以去對

440
00:15:46,640 --> 00:15:47,640
某些特定的context

441
00:15:47,640 --> 00:15:48,640
去做一些

442
00:15:48,640 --> 00:15:49,640
它有的操作

443
00:15:49,640 --> 00:15:50,640
但我要去改變

444
00:15:50,640 --> 00:15:51,640
我當前process的權限

445
00:15:51,640 --> 00:15:52,640
要怎麼辦

446
00:15:52,640 --> 00:15:53,640
那這樣的做法

447
00:15:53,640 --> 00:15:55,640
它在ACNAS的做法是這樣

448
00:15:55,640 --> 00:15:56,640
就是當我的

449
00:15:56,640 --> 00:15:58,640
當前權限去

450
00:15:58,640 --> 00:15:59,640
一插ACB

451
00:15:59,640 --> 00:16:00,640
另外一個

452
00:16:00,640 --> 00:16:02,640
在我另外一個context的答案的時候

453
00:16:02,640 --> 00:16:04,640
如果有一條transition rule的話

454
00:16:04,640 --> 00:16:05,640
那我就會轉換到

455
00:16:05,640 --> 00:16:06,640
就是那個

456
00:16:06,640 --> 00:16:09,640
那條rule所指定的context

457
00:16:09,640 --> 00:16:11,640
就是所指定的那個權限

458
00:16:11,640 --> 00:16:12,640
那我就會換到

459
00:16:12,640 --> 00:16:13,640
另外一個權限

460
00:16:13,640 --> 00:16:14,640
去執行我接下來

461
00:16:14,640 --> 00:16:15,640
一插ACB的那個答案

462
00:16:15,640 --> 00:16:16,640
對

463
00:16:16,640 --> 00:16:17,640
那這樣我就可以做到

464
00:16:17,640 --> 00:16:18,640
一個權限答案的部分

465
00:16:18,640 --> 00:16:19,640
改變我當前權限的

466
00:16:19,640 --> 00:16:20,640
一個部分

467
00:16:20,640 --> 00:16:23,640
那ACNAS當然就是

468
00:16:23,640 --> 00:16:24,640
稍微講一下

469
00:16:24,640 --> 00:16:25,640
它的一些優缺點的部分

470
00:16:25,640 --> 00:16:26,640
那它優點的話其實就是

471
00:16:26,640 --> 00:16:28,640
它可以做到非常精確的

472
00:16:28,640 --> 00:16:29,640
一個權限管控

473
00:16:29,640 --> 00:16:30,640
就我每一個

474
00:16:30,640 --> 00:16:31,640
你要做什麼操作

475
00:16:31,640 --> 00:16:32,640
都要有一條rule去表示

476
00:16:32,640 --> 00:16:33,640
你可以做你想做

477
00:16:33,640 --> 00:16:34,640
這就非常一個

478
00:16:34,640 --> 00:16:36,640
強烈的一個權限管控部分

479
00:16:36,640 --> 00:16:37,640
那如果它就是會解決一個

480
00:16:37,640 --> 00:16:39,640
ACNAS上一個很大問題

481
00:16:39,640 --> 00:16:40,640
就是我們前天提到

482
00:16:40,640 --> 00:16:41,640
root超強

483
00:16:41,640 --> 00:16:42,640
對

484
00:16:42,640 --> 00:16:43,640
那這邊就可以解決說

485
00:16:43,640 --> 00:16:44,640
就是因為它把權限

486
00:16:44,640 --> 00:16:46,640
分成了很多條rule來去管理

487
00:16:46,640 --> 00:16:48,640
所以那個root的部分

488
00:16:48,640 --> 00:16:49,640
就沒有那麼強的權限

489
00:16:49,640 --> 00:16:50,640
我怎麼都可以做

490
00:16:50,640 --> 00:16:51,640
對

491
00:16:51,640 --> 00:16:52,640
那缺點的部分

492
00:16:52,640 --> 00:16:53,640
第一個的話就是

493
00:16:53,640 --> 00:16:54,640
它的rule很難設定

494
00:16:54,640 --> 00:16:55,640
就是因為說

495
00:16:55,640 --> 00:16:56,640
要設定rule超級多

496
00:16:56,640 --> 00:16:57,640
對

497
00:16:57,640 --> 00:16:58,640
另外一個部分的話就是

498
00:16:58,640 --> 00:17:00,640
你在之後

499
00:17:00,640 --> 00:17:02,640
如果你拿到一台機器

500
00:17:02,640 --> 00:17:03,640
那機器上有ACNAS

501
00:17:03,640 --> 00:17:05,640
然後你想要去做

502
00:17:05,640 --> 00:17:06,640
輸出apt install

503
00:17:06,640 --> 00:17:07,640
然後你就會發現它爛掉了

504
00:17:07,640 --> 00:17:08,640
對

505
00:17:08,640 --> 00:17:09,640
因為你的輸出

506
00:17:09,640 --> 00:17:10,640
就不像之前那麼強了

507
00:17:10,640 --> 00:17:11,640
沒有錯

508
00:17:11,640 --> 00:17:12,640
就會有這樣的一個問題

509
00:17:12,640 --> 00:17:14,640
那對於這個機制的話

510
00:17:14,640 --> 00:17:16,640
其實ACNAS有其中兩個機制

511
00:17:16,640 --> 00:17:17,640
來去做解決

512
00:17:17,640 --> 00:17:18,640
第一個的話是

513
00:17:18,640 --> 00:17:19,640
enforce permissive

514
00:17:19,640 --> 00:17:20,640
另外一個的話是

515
00:17:20,640 --> 00:17:21,640
permissive domain

516
00:17:21,640 --> 00:17:22,640
那enforce permissive的部分就是

517
00:17:22,640 --> 00:17:25,640
我可以將我當前ACNAS的狀態

518
00:17:25,640 --> 00:17:26,640
設定成permissive

519
00:17:26,640 --> 00:17:27,640
那這意思就是

520
00:17:27,640 --> 00:17:30,640
接下來你要做操作

521
00:17:30,640 --> 00:17:31,640
ACNAS都不會阻擋你

522
00:17:31,640 --> 00:17:32,640
但我會留下log

523
00:17:32,640 --> 00:17:34,640
也就是你的這個系統上

524
00:17:34,640 --> 00:17:35,640
就只是多了一層

525
00:17:35,640 --> 00:17:37,640
會幫你log的一個ACNAS

526
00:17:37,640 --> 00:17:39,640
但剩下的情況就是跟

527
00:17:39,640 --> 00:17:40,640
沒有ACNAS的情況

528
00:17:40,640 --> 00:17:41,640
是一模一樣的

529
00:17:41,640 --> 00:17:42,640
對

530
00:17:42,640 --> 00:17:44,640
那就通常在Red Hat的

531
00:17:44,640 --> 00:17:45,640
換機是6.0的

532
00:17:45,640 --> 00:17:47,640
某一個教科書

533
00:17:47,640 --> 00:17:48,640
它的第一頁就是表示

534
00:17:48,640 --> 00:17:50,640
請關掉你的ACNAS

535
00:17:50,640 --> 00:17:51,640
把它設成permissive

536
00:17:51,640 --> 00:17:52,640
對

537
00:17:52,640 --> 00:17:53,640
所以就

538
00:17:53,640 --> 00:17:54,640
就還

539
00:17:54,640 --> 00:17:56,640
而且Red Hat是

540
00:17:56,640 --> 00:17:57,640
ACNAS的

541
00:17:57,640 --> 00:17:59,640
就是管理的公司

542
00:17:59,640 --> 00:18:00,640
對

543
00:18:00,640 --> 00:18:01,640
所以就還

544
00:18:01,640 --> 00:18:02,640
還蠻有趣的這樣

545
00:18:02,640 --> 00:18:03,640
然後另外一個的話

546
00:18:03,640 --> 00:18:04,640
就是有一個特別的入口

547
00:18:04,640 --> 00:18:05,640
叫permissive domain

548
00:18:05,640 --> 00:18:07,640
那它其實就是一個權限

549
00:18:07,640 --> 00:18:09,640
表示一個特別的權限

550
00:18:09,640 --> 00:18:11,640
那當你切換到這個權限下

551
00:18:11,640 --> 00:18:12,640
你的行為就跟

552
00:18:12,640 --> 00:18:14,640
enforce設成permissive是一樣的

553
00:18:14,640 --> 00:18:15,640
就是只會有log

554
00:18:15,640 --> 00:18:17,640
但是什麼操作都還是讓你過

555
00:18:17,640 --> 00:18:18,640
沒錯

556
00:18:18,640 --> 00:18:19,640
所以這邊就可以看到

557
00:18:19,640 --> 00:18:20,640
set enforced

558
00:18:20,640 --> 00:18:21,640
就是我把那個enforce

559
00:18:21,640 --> 00:18:22,640
設成permissive的意思

560
00:18:22,640 --> 00:18:23,640
對

561
00:18:23,640 --> 00:18:24,640
就大家都

562
00:18:24,640 --> 00:18:25,640
開機先看看就對了

563
00:18:25,640 --> 00:18:26,640
好

564
00:18:26,640 --> 00:18:27,640
但因為我們在Android上面

565
00:18:27,640 --> 00:18:29,640
它的那個ACNAS是沒辦法set

566
00:18:29,640 --> 00:18:30,640
就是

567
00:18:30,640 --> 00:18:31,640
就是一定是打開的

568
00:18:31,640 --> 00:18:33,640
所以我還是要想辦法去

569
00:18:33,640 --> 00:18:34,640
bypass它

570
00:18:34,640 --> 00:18:35,640
那我就接著來看一下

571
00:18:35,640 --> 00:18:37,640
它在kernel中的一些運作流程

572
00:18:37,640 --> 00:18:38,640
會是長這樣

573
00:18:38,640 --> 00:18:39,640
對

574
00:18:39,640 --> 00:18:40,640
那首先的話就是

575
00:18:40,640 --> 00:18:41,640
當你去做一些

576
00:18:41,640 --> 00:18:42,640
system code

577
00:18:42,640 --> 00:18:43,640
就是前面提到的

578
00:18:43,640 --> 00:18:44,640
這些system code的時候

579
00:18:44,640 --> 00:18:45,640
它其實會call到一個

580
00:18:45,640 --> 00:18:47,640
叫LSM hook的一個function

581
00:18:47,640 --> 00:18:48,640
而這個function

582
00:18:48,640 --> 00:18:49,640
它在第一層

583
00:18:49,640 --> 00:18:50,640
就在ACNAS這個環境下

584
00:18:50,640 --> 00:18:51,640
它就是對

585
00:18:51,640 --> 00:18:52,640
它就會去

586
00:18:52,640 --> 00:18:53,640
hook到就是

587
00:18:53,640 --> 00:18:54,640
ACNAS的function

588
00:18:54,640 --> 00:18:55,640
那第一層的

589
00:18:55,640 --> 00:18:57,640
這ACNAS的function呢

590
00:18:57,640 --> 00:18:58,640
就會去做的事情

591
00:18:58,640 --> 00:18:59,640
就是去收集一些

592
00:18:59,640 --> 00:19:00,640
我的一些

593
00:19:00,640 --> 00:19:01,640
所需要的一些資訊

594
00:19:01,640 --> 00:19:02,640
像是就是

595
00:19:02,640 --> 00:19:03,640
這邊提到

596
00:19:03,640 --> 00:19:04,640
SSID TSID

597
00:19:04,640 --> 00:19:05,640
class unpermitted

598
00:19:05,640 --> 00:19:06,640
還有requested的部分

599
00:19:06,640 --> 00:19:08,640
那這幾個東西其實就是

600
00:19:08,640 --> 00:19:09,640
SSID就是

601
00:19:09,640 --> 00:19:12,640
我現在這個process的權限

602
00:19:12,640 --> 00:19:13,640
TSID就是我

603
00:19:13,640 --> 00:19:14,640
這process要對

604
00:19:14,640 --> 00:19:15,640
哪一個檔案執行的

605
00:19:15,640 --> 00:19:16,640
就是那個檔案的權限

606
00:19:16,640 --> 00:19:17,640
是哪一個

607
00:19:17,640 --> 00:19:18,640
那接著

608
00:19:18,640 --> 00:19:19,640
好 接著的話就會去看

609
00:19:19,640 --> 00:19:20,640
我需要哪些權限

610
00:19:20,640 --> 00:19:21,640
就requested

611
00:19:21,640 --> 00:19:22,640
就是我會需要

612
00:19:22,640 --> 00:19:23,640
哪些權限的意思

613
00:19:23,640 --> 00:19:24,640
對 就是剛才提到

614
00:19:24,640 --> 00:19:25,640
open rewrite這三個權限

615
00:19:25,640 --> 00:19:26,640
對

616
00:19:26,640 --> 00:19:27,640
那就會把這些資訊

617
00:19:27,640 --> 00:19:28,640
就傳給到就是

618
00:19:28,640 --> 00:19:30,640
叫AVC has no audit

619
00:19:30,640 --> 00:19:31,640
的

620
00:19:31,640 --> 00:19:33,640
AVC has no audit

621
00:19:33,640 --> 00:19:34,640
不好意思口誤

622
00:19:34,640 --> 00:19:35,640
對 這個function

623
00:19:35,640 --> 00:19:36,640
那這function會做的事情

624
00:19:36,640 --> 00:19:37,640
就是實際的去

625
00:19:37,640 --> 00:19:38,640
去看說你有沒有權限的部分

626
00:19:38,640 --> 00:19:39,640
首先的話

627
00:19:39,640 --> 00:19:40,640
它就會先去做

628
00:19:40,640 --> 00:19:41,640
AVC lookup

629
00:19:41,640 --> 00:19:42,640
就去一個cache的空間

630
00:19:42,640 --> 00:19:43,640
去看說

631
00:19:43,640 --> 00:19:44,640
我這個判斷的情況

632
00:19:44,640 --> 00:19:45,640
有沒有

633
00:19:45,640 --> 00:19:46,640
之前有沒有提過

634
00:19:46,640 --> 00:19:47,640
如果

635
00:19:47,640 --> 00:19:48,640
如果之前有找過的話

636
00:19:48,640 --> 00:19:49,640
它就會留下一個cache

637
00:19:49,640 --> 00:19:50,640
在這邊

638
00:19:50,640 --> 00:19:51,640
來去知道就是

639
00:19:51,640 --> 00:19:52,640
你這個操作到

640
00:19:52,640 --> 00:19:53,640
有哪些權限

641
00:19:53,640 --> 00:19:54,640
如果沒有找過的話

642
00:19:54,640 --> 00:19:55,640
它就會再去call到

643
00:19:55,640 --> 00:19:56,640
security compute AV

644
00:19:56,640 --> 00:19:57,640
這個function

645
00:19:57,640 --> 00:19:58,640
這個function

646
00:19:58,640 --> 00:19:59,640
做的事情就是去

647
00:19:59,640 --> 00:20:00,640
policy那邊

648
00:20:00,640 --> 00:20:01,640
去把我這個

649
00:20:01,640 --> 00:20:02,640
當前這個執行

650
00:20:02,640 --> 00:20:03,640
TSID對應到

651
00:20:03,640 --> 00:20:04,640
SSID對應到

652
00:20:04,640 --> 00:20:05,640
TSID的這個操作

653
00:20:05,640 --> 00:20:07,640
所用的權限都找出來

654
00:20:07,640 --> 00:20:08,640
那到時候

655
00:20:08,640 --> 00:20:09,640
我就去用這個權限

656
00:20:09,640 --> 00:20:10,640
來去跟

657
00:20:10,640 --> 00:20:11,640
就是

658
00:20:11,640 --> 00:20:12,640
我這邊

659
00:20:12,640 --> 00:20:13,640
所需要requested的

660
00:20:13,640 --> 00:20:14,640
來去做比較

661
00:20:14,640 --> 00:20:15,640
如果requested

662
00:20:15,640 --> 00:20:16,640
需要超過這個權

663
00:20:16,640 --> 00:20:17,640
就是

664
00:20:17,640 --> 00:20:18,640
如果requested

665
00:20:18,640 --> 00:20:19,640
需要超過我

666
00:20:19,640 --> 00:20:20,640
所能夠擁有的權限的話

667
00:20:20,640 --> 00:20:21,640
它就會去call到

668
00:20:21,640 --> 00:20:23,640
AVC deny的

669
00:20:23,640 --> 00:20:24,640
將你的這個操作

670
00:20:24,640 --> 00:20:25,640
給否決掉

671
00:20:25,640 --> 00:20:26,640
對

672
00:20:26,640 --> 00:20:28,640
那AVC deny的

673
00:20:28,640 --> 00:20:29,640
對

674
00:20:29,640 --> 00:20:30,640
不好意思

675
00:20:30,640 --> 00:20:31,640
這邊要再講一下

676
00:20:31,640 --> 00:20:32,640
就是前面提到

677
00:20:32,640 --> 00:20:33,640
就是這個

678
00:20:33,640 --> 00:20:34,640
security compute AV

679
00:20:34,640 --> 00:20:35,640
它會做

680
00:20:35,640 --> 00:20:36,640
它會前面會call到一個

681
00:20:36,640 --> 00:20:37,640
叫EVMARGabit

682
00:20:37,640 --> 00:20:38,640
這個function

683
00:20:38,640 --> 00:20:39,640
這個function就會是

684
00:20:39,640 --> 00:20:40,640
等等我們

685
00:20:40,640 --> 00:20:41,640
就是要做bypass的部分

686
00:20:41,640 --> 00:20:42,640
要會用到一個function

687
00:20:42,640 --> 00:20:43,640
那接著我們回來講一下

688
00:20:43,640 --> 00:20:44,640
AVC deny

689
00:20:44,640 --> 00:20:45,640
那AVC deny

690
00:20:45,640 --> 00:20:46,640
它做的事情其實很簡單

691
00:20:46,640 --> 00:20:48,640
如果你有寫過C code的話

692
00:20:48,640 --> 00:20:49,640
就會知道就是

693
00:20:49,640 --> 00:20:51,640
它可能會有一些error

694
00:20:51,640 --> 00:20:52,640
就是

695
00:20:52,640 --> 00:20:54,640
大家應該知道error

696
00:20:54,640 --> 00:20:55,640
error number這東西

697
00:20:55,640 --> 00:20:56,640
對

698
00:20:56,640 --> 00:20:57,640
那它在AVC deny

699
00:20:57,640 --> 00:20:58,640
在做的事情就是

700
00:20:58,640 --> 00:20:59,640
return一個error number

701
00:20:59,640 --> 00:21:00,640
表示你沒有權限這樣

702
00:21:00,640 --> 00:21:01,640
對

703
00:21:01,640 --> 00:21:02,640
但它有兩個情況

704
00:21:02,640 --> 00:21:03,640
就是

705
00:21:03,640 --> 00:21:04,640
會是returning

706
00:21:04,640 --> 00:21:05,640
也就是代表著

707
00:21:05,640 --> 00:21:06,640
因為通常returning就代表

708
00:21:06,640 --> 00:21:07,640
這操作成功了

709
00:21:07,640 --> 00:21:08,640
你有權限這樣

710
00:21:08,640 --> 00:21:09,640
對

711
00:21:09,640 --> 00:21:10,640
它有兩個情況是returning的

712
00:21:10,640 --> 00:21:11,640
第二的話就是

713
00:21:11,640 --> 00:21:12,640
它會去

714
00:21:12,640 --> 00:21:13,640
但你

715
00:21:13,640 --> 00:21:14,640
它會去判斷說

716
00:21:14,640 --> 00:21:15,640
enforce

717
00:21:15,640 --> 00:21:16,640
enable return false的情況

718
00:21:16,640 --> 00:21:17,640
它會returning

719
00:21:17,640 --> 00:21:18,640
那這情況其實就是

720
00:21:18,640 --> 00:21:20,640
對應到我們前面提到的

721
00:21:20,640 --> 00:21:22,640
enforce permissive的這個情況

722
00:21:22,640 --> 00:21:23,640
對

723
00:21:23,640 --> 00:21:24,640
但它會需要就是

724
00:21:24,640 --> 00:21:25,640
在去編譯gernode的時候

725
00:21:25,640 --> 00:21:27,640
會需要帶一個config在裡面

726
00:21:27,640 --> 00:21:29,640
它這個情況才有可能會是true

727
00:21:29,640 --> 00:21:30,640
那另外一個情況的話就是

728
00:21:30,640 --> 00:21:32,640
我afd flag帶有

729
00:21:32,640 --> 00:21:34,640
就是

730
00:21:34,640 --> 00:21:35,640
no

731
00:21:35,640 --> 00:21:36,640
對

732
00:21:36,640 --> 00:21:37,640
稍微看一下

733
00:21:37,640 --> 00:21:38,640
afd flag permissive

734
00:21:38,640 --> 00:21:39,640
這個flag

735
00:21:39,640 --> 00:21:40,640
對

736
00:21:40,640 --> 00:21:41,640
那這個flag的話就是會對應到

737
00:21:41,640 --> 00:21:42,640
permissive domain這個情況

738
00:21:42,640 --> 00:21:43,640
也就是

739
00:21:43,640 --> 00:21:45,640
你的當前的就是

740
00:21:45,640 --> 00:21:47,640
權限是permissive

741
00:21:47,640 --> 00:21:48,640
對

742
00:21:48,640 --> 00:21:49,640
那這個的

743
00:21:49,640 --> 00:21:50,640
這個情況就是

744
00:21:50,640 --> 00:21:51,640
我的這個flag要帶有

745
00:21:51,640 --> 00:21:52,640
我的afd要帶有flag的話

746
00:21:52,640 --> 00:21:53,640
就是要在

747
00:21:53,640 --> 00:21:55,640
一邊要給return

748
00:21:55,640 --> 00:21:56,640
true的時候

749
00:21:56,640 --> 00:21:57,640
它才會帶起來

750
00:21:57,640 --> 00:21:58,640
對

751
00:21:58,640 --> 00:21:59,640
那我們接下來就會去想著

752
00:21:59,640 --> 00:22:00,640
試著說

753
00:22:00,640 --> 00:22:02,640
就是看能不能用這條路來去

754
00:22:02,640 --> 00:22:03,640
bypass掉我asyns

755
00:22:03,640 --> 00:22:05,640
也就讓我的當前的權限是permissive

756
00:22:06,640 --> 00:22:07,640
那我們要去繞過

757
00:22:07,640 --> 00:22:09,640
這個asyns的方法就

758
00:22:09,640 --> 00:22:10,640
換我們就換個思路

759
00:22:10,640 --> 00:22:11,640
它是evmark a bit

760
00:22:11,640 --> 00:22:14,640
會去將這個flag給設起來

761
00:22:14,640 --> 00:22:15,640
那我們的做法很簡單

762
00:22:15,640 --> 00:22:16,640
我們就改

763
00:22:16,640 --> 00:22:17,640
call evmark c bit

764
00:22:17,640 --> 00:22:19,640
把這個flag給設起來

765
00:22:19,640 --> 00:22:20,640
那我們不就

766
00:22:20,640 --> 00:22:21,640
等於我們把permissive domain

767
00:22:21,640 --> 00:22:22,640
給設起來

768
00:22:22,640 --> 00:22:23,640
那我們就可以bypass掉

769
00:22:23,640 --> 00:22:24,640
asyns的話

770
00:22:24,640 --> 00:22:25,640
對

771
00:22:25,640 --> 00:22:26,640
那

772
00:22:26,640 --> 00:22:28,640
接著我們要做的事情就是

773
00:22:28,640 --> 00:22:29,640
想辦法去call到

774
00:22:29,640 --> 00:22:30,640
evmark c bit這個function

775
00:22:30,640 --> 00:22:31,640
但因為這個function在kernel裡面

776
00:22:31,640 --> 00:22:32,640
所以我們可能會要去

777
00:22:32,640 --> 00:22:34,640
做一些其他事情來去

778
00:22:34,640 --> 00:22:36,640
call到這個kernel的function

779
00:22:36,640 --> 00:22:37,640
沒有錯

780
00:22:37,640 --> 00:22:38,640
那首先的話

781
00:22:38,640 --> 00:22:39,640
我們先回來看一下

782
00:22:39,640 --> 00:22:40,640
就是init的

783
00:22:40,640 --> 00:22:42,640
一個權限的部分

784
00:22:42,640 --> 00:22:43,640
對

785
00:22:43,640 --> 00:22:44,640
那

786
00:22:44,640 --> 00:22:45,640
init的話就是

787
00:22:45,640 --> 00:22:46,640
它會有帶有幾條

788
00:22:46,640 --> 00:22:47,640
比較特別的路

789
00:22:47,640 --> 00:22:48,640
那這邊路的意思

790
00:22:48,640 --> 00:22:49,640
其實是這樣的

791
00:22:49,640 --> 00:22:50,640
就是說

792
00:22:50,640 --> 00:22:51,640
首先的話我init

793
00:22:51,640 --> 00:22:52,640
它會transition

794
00:22:52,640 --> 00:22:53,640
就是我改變權限到

795
00:22:53,640 --> 00:22:55,640
random prop的這個權限

796
00:22:55,640 --> 00:22:56,640
而random prop

797
00:22:56,640 --> 00:22:57,640
它可以去做

798
00:22:57,640 --> 00:22:58,640
low kernel module

799
00:22:58,640 --> 00:22:59,640
這個權限

800
00:22:59,640 --> 00:23:00,640
所以代表著

801
00:23:00,640 --> 00:23:01,640
我init可以去做

802
00:23:01,640 --> 00:23:03,640
到low kernel module的意思

803
00:23:03,640 --> 00:23:04,640
對

804
00:23:04,640 --> 00:23:05,640
所以這就是為什麼

805
00:23:05,640 --> 00:23:06,640
當初要去

806
00:23:06,640 --> 00:23:07,640
hijack init的原因

807
00:23:07,640 --> 00:23:08,640
對

808
00:23:08,640 --> 00:23:09,640
那接著

809
00:23:09,640 --> 00:23:10,640
另外我們這邊

810
00:23:10,640 --> 00:23:11,640
其實稍微有點破梗了

811
00:23:11,640 --> 00:23:12,640
就是我們這邊

812
00:23:12,640 --> 00:23:13,640
會要有low kernel module

813
00:23:13,640 --> 00:23:14,640
的權限

814
00:23:14,640 --> 00:23:15,640
那這就是為什麼

815
00:23:15,640 --> 00:23:16,640
那這就是我們可以做到去

816
00:23:16,640 --> 00:23:18,640
call到kernel中function的方法

817
00:23:18,640 --> 00:23:20,640
也就是我們使用kernel module

818
00:23:20,640 --> 00:23:21,640
對

819
00:23:21,640 --> 00:23:22,640
那我這個kernel module

820
00:23:22,640 --> 00:23:23,640
它要去

821
00:23:24,640 --> 00:23:25,640
它要怎麼去

822
00:23:25,640 --> 00:23:26,640
讓它去

823
00:23:26,640 --> 00:23:27,640
就是

824
00:23:28,640 --> 00:23:29,640
對

825
00:23:29,640 --> 00:23:30,640
就是要怎麼去

826
00:23:30,640 --> 00:23:31,640
因為我們其實

827
00:23:31,640 --> 00:23:32,640
我們其實

828
00:23:32,640 --> 00:23:33,640
今天預期是這樣

829
00:23:33,640 --> 00:23:34,640
就是我已經編出一個

830
00:23:34,640 --> 00:23:35,640
kernel module了

831
00:23:35,640 --> 00:23:36,640
而這個kernel module

832
00:23:36,640 --> 00:23:37,640
可以做到的事情

833
00:23:37,640 --> 00:23:38,640
就是去做到

834
00:23:38,640 --> 00:23:39,640
那怎麼做的

835
00:23:39,640 --> 00:23:40,640
就大家可以

836
00:23:40,640 --> 00:23:41,640
事後再問我這樣

837
00:23:41,640 --> 00:23:42,640
對

838
00:23:42,640 --> 00:23:43,640
那我今天要做的事情

839
00:23:43,640 --> 00:23:44,640
就是如何把這個kernel module

840
00:23:44,640 --> 00:23:45,640
可以載入到

841
00:23:45,640 --> 00:23:46,640
那個linux的系統裡面

842
00:23:46,640 --> 00:23:47,640
那這邊做法

843
00:23:47,640 --> 00:23:48,640
其實是這樣

844
00:23:48,640 --> 00:23:49,640
就是

845
00:23:49,640 --> 00:23:50,640
我們先

846
00:23:50,640 --> 00:23:51,640
首先的話就是

847
00:23:51,640 --> 00:23:52,640
我們要先去找

848
00:23:52,640 --> 00:23:53,640
就是帶有

849
00:23:53,640 --> 00:23:54,640
vendor toolbars

850
00:23:54,640 --> 00:23:55,640
hiec

851
00:23:55,640 --> 00:23:56,640
這個context的一個檔案

852
00:23:56,640 --> 00:23:57,640
也就是剛才提到

853
00:23:57,640 --> 00:23:58,640
我們可以去

854
00:23:58,640 --> 00:23:59,640
轉換權限的那個

855
00:23:59,640 --> 00:24:00,640
所需要的那個

856
00:24:00,640 --> 00:24:01,640
elf binary

857
00:24:01,640 --> 00:24:02,640
然後再去找它

858
00:24:02,640 --> 00:24:03,640
就可以看到就是

859
00:24:03,640 --> 00:24:04,640
vendor toolbars

860
00:24:04,640 --> 00:24:05,640
是帶有這個

861
00:24:05,640 --> 00:24:06,640
這個權限的

862
00:24:06,640 --> 00:24:07,640
對

863
00:24:07,640 --> 00:24:08,640
那接著我們要再去找到

864
00:24:08,640 --> 00:24:09,640
就是

865
00:24:09,640 --> 00:24:10,640
可以被當成

866
00:24:10,640 --> 00:24:11,640
可以去被當成

867
00:24:11,640 --> 00:24:12,640
kernel module

868
00:24:12,640 --> 00:24:13,640
loading system裡面的

869
00:24:13,640 --> 00:24:14,640
一個檔案

870
00:24:14,640 --> 00:24:15,640
對

871
00:24:15,640 --> 00:24:16,640
那我們找到的話就是

872
00:24:16,640 --> 00:24:17,640
在vendor lib

873
00:24:17,640 --> 00:24:18,640
和vendor lib64下的

874
00:24:18,640 --> 00:24:19,640
所有的library

875
00:24:19,640 --> 00:24:20,640
都可以被

876
00:24:20,640 --> 00:24:21,640
當作kernel module

877
00:24:21,640 --> 00:24:22,640
loading system裡面

878
00:24:22,640 --> 00:24:23,640
對

879
00:24:23,640 --> 00:24:24,640
那我們這邊的

880
00:24:24,640 --> 00:24:25,640
做的海嘉的方法

881
00:24:25,640 --> 00:24:26,640
就是這樣

882
00:24:26,640 --> 00:24:27,640
首先的話就是

883
00:24:27,640 --> 00:24:28,640
因為

884
00:24:28,640 --> 00:24:29,640
這兩個context

885
00:24:29,640 --> 00:24:30,640
帶有這兩個權限

886
00:24:30,640 --> 00:24:31,640
他們都可以被

887
00:24:31,640 --> 00:24:32,640
init去做open con read

888
00:24:32,640 --> 00:24:33,640
那我們就可以用

889
00:24:33,640 --> 00:24:34,640
dirty pipe來去對

890
00:24:34,640 --> 00:24:35,640
這兩個檔案

891
00:24:35,640 --> 00:24:37,640
來去做overwrite部分

892
00:24:37,640 --> 00:24:38,640
雖然他們就是

893
00:24:38,640 --> 00:24:39,640
不可被寫

894
00:24:39,640 --> 00:24:40,640
但不管

895
00:24:40,640 --> 00:24:41,640
我們就要寫它

896
00:24:41,640 --> 00:24:42,640
對

897
00:24:42,640 --> 00:24:43,640
那我們就寫的

898
00:24:43,640 --> 00:24:44,640
過程是這樣的

899
00:24:44,640 --> 00:24:45,640
首先的話

900
00:24:45,640 --> 00:24:46,640
我們先將toolbars

901
00:24:46,640 --> 00:24:47,640
這個檔案

902
00:24:47,640 --> 00:24:48,640
寫成就是去

903
00:24:48,640 --> 00:24:49,640
做load kernel module

904
00:24:49,640 --> 00:24:50,640
對

905
00:24:50,640 --> 00:24:51,640
就是

906
00:24:51,640 --> 00:24:52,640
這個對象就是

907
00:24:52,640 --> 00:24:53,640
我們找到的

908
00:24:53,640 --> 00:24:54,640
在vendor lib

909
00:24:54,640 --> 00:24:55,640
底下一個library

910
00:24:55,640 --> 00:24:56,640
而

911
00:24:56,640 --> 00:24:57,640
另外的話

912
00:24:57,640 --> 00:24:58,640
我們再將這個library

913
00:24:58,640 --> 00:24:59,640
就是把kernel module

914
00:24:59,640 --> 00:25:00,640
寫進這個library裡面

915
00:25:00,640 --> 00:25:01,640
那接著我們就可以

916
00:25:01,640 --> 00:25:02,640
去自行這個

917
00:25:02,640 --> 00:25:03,640
就是

918
00:25:03,640 --> 00:25:04,640
這個vendor toolbars的部分

919
00:25:04,640 --> 00:25:05,640
他就會去

920
00:25:05,640 --> 00:25:06,640
把這個library

921
00:25:06,640 --> 00:25:07,640
當作kernel module

922
00:25:07,640 --> 00:25:08,640
給load進system裡面

923
00:25:08,640 --> 00:25:09,640
對

924
00:25:09,640 --> 00:25:10,640
那接著的話

925
00:25:10,640 --> 00:25:11,640
就可以去看到

926
00:25:11,640 --> 00:25:12,640
就是我們就可以

927
00:25:12,640 --> 00:25:13,640
這樣子成功地

928
00:25:13,640 --> 00:25:14,640
去拿到一個

929
00:25:14,640 --> 00:25:15,640
reversible shell

930
00:25:15,640 --> 00:25:16,640
對

931
00:25:16,640 --> 00:25:17,640
沒錯

932
00:25:17,640 --> 00:25:18,640
那為什麼我們可以說

933
00:25:18,640 --> 00:25:19,640
我們這是拿reversible shell呢

934
00:25:19,640 --> 00:25:20,640
這邊可以看到就是

935
00:25:20,640 --> 00:25:22,640
我們這邊context的部分

936
00:25:22,640 --> 00:25:23,640
是vendor more prop

937
00:25:23,640 --> 00:25:24,640
就是我們已經改變好

938
00:25:24,640 --> 00:25:25,640
我們的

939
00:25:25,640 --> 00:25:26,640
暫前前線的

940
00:25:26,640 --> 00:25:27,640
另外的話

941
00:25:27,640 --> 00:25:28,640
我們可以去ls

942
00:25:28,640 --> 00:25:29,640
這個library

943
00:25:29,640 --> 00:25:30,640
他是要

944
00:25:30,640 --> 00:25:31,640
就是

945
00:25:31,640 --> 00:25:32,640
你必須要是在

946
00:25:32,640 --> 00:25:34,640
root的情況下

947
00:25:34,640 --> 00:25:35,640
而且要

948
00:25:35,640 --> 00:25:36,640
bypass掉senus

949
00:25:36,640 --> 00:25:37,640
才有辦法去

950
00:25:37,640 --> 00:25:38,640
ls他

951
00:25:38,640 --> 00:25:39,640
對

952
00:25:39,640 --> 00:25:40,640
這就是為什麼我們表示

953
00:25:40,640 --> 00:25:41,640
我們已經拿到

954
00:25:41,640 --> 00:25:42,640
成功拿到reversible shell

955
00:25:42,640 --> 00:25:43,640
的原因

956
00:25:43,640 --> 00:25:44,640
對

957
00:25:44,640 --> 00:25:45,640
那就稍微去

958
00:25:45,640 --> 00:25:46,640
通診一下

959
00:25:46,640 --> 00:25:47,640
就是我們在android上面

960
00:25:47,640 --> 00:25:48,640
要去

961
00:25:48,640 --> 00:25:49,640
如果真的去

962
00:25:49,640 --> 00:25:50,640
拿到很高的權限的話

963
00:25:50,640 --> 00:25:52,640
我們就要先把senus

964
00:25:52,640 --> 00:25:53,640
給bypass掉

965
00:25:53,640 --> 00:25:54,640
那bypass掉之後

966
00:25:54,640 --> 00:25:55,640
我們可以幹嘛呢

967
00:25:55,640 --> 00:25:57,640
其實我們可以做的事情

968
00:25:57,640 --> 00:25:58,640
就是

969
00:25:58,640 --> 00:25:59,640
首先因為我們已經拿到root

970
00:25:59,640 --> 00:26:00,640
我們就可以

971
00:26:00,640 --> 00:26:01,640
rm-rf

972
00:26:01,640 --> 00:26:02,640
斜線

973
00:26:02,640 --> 00:26:03,640
就把android上面的

974
00:26:03,640 --> 00:26:04,640
的檔案系統

975
00:26:04,640 --> 00:26:05,640
通通刪掉

976
00:26:05,640 --> 00:26:06,640
沒有錯

977
00:26:06,640 --> 00:26:07,640
另外的話其實

978
00:26:07,640 --> 00:26:08,640
真的要去做一些

979
00:26:08,640 --> 00:26:09,640
壞壞事情的話

980
00:26:09,640 --> 00:26:10,640
其實我們可以做手機截圖

981
00:26:10,640 --> 00:26:11,640
對

982
00:26:11,640 --> 00:26:12,640
那就小心

983
00:26:12,640 --> 00:26:13,640
你的手機

984
00:26:13,640 --> 00:26:14,640
沒錯

985
00:26:14,640 --> 00:26:15,640
ok

986
00:26:15,640 --> 00:26:16,640
好

987
00:26:16,640 --> 00:26:17,640
那另外的話就是

988
00:26:17,640 --> 00:26:19,640
就稍微總結一下

989
00:26:19,640 --> 00:26:20,640
就是

990
00:26:20,640 --> 00:26:21,640
因為我們是在一個

991
00:26:21,640 --> 00:26:22,640
kernel上的exploit

992
00:26:22,640 --> 00:26:23,640
所以我們會需要去

993
00:26:23,640 --> 00:26:24,640
做一個kernel module部分

994
00:26:24,640 --> 00:26:25,640
好

995
00:26:25,640 --> 00:26:26,640
這kernel module做的事情

996
00:26:27,640 --> 00:26:28,640
並且去

997
00:26:28,640 --> 00:26:29,640
就是這樣子

998
00:26:29,640 --> 00:26:30,640
來去bypass

999
00:26:30,640 --> 00:26:31,640
s-index操作

1000
00:26:31,640 --> 00:26:32,640
所以就是

1001
00:26:32,640 --> 00:26:33,640
沒錯

1002
00:26:33,640 --> 00:26:34,640
我們就去

1003
00:26:34,640 --> 00:26:35,640
拿到一個

1004
00:26:35,640 --> 00:26:36,640
就是

1005
00:26:36,640 --> 00:26:37,640
在你手機上拿到一個

1006
00:26:37,640 --> 00:26:39,640
非常高前線的一個情況

1007
00:26:39,640 --> 00:26:40,640
好

1008
00:26:40,640 --> 00:26:41,640
那最後就稍微

1009
00:26:41,640 --> 00:26:43,640
就是來demo一下

1010
00:26:45,640 --> 00:26:46,640
按錯了

1011
00:26:46,640 --> 00:26:47,640
抱歉

1012
00:26:51,640 --> 00:26:52,640
不好意思

1013
00:26:53,640 --> 00:26:54,640
好

1014
00:26:54,640 --> 00:26:55,640
OK

1015
00:26:55,640 --> 00:26:56,640
好了

1016
00:26:56,640 --> 00:26:57,640
OK

1017
00:26:57,640 --> 00:26:58,640
那首先的話

1018
00:26:58,640 --> 00:26:59,640
就是你可以看到

1019
00:26:59,640 --> 00:27:00,640
就是我這邊做的事情

1020
00:27:00,640 --> 00:27:01,640
就是

1021
00:27:01,640 --> 00:27:02,640
去

1022
00:27:02,640 --> 00:27:03,640
去看一下

1023
00:27:03,640 --> 00:27:04,640
我們現在當前UID是show

1024
00:27:04,640 --> 00:27:05,640
這是一個很低的前線

1025
00:27:05,640 --> 00:27:06,640
然後

1026
00:27:06,640 --> 00:27:07,640
我就

1027
00:27:07,640 --> 00:27:08,640
我們的context也是

1028
00:27:08,640 --> 00:27:09,640
show

1029
00:27:09,640 --> 00:27:10,640
就我現在是在一個

1030
00:27:10,640 --> 00:27:11,640
非常低的前線

1031
00:27:11,640 --> 00:27:12,640
我沒有那個

1032
00:27:12,640 --> 00:27:13,640
就是可以直接去做

1033
00:27:13,640 --> 00:27:14,640
我沒有sudo

1034
00:27:14,640 --> 00:27:15,640
就我什麼都沒有

1035
00:27:15,640 --> 00:27:17,640
就這一個非常低的前線

1036
00:27:17,640 --> 00:27:18,640
那另外

1037
00:27:18,640 --> 00:27:19,640
右邊這邊的話

1038
00:27:19,640 --> 00:27:20,640
我們就去

1039
00:27:20,640 --> 00:27:21,640
把一個

1040
00:27:21,640 --> 00:27:22,640
就是

1041
00:27:22,640 --> 00:27:23,640
reverse show的server給打開

1042
00:27:23,640 --> 00:27:24,640
對

1043
00:27:24,640 --> 00:27:25,640
接著我們左邊的部分

1044
00:27:25,640 --> 00:27:26,640
就去執行我們的exploit

1045
00:27:26,640 --> 00:27:27,640
沒錯

1046
00:27:27,640 --> 00:27:28,640
然後執行完之後

1047
00:27:28,640 --> 00:27:29,640
你可以看到

1048
00:27:29,640 --> 00:27:30,640
右邊的reverse show

1049
00:27:30,640 --> 00:27:31,640
那邊就彈出一個

1050
00:27:31,640 --> 00:27:32,640
就是show的試穿了

1051
00:27:32,640 --> 00:27:33,640
對

1052
00:27:33,640 --> 00:27:34,640
你就可以看到

1053
00:27:34,640 --> 00:27:35,640
我們拿了show了

1054
00:27:35,640 --> 00:27:36,640
對

1055
00:27:36,640 --> 00:27:37,640
然後這show

1056
00:27:37,640 --> 00:27:38,640
它的ID是root

1057
00:27:38,640 --> 00:27:39,640
並且它的context

1058
00:27:39,640 --> 00:27:40,640
是randomlyprobe

1059
00:27:40,640 --> 00:27:41,640
這代表我們當前已經

1060
00:27:41,640 --> 00:27:42,640
做完我們的kernel module

1061
00:27:42,640 --> 00:27:43,640
就是我們已經把

1062
00:27:43,640 --> 00:27:44,640
s-index bypass掉

1063
00:27:44,640 --> 00:27:45,640
然後我們有24線data

1064
00:27:45,640 --> 00:27:46,640
我們是可以成功去

1065
00:27:46,640 --> 00:27:47,640
就是

1066
00:27:47,640 --> 00:27:48,640
看到這個data下面是

1067
00:27:48,640 --> 00:27:49,640
有什麼

1068
00:27:49,640 --> 00:27:50,640
有什麼東西了

1069
00:27:50,640 --> 00:27:51,640
對 沒錯

1070
00:27:51,640 --> 00:27:52,640
那大家可以

1071
00:27:52,640 --> 00:27:53,640
自己去試試看

1072
00:27:53,640 --> 00:27:54,640
就是把你的

1073
00:27:54,640 --> 00:27:55,640
Android上面

1074
00:27:55,640 --> 00:27:56,640
開一個show出來

1075
00:27:56,640 --> 00:27:57,640
你可以去LA之前

1076
00:27:57,640 --> 00:27:58,640
去看看

1077
00:27:58,640 --> 00:27:59,640
你會發現是沒辦法做到的

1078
00:27:59,640 --> 00:28:00,640
但我們做到了

1079
00:28:00,640 --> 00:28:01,640
沒錯

1080
00:28:01,640 --> 00:28:02,640
那這邊的話就希望

1081
00:28:02,640 --> 00:28:03,640
大家鼓掌一下

1082
00:28:03,640 --> 00:28:04,640
感謝感謝

1083
00:28:08,640 --> 00:28:09,640
好的

1084
00:28:09,640 --> 00:28:10,640
好 那我們就

1085
00:28:10,640 --> 00:28:11,640
講到這邊

1086
00:28:11,640 --> 00:28:12,640
那就歡迎大家Q&A

1087
00:28:12,640 --> 00:28:13,640
對

1088
00:28:13,640 --> 00:28:14,640
那這場可能就

1089
00:28:14,640 --> 00:28:15,640
稍微難一點

1090
00:28:15,640 --> 00:28:17,640
就歡迎大家提一些問題

1091
00:28:17,640 --> 00:28:18,640
好

1092
00:28:18,640 --> 00:28:19,640
就可能你剛才

1093
00:28:19,640 --> 00:28:20,640
有哪些就是

1094
00:28:20,640 --> 00:28:21,640
基本部分沒有聽懂

1095
00:28:21,640 --> 00:28:23,640
都可以提問這樣

1096
00:28:37,640 --> 00:28:38,640
那個

1097
00:28:38,640 --> 00:28:39,640
我們今天的

1098
00:28:39,640 --> 00:28:40,640
對

1099
00:28:40,640 --> 00:28:41,640
我們今天發問

1100
00:28:41,640 --> 00:28:42,640
都是在slido上面

1101
00:28:42,640 --> 00:28:44,640
所以歡迎大家掃描QR code

1102
00:28:44,640 --> 00:28:45,640
然後在上面發問

1103
00:28:45,640 --> 00:28:46,640
然後如果你覺得

1104
00:28:46,640 --> 00:28:47,640
別人的問題

1105
00:28:47,640 --> 00:28:48,640
也是你的問題的話

1106
00:28:48,640 --> 00:28:50,640
上面都可以幫我按個讚

1107
00:28:50,640 --> 00:28:51,640
這樣你的問題

1108
00:28:51,640 --> 00:28:52,640
就會被更多人看到

1109
00:28:55,640 --> 00:28:56,640
好 那

1110
00:28:57,640 --> 00:28:58,640
這部分的話就

1111
00:28:58,640 --> 00:28:59,640
一個一個

1112
00:28:59,640 --> 00:29:00,640
請問問題滿少的

1113
00:29:00,640 --> 00:29:01,640
我們就一個一個答

1114
00:29:02,640 --> 00:29:04,640
好 那有人問到說

1115
00:29:04,640 --> 00:29:05,640
怎麼確定說

1116
00:29:05,640 --> 00:29:07,640
shellcode的地方

1117
00:29:07,640 --> 00:29:08,640
不太會被呼叫到

1118
00:29:08,640 --> 00:29:10,640
應該是指CXAVCD的那塊吧

1119
00:29:10,640 --> 00:29:12,640
那那塊其實就是

1120
00:29:12,640 --> 00:29:14,640
你其實可以從IDA去擬

1121
00:29:14,640 --> 00:29:15,640
然後你可以從

1122
00:29:15,640 --> 00:29:16,640
close reference去找

1123
00:29:16,640 --> 00:29:17,640
那其實你丟上去

1124
00:29:17,640 --> 00:29:18,640
直接丟上去跑

1125
00:29:18,640 --> 00:29:19,640
然後跑完以後

1126
00:29:19,640 --> 00:29:20,640
你就會發現

1127
00:29:20,640 --> 00:29:21,640
什麼事都不會發生

1128
00:29:21,640 --> 00:29:22,640
因為你丟到一串

1129
00:29:22,640 --> 00:29:23,640
一直被執行的

1130
00:29:23,640 --> 00:29:24,640
code的區段的時候

1131
00:29:24,640 --> 00:29:25,640
你一丟上去

1132
00:29:25,640 --> 00:29:26,640
它直接壞掉

1133
00:29:26,640 --> 00:29:27,640
在客戶直接panic

1134
00:29:27,640 --> 00:29:28,640
所以就直接進reboot

1135
00:29:28,640 --> 00:29:29,640
那我們就那時候測

1136
00:29:29,640 --> 00:29:30,640
我們就隨便找一塊

1137
00:29:30,640 --> 00:29:32,640
就是隨便找一個function

1138
00:29:32,640 --> 00:29:33,640
然後開始覺得說

1139
00:29:33,640 --> 00:29:34,640
好像可以

1140
00:29:34,640 --> 00:29:35,640
然後就放上去

1141
00:29:35,640 --> 00:29:36,640
然後跑

1142
00:29:36,640 --> 00:29:37,640
然後它就不會壞掉

1143
00:29:37,640 --> 00:29:38,640
那就選這一塊這樣

1144
00:29:40,640 --> 00:29:41,640
輕鬆通靈法這樣

1145
00:29:41,640 --> 00:29:42,640
我稍微補充一下

1146
00:29:42,640 --> 00:29:43,640
就是其實

1147
00:29:43,640 --> 00:29:44,640
我們當初做的時候

1148
00:29:44,640 --> 00:29:45,640
有把它丟上去

1149
00:29:45,640 --> 00:29:46,640
然後就放著

1150
00:29:46,640 --> 00:29:47,640
我們放多久啊

1151
00:29:47,640 --> 00:29:48,640
我們應該放蠻長一段時間

1152
00:29:48,640 --> 00:29:49,640
應該四五個小時吧

1153
00:29:49,640 --> 00:29:50,640
對 幾個小時

1154
00:29:50,640 --> 00:29:51,640
都沒壞

1155
00:29:51,640 --> 00:29:52,640
那應該就沒事這樣子

1156
00:29:52,640 --> 00:29:54,640
佛系找小口放置法

1157
00:29:54,640 --> 00:29:55,640
沒有錯

1158
00:29:57,640 --> 00:29:59,640
然後第二個問題是問說

1159
00:29:59,640 --> 00:30:01,640
有辦法拿到precision root嗎

1160
00:30:01,640 --> 00:30:02,640
像是透過magisk之類

1161
00:30:02,640 --> 00:30:03,640
這不行

1162
00:30:03,640 --> 00:30:04,640
因為我們

1163
00:30:04,640 --> 00:30:05,640
我們沒有去onlabloader

1164
00:30:05,640 --> 00:30:06,640
我們的export

1165
00:30:06,640 --> 00:30:07,640
也沒有去

1166
00:30:07,640 --> 00:30:08,640
能夠做到onlabloader

1167
00:30:08,640 --> 00:30:09,640
沒辦法把整個分位

1168
00:30:09,640 --> 00:30:10,640
這樣刷回去

1169
00:30:10,640 --> 00:30:11,640
所以我們沒辦法

1170
00:30:11,640 --> 00:30:12,640
做到precision root

1171
00:30:16,640 --> 00:30:17,640
好

1172
00:30:17,640 --> 00:30:18,640
那SE呢

1173
00:30:18,640 --> 00:30:19,640
這部分我來講一下

1174
00:30:19,640 --> 00:30:20,640
好

1175
00:30:20,640 --> 00:30:21,640
就是

1176
00:30:21,640 --> 00:30:22,640
大家

1177
00:30:22,640 --> 00:30:23,640
就是

1178
00:30:23,640 --> 00:30:24,640
又要改permissive

1179
00:30:24,640 --> 00:30:25,640
應該可以disable

1180
00:30:25,640 --> 00:30:26,640
應該可以吧

1181
00:30:26,640 --> 00:30:27,640
這情況是這樣的

1182
00:30:27,640 --> 00:30:29,640
要看你的Android

1183
00:30:29,640 --> 00:30:31,640
是哪一個廠牌出的

1184
00:30:31,640 --> 00:30:33,640
就是我們目前要

1185
00:30:33,640 --> 00:30:34,640
看到一些情況就是

1186
00:30:34,640 --> 00:30:36,640
Pixel6

1187
00:30:36,640 --> 00:30:38,640
它可以去做

1188
00:30:38,640 --> 00:30:39,640
就是可以去

1189
00:30:39,640 --> 00:30:40,640
去做set

1190
00:30:40,640 --> 00:30:42,640
就是去setinforce

1191
00:30:42,640 --> 00:30:43,640
乘0的部分

1192
00:30:43,640 --> 00:30:44,640
但這個你需要

1193
00:30:44,640 --> 00:30:45,640
高權限

1194
00:30:45,640 --> 00:30:46,640
所以代表你要

1195
00:30:46,640 --> 00:30:47,640
如果真的你自己要做的話

1196
00:30:47,640 --> 00:30:48,640
就是你要

1197
00:30:48,640 --> 00:30:50,640
將你的手機刷成root

1198
00:30:50,640 --> 00:30:51,640
並且去把這個

1199
00:30:51,640 --> 00:30:52,640
就是再去做setinforce

1200
00:30:52,640 --> 00:30:54,640
然後你拿root的權限下去

1201
00:30:54,640 --> 00:30:55,640
做setinforce0

1202
00:30:55,640 --> 00:30:56,640
對

1203
00:30:56,640 --> 00:30:57,640
但其實大部分廠牌的

1204
00:30:57,640 --> 00:30:59,640
Android的手機

1205
00:30:59,640 --> 00:31:00,640
它都會將

1206
00:31:00,640 --> 00:31:01,640
就是

1207
00:31:01,640 --> 00:31:02,640
因為之前有提到

1208
00:31:02,640 --> 00:31:03,640
就是我要做setinforce

1209
00:31:03,640 --> 00:31:04,640
那個

1210
00:31:04,640 --> 00:31:05,640
試行的話

1211
00:31:05,640 --> 00:31:06,640
我會需要

1212
00:31:06,640 --> 00:31:07,640
kernel module要帶有一個

1213
00:31:07,640 --> 00:31:08,640
config來去編譯

1214
00:31:08,640 --> 00:31:09,640
才會有這個

1215
00:31:09,640 --> 00:31:10,640
才可以去做setinforce0

1216
00:31:10,640 --> 00:31:11,640
對

1217
00:31:11,640 --> 00:31:13,640
那這個情況其實

1218
00:31:13,640 --> 00:31:14,640
大部分的廠商

1219
00:31:14,640 --> 00:31:15,640
在編linux kernel的時候

1220
00:31:15,640 --> 00:31:16,640
就會把這個flag

1221
00:31:16,640 --> 00:31:18,640
就這個config給拔掉

1222
00:31:18,640 --> 00:31:19,640
所以代表你沒辦法去做

1223
00:31:19,640 --> 00:31:20,640
setinforce0的部分

1224
00:31:20,640 --> 00:31:22,640
那就沒辦法直接做

1225
00:31:22,640 --> 00:31:23,640
對

1226
00:31:23,640 --> 00:31:24,640
好

1227
00:31:24,640 --> 00:31:25,640
那有人問說

1228
00:31:25,640 --> 00:31:27,640
這個攻擊的前置條件

1229
00:31:27,640 --> 00:31:28,640
有哪些版本

1230
00:31:28,640 --> 00:31:30,640
那其實derivative影響的版本

1231
00:31:30,640 --> 00:31:32,640
是kernel5.8以上

1232
00:31:32,640 --> 00:31:34,640
那它對應到Android系統的話

1233
00:31:34,640 --> 00:31:35,640
是Android12

1234
00:31:35,640 --> 00:31:37,640
那像是我們

1235
00:31:37,640 --> 00:31:39,640
可以在pixel6

1236
00:31:39,640 --> 00:31:41,640
或是samsung galaxy22上

1237
00:31:41,640 --> 00:31:43,640
自行攻擊

1238
00:31:43,640 --> 00:31:45,640
那就順便回答說

1239
00:31:45,640 --> 00:31:46,640
下面有一個說

1240
00:31:46,640 --> 00:31:47,640
有沒有人在arm上手機實驗過

1241
00:31:47,640 --> 00:31:48,640
有

1242
00:31:48,640 --> 00:31:49,640
其實我們是

1243
00:31:49,640 --> 00:31:50,640
有打

1244
00:31:50,640 --> 00:31:51,640
就是有用export

1245
00:31:51,640 --> 00:31:52,640
直接在pixel6上

1246
00:31:52,640 --> 00:31:53,640
拿root

1247
00:31:57,640 --> 00:31:59,640
花了多少時間做到

1248
00:31:59,640 --> 00:32:00,640
是

1249
00:32:00,640 --> 00:32:01,640
我們其實

1250
00:32:01,640 --> 00:32:02,640
做這個大概從

1251
00:32:02,640 --> 00:32:05,640
3月到5月中吧

1252
00:32:05,640 --> 00:32:07,640
大概兩個多月

1253
00:32:07,640 --> 00:32:09,640
從我們對於

1254
00:32:09,640 --> 00:32:11,640
那個環境的不認識

1255
00:32:11,640 --> 00:32:12,640
然後到一路export

1256
00:32:12,640 --> 00:32:14,640
大概兩個月這樣子

1257
00:32:14,640 --> 00:32:15,640
那從中間的話

1258
00:32:15,640 --> 00:32:17,640
我們就從invater上

1259
00:32:17,640 --> 00:32:18,640
開始看

1260
00:32:18,640 --> 00:32:19,640
然後跟

1261
00:32:19,640 --> 00:32:20,640
看Android的source

1262
00:32:20,640 --> 00:32:21,640
看NS的保護機制

1263
00:32:21,640 --> 00:32:22,640
跟

1264
00:32:22,640 --> 00:32:24,640
還有做一些黑箱通靈法

1265
00:32:24,640 --> 00:32:25,640
就是

1266
00:32:25,640 --> 00:32:26,640
我們在debug的時候

1267
00:32:26,640 --> 00:32:27,640
其實那時候遇到一個

1268
00:32:27,640 --> 00:32:28,640
蠻好笑的問題

1269
00:32:28,640 --> 00:32:29,640
就是我們invater

1270
00:32:29,640 --> 00:32:31,640
我們要接GDB server debug出來

1271
00:32:31,640 --> 00:32:32,640
結果一attach上

1272
00:32:32,640 --> 00:32:33,640
init process

1273
00:32:33,640 --> 00:32:34,640
直接爛掉

1274
00:32:34,640 --> 00:32:35,640
我們想說

1275
00:32:35,640 --> 00:32:36,640
是什麼意思

1276
00:32:36,640 --> 00:32:37,640
我們就直接用panic的

1277
00:32:37,640 --> 00:32:39,640
那個message來做debug

1278
00:32:43,640 --> 00:32:44,640
那能繞過

1279
00:32:44,640 --> 00:32:47,640
Samsung Knox的硬體及保護嗎

1280
00:32:48,640 --> 00:32:49,640
我們真的沒有去對

1281
00:32:49,640 --> 00:32:51,640
Samsung的Knox

1282
00:32:51,640 --> 00:32:53,640
Samsung Knox的保護機制

1283
00:32:53,640 --> 00:32:54,640
我們沒有對

1284
00:32:54,640 --> 00:32:55,640
Samsung的手機做過

1285
00:32:55,640 --> 00:32:56,640
所以這邊

1286
00:32:56,640 --> 00:32:58,640
還沒辦法跟你確定

1287
00:32:58,640 --> 00:33:00,640
對 但Samsung Knox

1288
00:33:00,640 --> 00:33:01,640
要去繞過

1289
00:33:01,640 --> 00:33:02,640
應該還是會需要

1290
00:33:02,640 --> 00:33:03,640
就是拿到

1291
00:33:03,640 --> 00:33:04,640
跟我們前面提到

1292
00:33:04,640 --> 00:33:05,640
Persistent

1293
00:33:05,640 --> 00:33:06,640
拿到一樣的權限

1294
00:33:06,640 --> 00:33:08,640
就是我們至少要拿到

1295
00:33:08,640 --> 00:33:09,640
EL3的這樣的權限

1296
00:33:09,640 --> 00:33:11,640
我們才有可能去做

1297
00:33:11,640 --> 00:33:12,640
bypass掉

1298
00:33:12,640 --> 00:33:13,640
這樣硬體保護機的部分

1299
00:33:13,640 --> 00:33:14,640
那我們現在其實都是

1300
00:33:14,640 --> 00:33:15,640
遊蕩在EL1而已

1301
00:33:15,640 --> 00:33:16,640
就是我們可以再去

1302
00:33:16,640 --> 00:33:18,640
Knox上面去做一些

1303
00:33:18,640 --> 00:33:19,640
乖乖幹一個

1304
00:33:19,640 --> 00:33:20,640
乖乖的事情這樣

1305
00:33:20,640 --> 00:33:21,640
對對對

1306
00:33:21,640 --> 00:33:22,640
我們所有就在EL1上而已

1307
00:33:22,640 --> 00:33:24,640
還沒達到EL3

1308
00:33:25,640 --> 00:33:27,640
現在這個漏洞已經修補了

1309
00:33:27,640 --> 00:33:28,640
對 那個Dirty Pie

1310
00:33:28,640 --> 00:33:29,640
這個洞已經補起來了

1311
00:33:29,640 --> 00:33:31,640
就是我們那時候測的分位

1312
00:33:31,640 --> 00:33:33,640
是我們從

1313
00:33:33,640 --> 00:33:34,640
因為它是二月

1314
00:33:34,640 --> 00:33:35,640
Dirty Pie是今年

1315
00:33:35,640 --> 00:33:36,640
二月release的一個洞

1316
00:33:36,640 --> 00:33:37,640
二月底 三月初

1317
00:33:37,640 --> 00:33:39,640
那我們測過的洞是

1318
00:33:39,640 --> 00:33:41,640
我們一路測到Pixel 6的五月

1319
00:33:41,640 --> 00:33:42,640
它都可以Exploit

1320
00:33:42,640 --> 00:33:43,640
五月的時候

1321
00:33:43,640 --> 00:33:45,640
Pixel 6的分位才修好

1322
00:33:45,640 --> 00:33:46,640
對

1323
00:33:46,640 --> 00:33:47,640
好 這邊可以講一個

1324
00:33:47,640 --> 00:33:48,640
滿有趣的事情

1325
00:33:48,640 --> 00:33:49,640
就是我們當初

1326
00:33:49,640 --> 00:33:51,640
在去做Android的

1327
00:33:51,640 --> 00:33:53,640
就Emulator上面的Exploit的時候

1328
00:33:53,640 --> 00:33:54,640
我們其實是

1329
00:33:54,640 --> 00:33:55,640
我是去載

1330
00:33:55,640 --> 00:33:56,640
應該是十二月

1331
00:33:56,640 --> 00:33:58,640
二零二一十二月份的

1332
00:33:58,640 --> 00:34:00,640
的那個就是Android

1333
00:34:00,640 --> 00:34:01,640
對 但我發現

1334
00:34:01,640 --> 00:34:03,640
它上面的那個

1335
00:34:03,640 --> 00:34:04,640
Dirty Pie是被patch掉了

1336
00:34:04,640 --> 00:34:05,640
超神奇的

1337
00:34:05,640 --> 00:34:06,640
它明明就是

1338
00:34:06,640 --> 00:34:08,640
二零二一年十二月的

1339
00:34:08,640 --> 00:34:09,640
Kernel

1340
00:34:09,640 --> 00:34:10,640
但它Dirty Pie是patch掉了

1341
00:34:10,640 --> 00:34:11,640
就超怪

1342
00:34:11,640 --> 00:34:12,640
但明明這個東西

1343
00:34:12,640 --> 00:34:13,640
二月才release

1344
00:34:13,640 --> 00:34:14,640
我就不知道它是

1345
00:34:14,640 --> 00:34:15,640
到底發生什麼事情

1346
00:34:15,640 --> 00:34:16,640
對 可能是

1347
00:34:16,640 --> 00:34:17,640
後面有去做更新之類的吧

1348
00:34:17,640 --> 00:34:18,640
但反正就

1349
00:34:18,640 --> 00:34:19,640
它有patch掉這樣

1350
00:34:19,640 --> 00:34:21,640
對 就滿有趣的

1351
00:34:24,640 --> 00:34:25,640
漏洞怎麼補

1352
00:34:25,640 --> 00:34:28,640
漏洞曾經其實是在於說

1353
00:34:28,640 --> 00:34:29,640
Dirty Pie這個洞

1354
00:34:29,640 --> 00:34:30,640
是它在Pipe

1355
00:34:30,640 --> 00:34:31,640
拿Pipe的時候

1356
00:34:31,640 --> 00:34:33,640
它沒有對Flag做initialize

1357
00:34:33,640 --> 00:34:35,640
就是沒有做初始化

1358
00:34:37,640 --> 00:34:38,640
其實它怎麼補的

1359
00:34:38,640 --> 00:34:41,640
就是在拿Page Reference的時候

1360
00:34:41,640 --> 00:34:43,640
直接先做initialize

1361
00:34:43,640 --> 00:34:45,640
就直接加一個等於零這樣

1362
00:34:45,640 --> 00:34:46,640
就把它補掉了

1363
00:34:49,640 --> 00:34:50,640
詳細其實大家可以

1364
00:34:50,640 --> 00:34:51,640
盡量去搜尋

1365
00:34:51,640 --> 00:34:53,640
就是Dirty Pie的

1366
00:34:53,640 --> 00:34:55,640
就這關鍵字

1367
00:34:55,640 --> 00:34:56,640
你去看第一篇文章

1368
00:34:56,640 --> 00:34:57,640
應該就是

1369
00:34:57,640 --> 00:34:59,640
就是當初發Dirty Pie

1370
00:34:59,640 --> 00:35:02,640
這個CVE的那一個作者

1371
00:35:02,640 --> 00:35:03,640
他的Blog

1372
00:35:03,640 --> 00:35:04,640
那你就可以看到說

1373
00:35:04,640 --> 00:35:05,640
他的詳細的

1374
00:35:05,640 --> 00:35:07,640
他的漏洞是怎麼形成的

1375
00:35:07,640 --> 00:35:09,640
他到底做了怎樣的事情

1376
00:35:09,640 --> 00:35:11,640
他為什麼會碰到這漏洞

1377
00:35:11,640 --> 00:35:12,640
這也蠻有趣的

1378
00:35:12,640 --> 00:35:13,640
然後就是

1379
00:35:13,640 --> 00:35:15,640
他到底是怎麼去把它修掉的

1380
00:35:15,640 --> 00:35:16,640
詳細都可以看到

1381
00:35:16,640 --> 00:35:17,640
如果大家有興趣

1382
00:35:17,640 --> 00:35:18,640
可以去看一下

1383
00:35:19,640 --> 00:35:20,640
我這邊補充一個

1384
00:35:20,640 --> 00:35:22,640
就是Dirty Pie其實

1385
00:35:22,640 --> 00:35:23,640
它有一個限制

1386
00:35:23,640 --> 00:35:24,640
就是它不能寫

1387
00:35:24,640 --> 00:35:26,640
每個Page的第一個Button

1388
00:35:26,640 --> 00:35:28,640
其實這個部分讓我們

1389
00:35:28,640 --> 00:35:29,640
因為我們後面有寫Column Module

1390
00:35:29,640 --> 00:35:30,640
因為Column Module

1391
00:35:30,640 --> 00:35:32,640
不太可能只有一個Page的Size

1392
00:35:32,640 --> 00:35:33,640
所以我們必須要用

1393
00:35:33,640 --> 00:35:35,640
我們還必須要繞過這個限制

1394
00:35:35,640 --> 00:35:37,640
就是我們Column Module

1395
00:35:37,640 --> 00:35:39,640
是三個Page

1396
00:35:39,640 --> 00:35:40,640
所以我們至少

1397
00:35:40,640 --> 00:35:42,640
我們這個還需要去繞這個

1398
00:35:42,640 --> 00:35:43,640
所以這個還是一個蠻有趣的議題

1399
00:35:43,640 --> 00:35:44,640
大家也可以想想看說

1400
00:35:44,640 --> 00:35:45,640
當你這個

1401
00:35:45,640 --> 00:35:47,640
你這個洞被限制的時候

1402
00:35:47,640 --> 00:35:49,640
你有什麼方法可以去

1403
00:35:49,640 --> 00:35:51,640
就是你的Export也被限制住

1404
00:35:51,640 --> 00:35:52,640
那你還要怎麼去Export

1405
00:35:52,640 --> 00:35:54,640
也是一個蠻有趣的問題

1406
00:35:54,640 --> 00:35:55,640
我稍微補充一下

1407
00:35:55,640 --> 00:35:57,640
就是這邊的限制其實是這樣

1408
00:35:57,640 --> 00:35:58,640
就是因為我們沒辦法去

1409
00:35:58,640 --> 00:36:00,640
寫到第一個Byte

1410
00:36:00,640 --> 00:36:01,640
就是我們每Page的第一個Byte

1411
00:36:01,640 --> 00:36:02,640
所以代表我們沒辦法去寫到

1412
00:36:02,640 --> 00:36:03,640
D0 D0X1 0 0 0

1413
00:36:03,640 --> 00:36:04,640
D0X2 0 0 0

1414
00:36:04,640 --> 00:36:05,640
這三個位置

1415
00:36:05,640 --> 00:36:06,640
因為我剛才有說

1416
00:36:06,640 --> 00:36:08,640
是三個Page的大小的Column Module

1417
00:36:08,640 --> 00:36:09,640
所以我這三個位置是不能寫的

1418
00:36:09,640 --> 00:36:11,640
那既然這三個位置不能寫的話

1419
00:36:11,640 --> 00:36:13,640
代表我們寫上去Column Module

1420
00:36:13,640 --> 00:36:15,640
它會有三個Byte是壞掉的

1421
00:36:15,640 --> 00:36:16,640
那這個問題的話

1422
00:36:16,640 --> 00:36:18,640
其實就會去影響到一些事情

1423
00:36:18,640 --> 00:36:20,640
但我這邊直接爆雷好了

1424
00:36:20,640 --> 00:36:21,640
就是我們的做法是這樣的

1425
00:36:21,640 --> 00:36:22,640
其實大家可以去

1426
00:36:22,640 --> 00:36:24,640
有興趣可以去看一看

1427
00:36:24,640 --> 00:36:25,640
那我這邊就稍微講一下

1428
00:36:25,640 --> 00:36:27,640
就我們HeatKan到時候應該

1429
00:36:27,640 --> 00:36:28,640
在HeatKan的YouTube上面

1430
00:36:28,640 --> 00:36:31,640
應該會release我們在HeatKan上的發表

1431
00:36:31,640 --> 00:36:32,640
然後這邊的話就是

1432
00:36:32,640 --> 00:36:34,640
HeatKan的那個NERF版本

1433
00:36:34,640 --> 00:36:35,640
沒有錯

1434
00:36:35,640 --> 00:36:36,640
就到時候有興趣可以看

1435
00:36:36,640 --> 00:36:37,640
那我這邊稍微講一下就是

1436
00:36:37,640 --> 00:36:39,640
我們是怎麼擺Page它的

1437
00:36:39,640 --> 00:36:41,640
首先的話就是D0X0的部分

1438
00:36:41,640 --> 00:36:42,640
因為我們是一個Column Module

1439
00:36:42,640 --> 00:36:45,640
去Override到Library裡面

1440
00:36:45,640 --> 00:36:46,640
Column Module和Library

1441
00:36:46,640 --> 00:36:48,640
它們都是ELF的格式碼

1442
00:36:48,640 --> 00:36:49,640
所以在D0的位置

1443
00:36:49,640 --> 00:36:51,640
它一定是一個Major Number

1444
00:36:51,640 --> 00:36:53,640
所以這部分一定是一樣的

1445
00:36:53,640 --> 00:36:54,640
所以我沒寫到它

1446
00:36:54,640 --> 00:36:55,640
它也是會一樣就沒差

1447
00:36:55,640 --> 00:36:57,640
但在D0X1000

1448
00:36:57,640 --> 00:36:59,640
和D0X2000這兩個位置的部分的話

1449
00:36:59,640 --> 00:37:02,640
就比較麻煩

1450
00:37:02,640 --> 00:37:04,640
我們是怎麼做的呢

1451
00:37:04,640 --> 00:37:05,640
通靈

1452
00:37:05,640 --> 00:37:06,640
沒錯

1453
00:37:06,640 --> 00:37:08,640
我們就直接去硬找一個Library

1454
00:37:08,640 --> 00:37:09,640
跟我們Column Module上面

1455
00:37:09,640 --> 00:37:10,640
這兩個位置的值是一樣的

1456
00:37:10,640 --> 00:37:12,640
找到我們就成功了

1457
00:37:12,640 --> 00:37:13,640
沒錯

1458
00:37:13,640 --> 00:37:15,640
就是這麼做的

1459
00:37:15,640 --> 00:37:16,640
但其實我們沒有找到啦

1460
00:37:16,640 --> 00:37:18,640
我們其實只有找到

1461
00:37:18,640 --> 00:37:20,640
在D0X2000位置是一樣的

1462
00:37:20,640 --> 00:37:21,640
但D0X1000位置不一樣

1463
00:37:21,640 --> 00:37:23,640
但我們找到那個位置的值

1464
00:37:23,640 --> 00:37:25,640
有一個Library那個值是90

1465
00:37:25,640 --> 00:37:26,640
0X90

1466
00:37:26,640 --> 00:37:27,640
就是一個Nope

1467
00:37:27,640 --> 00:37:28,640
沒錯

1468
00:37:28,640 --> 00:37:29,640
在X823是一個Nope

1469
00:37:29,640 --> 00:37:30,640
那既然它是Nope的話

1470
00:37:30,640 --> 00:37:31,640
我就在Column Module那個位置

1471
00:37:31,640 --> 00:37:32,640
塞一個Nope進去

1472
00:37:32,640 --> 00:37:33,640
搞定

1473
00:37:33,640 --> 00:37:34,640
這樣

1474
00:37:34,640 --> 00:37:35,640
沒錯

1475
00:37:35,640 --> 00:37:37,640
那這邊就有這樣的一個小小故事

1476
00:37:37,640 --> 00:37:38,640
那有人問說

1477
00:37:38,640 --> 00:37:41,640
手機的本地體圈怎麼利用

1478
00:37:41,640 --> 00:37:43,640
是問說我們是

1479
00:37:43,640 --> 00:37:46,640
怎麼用漏洞利用的嗎

1480
00:37:46,640 --> 00:37:47,640
還是

1481
00:37:47,640 --> 00:37:48,640
我們如果是用漏洞利用的話

1482
00:37:48,640 --> 00:37:50,640
其實跟Emitter其實差不多

1483
00:37:50,640 --> 00:37:51,640
它變成ARM架構

1484
00:37:51,640 --> 00:37:52,640
就是

1485
00:37:52,640 --> 00:37:53,640
我們Emitter是X86

1486
00:37:53,640 --> 00:37:54,640
那我們就是

1487
00:37:54,640 --> 00:37:55,640
把它

1488
00:37:55,640 --> 00:37:56,640
把可能Shellcode

1489
00:37:56,640 --> 00:37:57,640
把那些東西變成ARM

1490
00:37:57,640 --> 00:37:58,640
那其實

1491
00:37:58,640 --> 00:37:59,640
還有遇到一個問題

1492
00:37:59,640 --> 00:38:00,640
就是蠻好笑的

1493
00:38:00,640 --> 00:38:02,640
蠻有趣的問題就是

1494
00:38:02,640 --> 00:38:04,640
其實它的Policy也有變

1495
00:38:04,640 --> 00:38:06,640
就是實際手機跟Emitter上的

1496
00:38:06,640 --> 00:38:07,640
Policy有變

1497
00:38:07,640 --> 00:38:08,640
它沒有Transition到

1498
00:38:08,640 --> 00:38:10,640
Mandelbrot Part那條路

1499
00:38:10,640 --> 00:38:12,640
但是我們是選擇用Transition到

1500
00:38:12,640 --> 00:38:14,640
另外一個叫Init-Ethermode.sh

1501
00:38:14,640 --> 00:38:15,640
的另外一個路上

1502
00:38:15,640 --> 00:38:16,640
對

1503
00:38:16,640 --> 00:38:17,640
那

1504
00:38:17,640 --> 00:38:18,640
那邊的話會

1505
00:38:18,640 --> 00:38:20,640
就比較抽象跟複雜一點

1506
00:38:20,640 --> 00:38:21,640
就是

1507
00:38:21,640 --> 00:38:22,640
這邊沒有

1508
00:38:22,640 --> 00:38:23,640
沒有準備到

1509
00:38:23,640 --> 00:38:24,640
手機的本地體權

1510
00:38:24,640 --> 00:38:25,640
怎麼利用

1511
00:38:25,640 --> 00:38:27,640
的Slide

1512
00:38:27,640 --> 00:38:28,640
喔

1513
00:38:28,640 --> 00:38:29,640
喔

1514
00:38:29,640 --> 00:38:30,640
如果你是想要這個漏洞

1515
00:38:30,640 --> 00:38:31,640
到底可以做哪些

1516
00:38:31,640 --> 00:38:32,640
破壞的事情的話

1517
00:38:32,640 --> 00:38:33,640
就它只有把它包裝成

1518
00:38:33,640 --> 00:38:34,640
武器的部分的話

1519
00:38:34,640 --> 00:38:35,640
首先的話就是

1520
00:38:35,640 --> 00:38:36,640
這東西其實可以

1521
00:38:36,640 --> 00:38:37,640
包裝成一個App的

1522
00:38:37,640 --> 00:38:38,640
對

1523
00:38:38,640 --> 00:38:39,640
那我們就可以把

1524
00:38:39,640 --> 00:38:40,640
這個App散播出去

1525
00:38:40,640 --> 00:38:41,640
那只要

1526
00:38:41,640 --> 00:38:42,640
只要你載到這個App

1527
00:38:42,640 --> 00:38:43,640
你就會在我們這邊

1528
00:38:43,640 --> 00:38:44,640
彈一個Reversio出來

1529
00:38:44,640 --> 00:38:45,640
那我們就可以對你

1530
00:38:45,640 --> 00:38:46,640
做一些事情這樣

1531
00:38:46,640 --> 00:38:47,640
沒錯

1532
00:38:47,640 --> 00:38:48,640
對

1533
00:38:48,640 --> 00:38:49,640
它是可以做成App的

1534
00:38:53,640 --> 00:38:54,640
看大家還有什麼

1535
00:38:55,640 --> 00:38:56,640
問題嗎

1536
00:39:08,640 --> 00:39:09,640
硬體設計

1537
00:39:09,640 --> 00:39:11,640
有辦法避免漏洞嗎

1538
00:39:12,640 --> 00:39:13,640
嗯

1539
00:39:14,640 --> 00:39:15,640
這個

1540
00:39:15,640 --> 00:39:16,640
這個

1541
00:39:29,640 --> 00:39:30,640
這我們不是

1542
00:39:31,640 --> 00:39:32,640
很確定

1543
00:39:32,640 --> 00:39:33,640
但是

1544
00:39:33,640 --> 00:39:34,640
因為我們打的是在科農城

1545
00:39:34,640 --> 00:39:35,640
所以

1546
00:39:36,640 --> 00:39:37,640
嗯

1547
00:39:37,640 --> 00:39:38,640
硬體設計應該是

1548
00:39:38,640 --> 00:39:39,640
現在還是

1549
00:39:39,640 --> 00:39:40,640
對

1550
00:39:40,640 --> 00:39:41,640
沒辦法去避免掉這個洞

1551
00:39:43,640 --> 00:39:44,640
那能夠抓RC嗎

1552
00:39:45,640 --> 00:39:46,640
我們拿到Reversible Shell以後

1553
00:39:46,640 --> 00:39:47,640
我們就可以做

1554
00:39:47,640 --> 00:39:48,640
任何事情

1555
00:39:48,640 --> 00:39:50,640
然後我們就是在

1556
00:39:50,640 --> 00:39:51,640
用這個動作RC

1557
00:39:51,640 --> 00:39:52,640
沒錯

1558
00:39:58,640 --> 00:39:59,640
市面上

1559
00:39:59,640 --> 00:40:00,640
直接在

1560
00:40:00,640 --> 00:40:01,640
本機Root

1561
00:40:01,640 --> 00:40:02,640
嗯

1562
00:40:02,640 --> 00:40:03,640
市面上像是

1563
00:40:03,640 --> 00:40:04,640
你刷Root

1564
00:40:04,640 --> 00:40:05,640
就是你可以用

1565
00:40:05,640 --> 00:40:07,640
剛有人提到一個Magisk的Tool

1566
00:40:07,640 --> 00:40:09,640
它其實會去Page你的Boot的Image

1567
00:40:09,640 --> 00:40:11,640
就是它會去換成它自己的

1568
00:40:12,640 --> 00:40:13,640
就是它自己的

1569
00:40:13,640 --> 00:40:14,640
那個Sudo

1570
00:40:14,640 --> 00:40:15,640
或是InitProcess

1571
00:40:15,640 --> 00:40:17,640
然後會先把你的SEDs關掉

1572
00:40:17,640 --> 00:40:19,640
然後它會去註冊一個

1573
00:40:19,640 --> 00:40:21,640
AllowAllPolicy的Service上去

1574
00:40:21,640 --> 00:40:22,640
然後它就是會有Sudo

1575
00:40:22,640 --> 00:40:24,640
就是它其實可以做提權

1576
00:40:24,640 --> 00:40:25,640
就它自己Magisk

1577
00:40:25,640 --> 00:40:26,640
它其實會塞一個

1578
00:40:26,640 --> 00:40:27,640
自己的SU進去

1579
00:40:27,640 --> 00:40:29,640
所以不一定是都是用漏洞

1580
00:40:29,640 --> 00:40:30,640
有些也是用

1581
00:40:30,640 --> 00:40:31,640
它原本底層開機的時候

1582
00:40:31,640 --> 00:40:32,640
來做到的

1583
00:40:33,640 --> 00:40:34,640
但你要先Unlock不漏的

1584
00:40:34,640 --> 00:40:35,640
對 刷機的話

1585
00:40:36,640 --> 00:40:37,640
對 重點就是

1586
00:40:37,640 --> 00:40:38,640
因為Unlock不

1587
00:40:38,640 --> 00:40:39,640
為什麼要Unlock不漏的

1588
00:40:39,640 --> 00:40:41,640
就是因為Unlock完不漏的之後

1589
00:40:41,640 --> 00:40:43,640
它就才不會去做Secure Boot

1590
00:40:43,640 --> 00:40:44,640
就是會去檢查

1591
00:40:44,640 --> 00:40:46,640
你當前的Image

1592
00:40:46,640 --> 00:40:47,640
有沒有被更改過

1593
00:40:47,640 --> 00:40:49,640
但就是因為這樣子

1594
00:40:49,640 --> 00:40:50,640
所以我們沒辦法去把

1595
00:40:50,640 --> 00:40:52,640
就是它Image給改掉

1596
00:40:52,640 --> 00:40:53,640
改掉的話它就會去發現

1597
00:40:53,640 --> 00:40:54,640
在Secure Boot的時候

1598
00:40:54,640 --> 00:40:55,640
就會發現

1599
00:40:55,640 --> 00:40:56,640
欸 你改掉了

1600
00:40:56,640 --> 00:40:57,640
我們就隨時

1601
00:40:57,640 --> 00:40:58,640
然後就直接

1602
00:40:58,640 --> 00:41:00,640
直接試給你看 對

1603
00:41:00,640 --> 00:41:01,640
所以這就是為什麼

1604
00:41:01,640 --> 00:41:02,640
我們沒辦法去做到Persistent的部分

1605
00:41:02,640 --> 00:41:03,640
對 因為我們沒辦法

1606
00:41:03,640 --> 00:41:04,640
Unlock不漏的

1607
00:41:04,640 --> 00:41:06,640
對 那個東西叫做DM Vertify

1608
00:41:06,640 --> 00:41:07,640
DM Vertify

1609
00:41:07,640 --> 00:41:08,640
那你可以去

1610
00:41:08,640 --> 00:41:09,640
有興趣的可以Google

1611
00:41:09,640 --> 00:41:10,640
Android DM Vertify

1612
00:41:10,640 --> 00:41:12,640
它就是不漏的檢查的一個機制

1613
00:41:13,640 --> 00:41:15,640
它會一層一層的驗你的Hash

1614
00:41:17,640 --> 00:41:18,640
好 那時間差不多了

1615
00:41:18,640 --> 00:41:19,640
那就到這邊

1616
00:41:19,640 --> 00:41:20,640
感謝大家提問

1617
00:41:20,640 --> 00:41:21,640
幫我們撐完最後十分鐘

